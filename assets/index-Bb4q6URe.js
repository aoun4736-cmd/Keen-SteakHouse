var gh = e => { throw TypeError(e) }; var zl = (e, t, n) => t.has(e) || gh("Cannot " + n); var P = (e, t, n) => (zl(e, t, "read from private field"), n ? n.call(e) : t.get(e)), ee = (e, t, n) => t.has(e) ? gh("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, n), H = (e, t, n, r) => (zl(e, t, "write to private field"), r ? r.call(e, n) : t.set(e, n), n), Ie = (e, t, n) => (zl(e, t, "access private method"), n); var jo = (e, t, n, r) => ({ set _(s) { H(e, t, s, n) }, get _() { return P(e, t, r) } }); function b1(e, t) { for (var n = 0; n < t.length; n++) { const r = t[n]; if (typeof r != "string" && !Array.isArray(r)) { for (const s in r) if (s !== "default" && !(s in e)) { const i = Object.getOwnPropertyDescriptor(r, s); i && Object.defineProperty(e, s, i.get ? i : { enumerable: !0, get: () => r[s] }) } } } return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" })) } (function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const s of document.querySelectorAll('link[rel="modulepreload"]')) r(s); new MutationObserver(s => { for (const i of s) if (i.type === "childList") for (const o of i.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && r(o) }).observe(document, { childList: !0, subtree: !0 }); function n(s) { const i = {}; return s.integrity && (i.integrity = s.integrity), s.referrerPolicy && (i.referrerPolicy = s.referrerPolicy), s.crossOrigin === "use-credentials" ? i.credentials = "include" : s.crossOrigin === "anonymous" ? i.credentials = "omit" : i.credentials = "same-origin", i } function r(s) { if (s.ep) return; s.ep = !0; const i = n(s); fetch(s.href, i) } })(); function Ig(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e } var Fg = { exports: {} }, il = {}, Vg = { exports: {} }, X = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var ho = Symbol.for("react.element"), S1 = Symbol.for("react.portal"), C1 = Symbol.for("react.fragment"), k1 = Symbol.for("react.strict_mode"), T1 = Symbol.for("react.profiler"), E1 = Symbol.for("react.provider"), N1 = Symbol.for("react.context"), P1 = Symbol.for("react.forward_ref"), j1 = Symbol.for("react.suspense"), R1 = Symbol.for("react.memo"), A1 = Symbol.for("react.lazy"), yh = Symbol.iterator; function M1(e) { return e === null || typeof e != "object" ? null : (e = yh && e[yh] || e["@@iterator"], typeof e == "function" ? e : null) } var _g = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, zg = Object.assign, Bg = {}; function Ks(e, t, n) { this.props = e, this.context = t, this.refs = Bg, this.updater = n || _g } Ks.prototype.isReactComponent = {}; Ks.prototype.setState = function (e, t) { if (typeof e != "object" && typeof e != "function" && e != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, e, t, "setState") }; Ks.prototype.forceUpdate = function (e) { this.updater.enqueueForceUpdate(this, e, "forceUpdate") }; function $g() { } $g.prototype = Ks.prototype; function md(e, t, n) { this.props = e, this.context = t, this.refs = Bg, this.updater = n || _g } var gd = md.prototype = new $g; gd.constructor = md; zg(gd, Ks.prototype); gd.isPureReactComponent = !0; var vh = Array.isArray, Ug = Object.prototype.hasOwnProperty, yd = { current: null }, Wg = { key: !0, ref: !0, __self: !0, __source: !0 }; function Hg(e, t, n) { var r, s = {}, i = null, o = null; if (t != null) for (r in t.ref !== void 0 && (o = t.ref), t.key !== void 0 && (i = "" + t.key), t) Ug.call(t, r) && !Wg.hasOwnProperty(r) && (s[r] = t[r]); var a = arguments.length - 2; if (a === 1) s.children = n; else if (1 < a) { for (var l = Array(a), c = 0; c < a; c++)l[c] = arguments[c + 2]; s.children = l } if (e && e.defaultProps) for (r in a = e.defaultProps, a) s[r] === void 0 && (s[r] = a[r]); return { $$typeof: ho, type: e, key: i, ref: o, props: s, _owner: yd.current } } function D1(e, t) { return { $$typeof: ho, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner } } function vd(e) { return typeof e == "object" && e !== null && e.$$typeof === ho } function L1(e) { var t = { "=": "=0", ":": "=2" }; return "$" + e.replace(/[=:]/g, function (n) { return t[n] }) } var xh = /\/+/g; function Bl(e, t) { return typeof e == "object" && e !== null && e.key != null ? L1("" + e.key) : t.toString(36) } function na(e, t, n, r, s) { var i = typeof e; (i === "undefined" || i === "boolean") && (e = null); var o = !1; if (e === null) o = !0; else switch (i) { case "string": case "number": o = !0; break; case "object": switch (e.$$typeof) { case ho: case S1: o = !0 } }if (o) return o = e, s = s(o), e = r === "" ? "." + Bl(o, 0) : r, vh(s) ? (n = "", e != null && (n = e.replace(xh, "$&/") + "/"), na(s, t, n, "", function (c) { return c })) : s != null && (vd(s) && (s = D1(s, n + (!s.key || o && o.key === s.key ? "" : ("" + s.key).replace(xh, "$&/") + "/") + e)), t.push(s)), 1; if (o = 0, r = r === "" ? "." : r + ":", vh(e)) for (var a = 0; a < e.length; a++) { i = e[a]; var l = r + Bl(i, a); o += na(i, t, n, l, s) } else if (l = M1(e), typeof l == "function") for (e = l.call(e), a = 0; !(i = e.next()).done;)i = i.value, l = r + Bl(i, a++), o += na(i, t, n, l, s); else if (i === "object") throw t = String(e), Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead."); return o } function Ro(e, t, n) { if (e == null) return e; var r = [], s = 0; return na(e, r, "", "", function (i) { return t.call(n, i, s++) }), r } function O1(e) { if (e._status === -1) { var t = e._result; t = t(), t.then(function (n) { (e._status === 0 || e._status === -1) && (e._status = 1, e._result = n) }, function (n) { (e._status === 0 || e._status === -1) && (e._status = 2, e._result = n) }), e._status === -1 && (e._status = 0, e._result = t) } if (e._status === 1) return e._result.default; throw e._result } var Ge = { current: null }, ra = { transition: null }, I1 = { ReactCurrentDispatcher: Ge, ReactCurrentBatchConfig: ra, ReactCurrentOwner: yd }; function Kg() { throw Error("act(...) is not supported in production builds of React.") } X.Children = { map: Ro, forEach: function (e, t, n) { Ro(e, function () { t.apply(this, arguments) }, n) }, count: function (e) { var t = 0; return Ro(e, function () { t++ }), t }, toArray: function (e) { return Ro(e, function (t) { return t }) || [] }, only: function (e) { if (!vd(e)) throw Error("React.Children.only expected to receive a single React element child."); return e } }; X.Component = Ks; X.Fragment = C1; X.Profiler = T1; X.PureComponent = md; X.StrictMode = k1; X.Suspense = j1; X.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = I1; X.act = Kg; X.cloneElement = function (e, t, n) { if (e == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + "."); var r = zg({}, e.props), s = e.key, i = e.ref, o = e._owner; if (t != null) { if (t.ref !== void 0 && (i = t.ref, o = yd.current), t.key !== void 0 && (s = "" + t.key), e.type && e.type.defaultProps) var a = e.type.defaultProps; for (l in t) Ug.call(t, l) && !Wg.hasOwnProperty(l) && (r[l] = t[l] === void 0 && a !== void 0 ? a[l] : t[l]) } var l = arguments.length - 2; if (l === 1) r.children = n; else if (1 < l) { a = Array(l); for (var c = 0; c < l; c++)a[c] = arguments[c + 2]; r.children = a } return { $$typeof: ho, type: e.type, key: s, ref: i, props: r, _owner: o } }; X.createContext = function (e) { return e = { $$typeof: N1, _currentValue: e, _currentValue2: e, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, e.Provider = { $$typeof: E1, _context: e }, e.Consumer = e }; X.createElement = Hg; X.createFactory = function (e) { var t = Hg.bind(null, e); return t.type = e, t }; X.createRef = function () { return { current: null } }; X.forwardRef = function (e) { return { $$typeof: P1, render: e } }; X.isValidElement = vd; X.lazy = function (e) { return { $$typeof: A1, _payload: { _status: -1, _result: e }, _init: O1 } }; X.memo = function (e, t) { return { $$typeof: R1, type: e, compare: t === void 0 ? null : t } }; X.startTransition = function (e) { var t = ra.transition; ra.transition = {}; try { e() } finally { ra.transition = t } }; X.unstable_act = Kg; X.useCallback = function (e, t) { return Ge.current.useCallback(e, t) }; X.useContext = function (e) { return Ge.current.useContext(e) }; X.useDebugValue = function () { }; X.useDeferredValue = function (e) { return Ge.current.useDeferredValue(e) }; X.useEffect = function (e, t) { return Ge.current.useEffect(e, t) }; X.useId = function () { return Ge.current.useId() }; X.useImperativeHandle = function (e, t, n) { return Ge.current.useImperativeHandle(e, t, n) }; X.useInsertionEffect = function (e, t) { return Ge.current.useInsertionEffect(e, t) }; X.useLayoutEffect = function (e, t) { return Ge.current.useLayoutEffect(e, t) }; X.useMemo = function (e, t) { return Ge.current.useMemo(e, t) }; X.useReducer = function (e, t, n) { return Ge.current.useReducer(e, t, n) }; X.useRef = function (e) { return Ge.current.useRef(e) }; X.useState = function (e) { return Ge.current.useState(e) }; X.useSyncExternalStore = function (e, t, n) { return Ge.current.useSyncExternalStore(e, t, n) }; X.useTransition = function () { return Ge.current.useTransition() }; X.version = "18.3.1"; Vg.exports = X; var x = Vg.exports; const D = Ig(x), Yg = b1({ __proto__: null, default: D }, [x]);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var F1 = x, V1 = Symbol.for("react.element"), _1 = Symbol.for("react.fragment"), z1 = Object.prototype.hasOwnProperty, B1 = F1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, $1 = { key: !0, ref: !0, __self: !0, __source: !0 }; function Gg(e, t, n) { var r, s = {}, i = null, o = null; n !== void 0 && (i = "" + n), t.key !== void 0 && (i = "" + t.key), t.ref !== void 0 && (o = t.ref); for (r in t) z1.call(t, r) && !$1.hasOwnProperty(r) && (s[r] = t[r]); if (e && e.defaultProps) for (r in t = e.defaultProps, t) s[r] === void 0 && (s[r] = t[r]); return { $$typeof: V1, type: e, key: i, ref: o, props: s, _owner: B1.current } } il.Fragment = _1; il.jsx = Gg; il.jsxs = Gg; Fg.exports = il; var u = Fg.exports, Qg = { exports: {} }, ut = {}, qg = { exports: {} }, Xg = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (e) { function t(N, j) { var O = N.length; N.push(j); e: for (; 0 < O;) { var U = O - 1 >>> 1, z = N[U]; if (0 < s(z, j)) N[U] = j, N[O] = z, O = U; else break e } } function n(N) { return N.length === 0 ? null : N[0] } function r(N) { if (N.length === 0) return null; var j = N[0], O = N.pop(); if (O !== j) { N[0] = O; e: for (var U = 0, z = N.length, q = z >>> 1; U < q;) { var Z = 2 * (U + 1) - 1, we = N[Z], Oe = Z + 1, te = N[Oe]; if (0 > s(we, O)) Oe < z && 0 > s(te, we) ? (N[U] = te, N[Oe] = O, U = Oe) : (N[U] = we, N[Z] = O, U = Z); else if (Oe < z && 0 > s(te, O)) N[U] = te, N[Oe] = O, U = Oe; else break e } } return j } function s(N, j) { var O = N.sortIndex - j.sortIndex; return O !== 0 ? O : N.id - j.id } if (typeof performance == "object" && typeof performance.now == "function") { var i = performance; e.unstable_now = function () { return i.now() } } else { var o = Date, a = o.now(); e.unstable_now = function () { return o.now() - a } } var l = [], c = [], d = 1, f = null, h = 3, p = !1, w = !1, y = !1, b = typeof setTimeout == "function" ? setTimeout : null, g = typeof clearTimeout == "function" ? clearTimeout : null, m = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function v(N) { for (var j = n(c); j !== null;) { if (j.callback === null) r(c); else if (j.startTime <= N) r(c), j.sortIndex = j.expirationTime, t(l, j); else break; j = n(c) } } function S(N) { if (y = !1, v(N), !w) if (n(l) !== null) w = !0, $(C); else { var j = n(c); j !== null && V(S, j.startTime - N) } } function C(N, j) { w = !1, y && (y = !1, g(E), E = -1), p = !0; var O = h; try { for (v(j), f = n(l); f !== null && (!(f.expirationTime > j) || N && !_());) { var U = f.callback; if (typeof U == "function") { f.callback = null, h = f.priorityLevel; var z = U(f.expirationTime <= j); j = e.unstable_now(), typeof z == "function" ? f.callback = z : f === n(l) && r(l), v(j) } else r(l); f = n(l) } if (f !== null) var q = !0; else { var Z = n(c); Z !== null && V(S, Z.startTime - j), q = !1 } return q } finally { f = null, h = O, p = !1 } } var k = !1, T = null, E = -1, A = 5, R = -1; function _() { return !(e.unstable_now() - R < A) } function I() { if (T !== null) { var N = e.unstable_now(); R = N; var j = !0; try { j = T(!0, N) } finally { j ? G() : (k = !1, T = null) } } else k = !1 } var G; if (typeof m == "function") G = function () { m(I) }; else if (typeof MessageChannel < "u") { var L = new MessageChannel, Q = L.port2; L.port1.onmessage = I, G = function () { Q.postMessage(null) } } else G = function () { b(I, 0) }; function $(N) { T = N, k || (k = !0, G()) } function V(N, j) { E = b(function () { N(e.unstable_now()) }, j) } e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function (N) { N.callback = null }, e.unstable_continueExecution = function () { w || p || (w = !0, $(C)) }, e.unstable_forceFrameRate = function (N) { 0 > N || 125 < N ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : A = 0 < N ? Math.floor(1e3 / N) : 5 }, e.unstable_getCurrentPriorityLevel = function () { return h }, e.unstable_getFirstCallbackNode = function () { return n(l) }, e.unstable_next = function (N) { switch (h) { case 1: case 2: case 3: var j = 3; break; default: j = h }var O = h; h = j; try { return N() } finally { h = O } }, e.unstable_pauseExecution = function () { }, e.unstable_requestPaint = function () { }, e.unstable_runWithPriority = function (N, j) { switch (N) { case 1: case 2: case 3: case 4: case 5: break; default: N = 3 }var O = h; h = N; try { return j() } finally { h = O } }, e.unstable_scheduleCallback = function (N, j, O) { var U = e.unstable_now(); switch (typeof O == "object" && O !== null ? (O = O.delay, O = typeof O == "number" && 0 < O ? U + O : U) : O = U, N) { case 1: var z = -1; break; case 2: z = 250; break; case 5: z = 1073741823; break; case 4: z = 1e4; break; default: z = 5e3 }return z = O + z, N = { id: d++, callback: j, priorityLevel: N, startTime: O, expirationTime: z, sortIndex: -1 }, O > U ? (N.sortIndex = O, t(c, N), n(l) === null && N === n(c) && (y ? (g(E), E = -1) : y = !0, V(S, O - U))) : (N.sortIndex = z, t(l, N), w || p || (w = !0, $(C))), N }, e.unstable_shouldYield = _, e.unstable_wrapCallback = function (N) { var j = h; return function () { var O = h; h = j; try { return N.apply(this, arguments) } finally { h = O } } } })(Xg); qg.exports = Xg; var U1 = qg.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var W1 = x, ct = U1; function M(e) { for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++)t += "&args[]=" + encodeURIComponent(arguments[n]); return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var Zg = new Set, Oi = {}; function $r(e, t) { Os(e, t), Os(e + "Capture", t) } function Os(e, t) { for (Oi[e] = t, e = 0; e < t.length; e++)Zg.add(t[e]) } var hn = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Fc = Object.prototype.hasOwnProperty, H1 = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, wh = {}, bh = {}; function K1(e) { return Fc.call(bh, e) ? !0 : Fc.call(wh, e) ? !1 : H1.test(e) ? bh[e] = !0 : (wh[e] = !0, !1) } function Y1(e, t, n, r) { if (n !== null && n.type === 0) return !1; switch (typeof t) { case "function": case "symbol": return !0; case "boolean": return r ? !1 : n !== null ? !n.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== "data-" && e !== "aria-"); default: return !1 } } function G1(e, t, n, r) { if (t === null || typeof t > "u" || Y1(e, t, n, r)) return !0; if (r) return !1; if (n !== null) switch (n.type) { case 3: return !t; case 4: return t === !1; case 5: return isNaN(t); case 6: return isNaN(t) || 1 > t }return !1 } function Qe(e, t, n, r, s, i, o) { this.acceptsBooleans = t === 2 || t === 3 || t === 4, this.attributeName = r, this.attributeNamespace = s, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = o } var Le = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (e) { Le[e] = new Qe(e, 0, !1, e, null, !1, !1) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (e) { var t = e[0]; Le[t] = new Qe(t, 1, !1, e[1], null, !1, !1) });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (e) { Le[e] = new Qe(e, 2, !1, e.toLowerCase(), null, !1, !1) });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (e) { Le[e] = new Qe(e, 2, !1, e, null, !1, !1) }); "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (e) { Le[e] = new Qe(e, 3, !1, e.toLowerCase(), null, !1, !1) });["checked", "multiple", "muted", "selected"].forEach(function (e) { Le[e] = new Qe(e, 3, !0, e, null, !1, !1) });["capture", "download"].forEach(function (e) { Le[e] = new Qe(e, 4, !1, e, null, !1, !1) });["cols", "rows", "size", "span"].forEach(function (e) { Le[e] = new Qe(e, 6, !1, e, null, !1, !1) });["rowSpan", "start"].forEach(function (e) { Le[e] = new Qe(e, 5, !1, e.toLowerCase(), null, !1, !1) }); var xd = /[\-:]([a-z])/g; function wd(e) { return e[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (e) { var t = e.replace(xd, wd); Le[t] = new Qe(t, 1, !1, e, null, !1, !1) }); "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (e) { var t = e.replace(xd, wd); Le[t] = new Qe(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1) });["xml:base", "xml:lang", "xml:space"].forEach(function (e) { var t = e.replace(xd, wd); Le[t] = new Qe(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1) });["tabIndex", "crossOrigin"].forEach(function (e) { Le[e] = new Qe(e, 1, !1, e.toLowerCase(), null, !1, !1) }); Le.xlinkHref = new Qe("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (e) { Le[e] = new Qe(e, 1, !1, e.toLowerCase(), null, !0, !0) }); function bd(e, t, n, r) { var s = Le.hasOwnProperty(t) ? Le[t] : null; (s !== null ? s.type !== 0 : r || !(2 < t.length) || t[0] !== "o" && t[0] !== "O" || t[1] !== "n" && t[1] !== "N") && (G1(t, n, s, r) && (n = null), r || s === null ? K1(t) && (n === null ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : s.mustUseProperty ? e[s.propertyName] = n === null ? s.type === 3 ? !1 : "" : n : (t = s.attributeName, r = s.attributeNamespace, n === null ? e.removeAttribute(t) : (s = s.type, n = s === 3 || s === 4 && n === !0 ? "" : "" + n, r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n)))) } var bn = W1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, Ao = Symbol.for("react.element"), es = Symbol.for("react.portal"), ts = Symbol.for("react.fragment"), Sd = Symbol.for("react.strict_mode"), Vc = Symbol.for("react.profiler"), Jg = Symbol.for("react.provider"), ey = Symbol.for("react.context"), Cd = Symbol.for("react.forward_ref"), _c = Symbol.for("react.suspense"), zc = Symbol.for("react.suspense_list"), kd = Symbol.for("react.memo"), Dn = Symbol.for("react.lazy"), ty = Symbol.for("react.offscreen"), Sh = Symbol.iterator; function ii(e) { return e === null || typeof e != "object" ? null : (e = Sh && e[Sh] || e["@@iterator"], typeof e == "function" ? e : null) } var me = Object.assign, $l; function gi(e) {
  if ($l === void 0) try { throw Error() } catch (n) { var t = n.stack.trim().match(/\n( *(at )?)/); $l = t && t[1] || "" } return `
`+ $l + e
} var Ul = !1; function Wl(e, t) {
  if (!e || Ul) return ""; Ul = !0; var n = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (t) if (t = function () { throw Error() }, Object.defineProperty(t.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(t, []) } catch (c) { var r = c } Reflect.construct(e, [], t) } else { try { t.call() } catch (c) { r = c } e.call(t.prototype) } else { try { throw Error() } catch (c) { r = c } e() } } catch (c) {
    if (c && r && typeof c.stack == "string") {
      for (var s = c.stack.split(`
`), i = r.stack.split(`
`), o = s.length - 1, a = i.length - 1; 1 <= o && 0 <= a && s[o] !== i[a];)a--; for (; 1 <= o && 0 <= a; o--, a--)if (s[o] !== i[a]) {
        if (o !== 1 || a !== 1) do if (o--, a--, 0 > a || s[o] !== i[a]) {
          var l = `
`+ s[o].replace(" at new ", " at "); return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)), l
        } while (1 <= o && 0 <= a); break
      }
    }
  } finally { Ul = !1, Error.prepareStackTrace = n } return (e = e ? e.displayName || e.name : "") ? gi(e) : ""
} function Q1(e) { switch (e.tag) { case 5: return gi(e.type); case 16: return gi("Lazy"); case 13: return gi("Suspense"); case 19: return gi("SuspenseList"); case 0: case 2: case 15: return e = Wl(e.type, !1), e; case 11: return e = Wl(e.type.render, !1), e; case 1: return e = Wl(e.type, !0), e; default: return "" } } function Bc(e) { if (e == null) return null; if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e; switch (e) { case ts: return "Fragment"; case es: return "Portal"; case Vc: return "Profiler"; case Sd: return "StrictMode"; case _c: return "Suspense"; case zc: return "SuspenseList" }if (typeof e == "object") switch (e.$$typeof) { case ey: return (e.displayName || "Context") + ".Consumer"; case Jg: return (e._context.displayName || "Context") + ".Provider"; case Cd: var t = e.render; return e = e.displayName, e || (e = t.displayName || t.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case kd: return t = e.displayName || null, t !== null ? t : Bc(e.type) || "Memo"; case Dn: t = e._payload, e = e._init; try { return Bc(e(t)) } catch { } }return null } function q1(e) { var t = e.type; switch (e.tag) { case 24: return "Cache"; case 9: return (t.displayName || "Context") + ".Consumer"; case 10: return (t._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return e = t.render, e = e.displayName || e.name || "", t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return t; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return Bc(t); case 8: return t === Sd ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof t == "function") return t.displayName || t.name || null; if (typeof t == "string") return t }return null } function er(e) { switch (typeof e) { case "boolean": case "number": case "string": case "undefined": return e; case "object": return e; default: return "" } } function ny(e) { var t = e.type; return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio") } function X1(e) { var t = ny(e) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), r = "" + e[t]; if (!e.hasOwnProperty(t) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") { var s = n.get, i = n.set; return Object.defineProperty(e, t, { configurable: !0, get: function () { return s.call(this) }, set: function (o) { r = "" + o, i.call(this, o) } }), Object.defineProperty(e, t, { enumerable: n.enumerable }), { getValue: function () { return r }, setValue: function (o) { r = "" + o }, stopTracking: function () { e._valueTracker = null, delete e[t] } } } } function Mo(e) { e._valueTracker || (e._valueTracker = X1(e)) } function ry(e) { if (!e) return !1; var t = e._valueTracker; if (!t) return !0; var n = t.getValue(), r = ""; return e && (r = ny(e) ? e.checked ? "true" : "false" : e.value), e = r, e !== n ? (t.setValue(e), !0) : !1 } function ba(e) { if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null; try { return e.activeElement || e.body } catch { return e.body } } function $c(e, t) { var n = t.checked; return me({}, t, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: n ?? e._wrapperState.initialChecked }) } function Ch(e, t) { var n = t.defaultValue == null ? "" : t.defaultValue, r = t.checked != null ? t.checked : t.defaultChecked; n = er(t.value != null ? t.value : n), e._wrapperState = { initialChecked: r, initialValue: n, controlled: t.type === "checkbox" || t.type === "radio" ? t.checked != null : t.value != null } } function sy(e, t) { t = t.checked, t != null && bd(e, "checked", t, !1) } function Uc(e, t) { sy(e, t); var n = er(t.value), r = t.type; if (n != null) r === "number" ? (n === 0 && e.value === "" || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n); else if (r === "submit" || r === "reset") { e.removeAttribute("value"); return } t.hasOwnProperty("value") ? Wc(e, t.type, n) : t.hasOwnProperty("defaultValue") && Wc(e, t.type, er(t.defaultValue)), t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked) } function kh(e, t, n) { if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) { var r = t.type; if (!(r !== "submit" && r !== "reset" || t.value !== void 0 && t.value !== null)) return; t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t } n = e.name, n !== "" && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, n !== "" && (e.name = n) } function Wc(e, t, n) { (t !== "number" || ba(e.ownerDocument) !== e) && (n == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n)) } var yi = Array.isArray; function ys(e, t, n, r) { if (e = e.options, t) { t = {}; for (var s = 0; s < n.length; s++)t["$" + n[s]] = !0; for (n = 0; n < e.length; n++)s = t.hasOwnProperty("$" + e[n].value), e[n].selected !== s && (e[n].selected = s), s && r && (e[n].defaultSelected = !0) } else { for (n = "" + er(n), t = null, s = 0; s < e.length; s++) { if (e[s].value === n) { e[s].selected = !0, r && (e[s].defaultSelected = !0); return } t !== null || e[s].disabled || (t = e[s]) } t !== null && (t.selected = !0) } } function Hc(e, t) { if (t.dangerouslySetInnerHTML != null) throw Error(M(91)); return me({}, t, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue }) } function Th(e, t) { var n = t.value; if (n == null) { if (n = t.children, t = t.defaultValue, n != null) { if (t != null) throw Error(M(92)); if (yi(n)) { if (1 < n.length) throw Error(M(93)); n = n[0] } t = n } t == null && (t = ""), n = t } e._wrapperState = { initialValue: er(n) } } function iy(e, t) { var n = er(t.value), r = er(t.defaultValue); n != null && (n = "" + n, n !== e.value && (e.value = n), t.defaultValue == null && e.defaultValue !== n && (e.defaultValue = n)), r != null && (e.defaultValue = "" + r) } function Eh(e) { var t = e.textContent; t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t) } function oy(e) { switch (e) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function Kc(e, t) { return e == null || e === "http://www.w3.org/1999/xhtml" ? oy(t) : e === "http://www.w3.org/2000/svg" && t === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e } var Do, ay = function (e) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (t, n, r, s) { MSApp.execUnsafeLocalFunction(function () { return e(t, n, r, s) }) } : e }(function (e, t) { if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e) e.innerHTML = t; else { for (Do = Do || document.createElement("div"), Do.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = Do.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (; t.firstChild;)e.appendChild(t.firstChild) } }); function Ii(e, t) { if (t) { var n = e.firstChild; if (n && n === e.lastChild && n.nodeType === 3) { n.nodeValue = t; return } } e.textContent = t } var bi = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, Z1 = ["Webkit", "ms", "Moz", "O"]; Object.keys(bi).forEach(function (e) { Z1.forEach(function (t) { t = t + e.charAt(0).toUpperCase() + e.substring(1), bi[t] = bi[e] }) }); function ly(e, t, n) { return t == null || typeof t == "boolean" || t === "" ? "" : n || typeof t != "number" || t === 0 || bi.hasOwnProperty(e) && bi[e] ? ("" + t).trim() : t + "px" } function cy(e, t) { e = e.style; for (var n in t) if (t.hasOwnProperty(n)) { var r = n.indexOf("--") === 0, s = ly(n, t[n], r); n === "float" && (n = "cssFloat"), r ? e.setProperty(n, s) : e[n] = s } } var J1 = me({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function Yc(e, t) { if (t) { if (J1[e] && (t.children != null || t.dangerouslySetInnerHTML != null)) throw Error(M(137, e)); if (t.dangerouslySetInnerHTML != null) { if (t.children != null) throw Error(M(60)); if (typeof t.dangerouslySetInnerHTML != "object" || !("__html" in t.dangerouslySetInnerHTML)) throw Error(M(61)) } if (t.style != null && typeof t.style != "object") throw Error(M(62)) } } function Gc(e, t) { if (e.indexOf("-") === -1) return typeof t.is == "string"; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var Qc = null; function Td(e) { return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e } var qc = null, vs = null, xs = null; function Nh(e) { if (e = go(e)) { if (typeof qc != "function") throw Error(M(280)); var t = e.stateNode; t && (t = ul(t), qc(e.stateNode, e.type, t)) } } function uy(e) { vs ? xs ? xs.push(e) : xs = [e] : vs = e } function dy() { if (vs) { var e = vs, t = xs; if (xs = vs = null, Nh(e), t) for (e = 0; e < t.length; e++)Nh(t[e]) } } function fy(e, t) { return e(t) } function hy() { } var Hl = !1; function py(e, t, n) { if (Hl) return e(t, n); Hl = !0; try { return fy(e, t, n) } finally { Hl = !1, (vs !== null || xs !== null) && (hy(), dy()) } } function Fi(e, t) { var n = e.stateNode; if (n === null) return null; var r = ul(n); if (r === null) return null; n = r[t]; e: switch (t) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (r = !r.disabled) || (e = e.type, r = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !r; break e; default: e = !1 }if (e) return null; if (n && typeof n != "function") throw Error(M(231, t, typeof n)); return n } var Xc = !1; if (hn) try { var oi = {}; Object.defineProperty(oi, "passive", { get: function () { Xc = !0 } }), window.addEventListener("test", oi, oi), window.removeEventListener("test", oi, oi) } catch { Xc = !1 } function eb(e, t, n, r, s, i, o, a, l) { var c = Array.prototype.slice.call(arguments, 3); try { t.apply(n, c) } catch (d) { this.onError(d) } } var Si = !1, Sa = null, Ca = !1, Zc = null, tb = { onError: function (e) { Si = !0, Sa = e } }; function nb(e, t, n, r, s, i, o, a, l) { Si = !1, Sa = null, eb.apply(tb, arguments) } function rb(e, t, n, r, s, i, o, a, l) { if (nb.apply(this, arguments), Si) { if (Si) { var c = Sa; Si = !1, Sa = null } else throw Error(M(198)); Ca || (Ca = !0, Zc = c) } } function Ur(e) { var t = e, n = e; if (e.alternate) for (; t.return;)t = t.return; else { e = t; do t = e, t.flags & 4098 && (n = t.return), e = t.return; while (e) } return t.tag === 3 ? n : null } function my(e) { if (e.tag === 13) { var t = e.memoizedState; if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated } return null } function Ph(e) { if (Ur(e) !== e) throw Error(M(188)) } function sb(e) { var t = e.alternate; if (!t) { if (t = Ur(e), t === null) throw Error(M(188)); return t !== e ? null : e } for (var n = e, r = t; ;) { var s = n.return; if (s === null) break; var i = s.alternate; if (i === null) { if (r = s.return, r !== null) { n = r; continue } break } if (s.child === i.child) { for (i = s.child; i;) { if (i === n) return Ph(s), e; if (i === r) return Ph(s), t; i = i.sibling } throw Error(M(188)) } if (n.return !== r.return) n = s, r = i; else { for (var o = !1, a = s.child; a;) { if (a === n) { o = !0, n = s, r = i; break } if (a === r) { o = !0, r = s, n = i; break } a = a.sibling } if (!o) { for (a = i.child; a;) { if (a === n) { o = !0, n = i, r = s; break } if (a === r) { o = !0, r = i, n = s; break } a = a.sibling } if (!o) throw Error(M(189)) } } if (n.alternate !== r) throw Error(M(190)) } if (n.tag !== 3) throw Error(M(188)); return n.stateNode.current === n ? e : t } function gy(e) { return e = sb(e), e !== null ? yy(e) : null } function yy(e) { if (e.tag === 5 || e.tag === 6) return e; for (e = e.child; e !== null;) { var t = yy(e); if (t !== null) return t; e = e.sibling } return null } var vy = ct.unstable_scheduleCallback, jh = ct.unstable_cancelCallback, ib = ct.unstable_shouldYield, ob = ct.unstable_requestPaint, xe = ct.unstable_now, ab = ct.unstable_getCurrentPriorityLevel, Ed = ct.unstable_ImmediatePriority, xy = ct.unstable_UserBlockingPriority, ka = ct.unstable_NormalPriority, lb = ct.unstable_LowPriority, wy = ct.unstable_IdlePriority, ol = null, Qt = null; function cb(e) { if (Qt && typeof Qt.onCommitFiberRoot == "function") try { Qt.onCommitFiberRoot(ol, e, void 0, (e.current.flags & 128) === 128) } catch { } } var It = Math.clz32 ? Math.clz32 : fb, ub = Math.log, db = Math.LN2; function fb(e) { return e >>>= 0, e === 0 ? 32 : 31 - (ub(e) / db | 0) | 0 } var Lo = 64, Oo = 4194304; function vi(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return e & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e } } function Ta(e, t) { var n = e.pendingLanes; if (n === 0) return 0; var r = 0, s = e.suspendedLanes, i = e.pingedLanes, o = n & 268435455; if (o !== 0) { var a = o & ~s; a !== 0 ? r = vi(a) : (i &= o, i !== 0 && (r = vi(i))) } else o = n & ~s, o !== 0 ? r = vi(o) : i !== 0 && (r = vi(i)); if (r === 0) return 0; if (t !== 0 && t !== r && !(t & s) && (s = r & -r, i = t & -t, s >= i || s === 16 && (i & 4194240) !== 0)) return t; if (r & 4 && (r |= n & 16), t = e.entangledLanes, t !== 0) for (e = e.entanglements, t &= r; 0 < t;)n = 31 - It(t), s = 1 << n, r |= e[n], t &= ~s; return r } function hb(e, t) { switch (e) { case 1: case 2: case 4: return t + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function pb(e, t) { for (var n = e.suspendedLanes, r = e.pingedLanes, s = e.expirationTimes, i = e.pendingLanes; 0 < i;) { var o = 31 - It(i), a = 1 << o, l = s[o]; l === -1 ? (!(a & n) || a & r) && (s[o] = hb(a, t)) : l <= t && (e.expiredLanes |= a), i &= ~a } } function Jc(e) { return e = e.pendingLanes & -1073741825, e !== 0 ? e : e & 1073741824 ? 1073741824 : 0 } function by() { var e = Lo; return Lo <<= 1, !(Lo & 4194240) && (Lo = 64), e } function Kl(e) { for (var t = [], n = 0; 31 > n; n++)t.push(e); return t } function po(e, t, n) { e.pendingLanes |= t, t !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, t = 31 - It(t), e[t] = n } function mb(e, t) { var n = e.pendingLanes & ~t; e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements; var r = e.eventTimes; for (e = e.expirationTimes; 0 < n;) { var s = 31 - It(n), i = 1 << s; t[s] = 0, r[s] = -1, e[s] = -1, n &= ~i } } function Nd(e, t) { var n = e.entangledLanes |= t; for (e = e.entanglements; n;) { var r = 31 - It(n), s = 1 << r; s & t | e[r] & t && (e[r] |= t), n &= ~s } } var ne = 0; function Sy(e) { return e &= -e, 1 < e ? 4 < e ? e & 268435455 ? 16 : 536870912 : 4 : 1 } var Cy, Pd, ky, Ty, Ey, eu = !1, Io = [], Hn = null, Kn = null, Yn = null, Vi = new Map, _i = new Map, On = [], gb = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function Rh(e, t) { switch (e) { case "focusin": case "focusout": Hn = null; break; case "dragenter": case "dragleave": Kn = null; break; case "mouseover": case "mouseout": Yn = null; break; case "pointerover": case "pointerout": Vi.delete(t.pointerId); break; case "gotpointercapture": case "lostpointercapture": _i.delete(t.pointerId) } } function ai(e, t, n, r, s, i) { return e === null || e.nativeEvent !== i ? (e = { blockedOn: t, domEventName: n, eventSystemFlags: r, nativeEvent: i, targetContainers: [s] }, t !== null && (t = go(t), t !== null && Pd(t)), e) : (e.eventSystemFlags |= r, t = e.targetContainers, s !== null && t.indexOf(s) === -1 && t.push(s), e) } function yb(e, t, n, r, s) { switch (t) { case "focusin": return Hn = ai(Hn, e, t, n, r, s), !0; case "dragenter": return Kn = ai(Kn, e, t, n, r, s), !0; case "mouseover": return Yn = ai(Yn, e, t, n, r, s), !0; case "pointerover": var i = s.pointerId; return Vi.set(i, ai(Vi.get(i) || null, e, t, n, r, s)), !0; case "gotpointercapture": return i = s.pointerId, _i.set(i, ai(_i.get(i) || null, e, t, n, r, s)), !0 }return !1 } function Ny(e) { var t = wr(e.target); if (t !== null) { var n = Ur(t); if (n !== null) { if (t = n.tag, t === 13) { if (t = my(n), t !== null) { e.blockedOn = t, Ey(e.priority, function () { ky(n) }); return } } else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) { e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null; return } } } e.blockedOn = null } function sa(e) { if (e.blockedOn !== null) return !1; for (var t = e.targetContainers; 0 < t.length;) { var n = tu(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent); if (n === null) { n = e.nativeEvent; var r = new n.constructor(n.type, n); Qc = r, n.target.dispatchEvent(r), Qc = null } else return t = go(n), t !== null && Pd(t), e.blockedOn = n, !1; t.shift() } return !0 } function Ah(e, t, n) { sa(e) && n.delete(t) } function vb() { eu = !1, Hn !== null && sa(Hn) && (Hn = null), Kn !== null && sa(Kn) && (Kn = null), Yn !== null && sa(Yn) && (Yn = null), Vi.forEach(Ah), _i.forEach(Ah) } function li(e, t) { e.blockedOn === t && (e.blockedOn = null, eu || (eu = !0, ct.unstable_scheduleCallback(ct.unstable_NormalPriority, vb))) } function zi(e) { function t(s) { return li(s, e) } if (0 < Io.length) { li(Io[0], e); for (var n = 1; n < Io.length; n++) { var r = Io[n]; r.blockedOn === e && (r.blockedOn = null) } } for (Hn !== null && li(Hn, e), Kn !== null && li(Kn, e), Yn !== null && li(Yn, e), Vi.forEach(t), _i.forEach(t), n = 0; n < On.length; n++)r = On[n], r.blockedOn === e && (r.blockedOn = null); for (; 0 < On.length && (n = On[0], n.blockedOn === null);)Ny(n), n.blockedOn === null && On.shift() } var ws = bn.ReactCurrentBatchConfig, Ea = !0; function xb(e, t, n, r) { var s = ne, i = ws.transition; ws.transition = null; try { ne = 1, jd(e, t, n, r) } finally { ne = s, ws.transition = i } } function wb(e, t, n, r) { var s = ne, i = ws.transition; ws.transition = null; try { ne = 4, jd(e, t, n, r) } finally { ne = s, ws.transition = i } } function jd(e, t, n, r) { if (Ea) { var s = tu(e, t, n, r); if (s === null) nc(e, t, r, Na, n), Rh(e, r); else if (yb(s, e, t, n, r)) r.stopPropagation(); else if (Rh(e, r), t & 4 && -1 < gb.indexOf(e)) { for (; s !== null;) { var i = go(s); if (i !== null && Cy(i), i = tu(e, t, n, r), i === null && nc(e, t, r, Na, n), i === s) break; s = i } s !== null && r.stopPropagation() } else nc(e, t, r, null, n) } } var Na = null; function tu(e, t, n, r) { if (Na = null, e = Td(r), e = wr(e), e !== null) if (t = Ur(e), t === null) e = null; else if (n = t.tag, n === 13) { if (e = my(t), e !== null) return e; e = null } else if (n === 3) { if (t.stateNode.current.memoizedState.isDehydrated) return t.tag === 3 ? t.stateNode.containerInfo : null; e = null } else t !== e && (e = null); return Na = e, null } function Py(e) { switch (e) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (ab()) { case Ed: return 1; case xy: return 4; case ka: case lb: return 16; case wy: return 536870912; default: return 16 }default: return 16 } } var $n = null, Rd = null, ia = null; function jy() { if (ia) return ia; var e, t = Rd, n = t.length, r, s = "value" in $n ? $n.value : $n.textContent, i = s.length; for (e = 0; e < n && t[e] === s[e]; e++); var o = n - e; for (r = 1; r <= o && t[n - r] === s[i - r]; r++); return ia = s.slice(e, 1 < r ? 1 - r : void 0) } function oa(e) { var t = e.keyCode; return "charCode" in e ? (e = e.charCode, e === 0 && t === 13 && (e = 13)) : e = t, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0 } function Fo() { return !0 } function Mh() { return !1 } function dt(e) { function t(n, r, s, i, o) { this._reactName = n, this._targetInst = s, this.type = r, this.nativeEvent = i, this.target = o, this.currentTarget = null; for (var a in e) e.hasOwnProperty(a) && (n = e[a], this[a] = n ? n(i) : i[a]); return this.isDefaultPrevented = (i.defaultPrevented != null ? i.defaultPrevented : i.returnValue === !1) ? Fo : Mh, this.isPropagationStopped = Mh, this } return me(t.prototype, { preventDefault: function () { this.defaultPrevented = !0; var n = this.nativeEvent; n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = Fo) }, stopPropagation: function () { var n = this.nativeEvent; n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = Fo) }, persist: function () { }, isPersistent: Fo }), t } var Ys = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, Ad = dt(Ys), mo = me({}, Ys, { view: 0, detail: 0 }), bb = dt(mo), Yl, Gl, ci, al = me({}, mo, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Md, button: 0, buttons: 0, relatedTarget: function (e) { return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== ci && (ci && e.type === "mousemove" ? (Yl = e.screenX - ci.screenX, Gl = e.screenY - ci.screenY) : Gl = Yl = 0, ci = e), Yl) }, movementY: function (e) { return "movementY" in e ? e.movementY : Gl } }), Dh = dt(al), Sb = me({}, al, { dataTransfer: 0 }), Cb = dt(Sb), kb = me({}, mo, { relatedTarget: 0 }), Ql = dt(kb), Tb = me({}, Ys, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Eb = dt(Tb), Nb = me({}, Ys, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : window.clipboardData } }), Pb = dt(Nb), jb = me({}, Ys, { data: 0 }), Lh = dt(jb), Rb = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, Ab = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, Mb = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function Db(e) { var t = this.nativeEvent; return t.getModifierState ? t.getModifierState(e) : (e = Mb[e]) ? !!t[e] : !1 } function Md() { return Db } var Lb = me({}, mo, { key: function (e) { if (e.key) { var t = Rb[e.key] || e.key; if (t !== "Unidentified") return t } return e.type === "keypress" ? (e = oa(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? Ab[e.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Md, charCode: function (e) { return e.type === "keypress" ? oa(e) : 0 }, keyCode: function (e) { return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 }, which: function (e) { return e.type === "keypress" ? oa(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 } }), Ob = dt(Lb), Ib = me({}, al, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Oh = dt(Ib), Fb = me({}, mo, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Md }), Vb = dt(Fb), _b = me({}, Ys, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), zb = dt(_b), Bb = me({}, al, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), $b = dt(Bb), Ub = [9, 13, 27, 32], Dd = hn && "CompositionEvent" in window, Ci = null; hn && "documentMode" in document && (Ci = document.documentMode); var Wb = hn && "TextEvent" in window && !Ci, Ry = hn && (!Dd || Ci && 8 < Ci && 11 >= Ci), Ih = " ", Fh = !1; function Ay(e, t) { switch (e) { case "keyup": return Ub.indexOf(t.keyCode) !== -1; case "keydown": return t.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function My(e) { return e = e.detail, typeof e == "object" && "data" in e ? e.data : null } var ns = !1; function Hb(e, t) { switch (e) { case "compositionend": return My(t); case "keypress": return t.which !== 32 ? null : (Fh = !0, Ih); case "textInput": return e = t.data, e === Ih && Fh ? null : e; default: return null } } function Kb(e, t) { if (ns) return e === "compositionend" || !Dd && Ay(e, t) ? (e = jy(), ia = Rd = $n = null, ns = !1, e) : null; switch (e) { case "paste": return null; case "keypress": if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) { if (t.char && 1 < t.char.length) return t.char; if (t.which) return String.fromCharCode(t.which) } return null; case "compositionend": return Ry && t.locale !== "ko" ? null : t.data; default: return null } } var Yb = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function Vh(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t === "input" ? !!Yb[e.type] : t === "textarea" } function Dy(e, t, n, r) { uy(r), t = Pa(t, "onChange"), 0 < t.length && (n = new Ad("onChange", "change", null, n, r), e.push({ event: n, listeners: t })) } var ki = null, Bi = null; function Gb(e) { Wy(e, 0) } function ll(e) { var t = is(e); if (ry(t)) return e } function Qb(e, t) { if (e === "change") return t } var Ly = !1; if (hn) { var ql; if (hn) { var Xl = "oninput" in document; if (!Xl) { var _h = document.createElement("div"); _h.setAttribute("oninput", "return;"), Xl = typeof _h.oninput == "function" } ql = Xl } else ql = !1; Ly = ql && (!document.documentMode || 9 < document.documentMode) } function zh() { ki && (ki.detachEvent("onpropertychange", Oy), Bi = ki = null) } function Oy(e) { if (e.propertyName === "value" && ll(Bi)) { var t = []; Dy(t, Bi, e, Td(e)), py(Gb, t) } } function qb(e, t, n) { e === "focusin" ? (zh(), ki = t, Bi = n, ki.attachEvent("onpropertychange", Oy)) : e === "focusout" && zh() } function Xb(e) { if (e === "selectionchange" || e === "keyup" || e === "keydown") return ll(Bi) } function Zb(e, t) { if (e === "click") return ll(t) } function Jb(e, t) { if (e === "input" || e === "change") return ll(t) } function eS(e, t) { return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t } var Vt = typeof Object.is == "function" ? Object.is : eS; function $i(e, t) { if (Vt(e, t)) return !0; if (typeof e != "object" || e === null || typeof t != "object" || t === null) return !1; var n = Object.keys(e), r = Object.keys(t); if (n.length !== r.length) return !1; for (r = 0; r < n.length; r++) { var s = n[r]; if (!Fc.call(t, s) || !Vt(e[s], t[s])) return !1 } return !0 } function Bh(e) { for (; e && e.firstChild;)e = e.firstChild; return e } function $h(e, t) { var n = Bh(e); e = 0; for (var r; n;) { if (n.nodeType === 3) { if (r = e + n.textContent.length, e <= t && r >= t) return { node: n, offset: t - e }; e = r } e: { for (; n;) { if (n.nextSibling) { n = n.nextSibling; break e } n = n.parentNode } n = void 0 } n = Bh(n) } } function Iy(e, t) { return e && t ? e === t ? !0 : e && e.nodeType === 3 ? !1 : t && t.nodeType === 3 ? Iy(e, t.parentNode) : "contains" in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1 : !1 } function Fy() { for (var e = window, t = ba(); t instanceof e.HTMLIFrameElement;) { try { var n = typeof t.contentWindow.location.href == "string" } catch { n = !1 } if (n) e = t.contentWindow; else break; t = ba(e.document) } return t } function Ld(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true") } function tS(e) { var t = Fy(), n = e.focusedElem, r = e.selectionRange; if (t !== n && n && n.ownerDocument && Iy(n.ownerDocument.documentElement, n)) { if (r !== null && Ld(n)) { if (t = r.start, e = r.end, e === void 0 && (e = t), "selectionStart" in n) n.selectionStart = t, n.selectionEnd = Math.min(e, n.value.length); else if (e = (t = n.ownerDocument || document) && t.defaultView || window, e.getSelection) { e = e.getSelection(); var s = n.textContent.length, i = Math.min(r.start, s); r = r.end === void 0 ? i : Math.min(r.end, s), !e.extend && i > r && (s = r, r = i, i = s), s = $h(n, i); var o = $h(n, r); s && o && (e.rangeCount !== 1 || e.anchorNode !== s.node || e.anchorOffset !== s.offset || e.focusNode !== o.node || e.focusOffset !== o.offset) && (t = t.createRange(), t.setStart(s.node, s.offset), e.removeAllRanges(), i > r ? (e.addRange(t), e.extend(o.node, o.offset)) : (t.setEnd(o.node, o.offset), e.addRange(t))) } } for (t = [], e = n; e = e.parentNode;)e.nodeType === 1 && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for (typeof n.focus == "function" && n.focus(), n = 0; n < t.length; n++)e = t[n], e.element.scrollLeft = e.left, e.element.scrollTop = e.top } } var nS = hn && "documentMode" in document && 11 >= document.documentMode, rs = null, nu = null, Ti = null, ru = !1; function Uh(e, t, n) { var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument; ru || rs == null || rs !== ba(r) || (r = rs, "selectionStart" in r && Ld(r) ? r = { start: r.selectionStart, end: r.selectionEnd } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = { anchorNode: r.anchorNode, anchorOffset: r.anchorOffset, focusNode: r.focusNode, focusOffset: r.focusOffset }), Ti && $i(Ti, r) || (Ti = r, r = Pa(nu, "onSelect"), 0 < r.length && (t = new Ad("onSelect", "select", null, t, n), e.push({ event: t, listeners: r }), t.target = rs))) } function Vo(e, t) { var n = {}; return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n } var ss = { animationend: Vo("Animation", "AnimationEnd"), animationiteration: Vo("Animation", "AnimationIteration"), animationstart: Vo("Animation", "AnimationStart"), transitionend: Vo("Transition", "TransitionEnd") }, Zl = {}, Vy = {}; hn && (Vy = document.createElement("div").style, "AnimationEvent" in window || (delete ss.animationend.animation, delete ss.animationiteration.animation, delete ss.animationstart.animation), "TransitionEvent" in window || delete ss.transitionend.transition); function cl(e) { if (Zl[e]) return Zl[e]; if (!ss[e]) return e; var t = ss[e], n; for (n in t) if (t.hasOwnProperty(n) && n in Vy) return Zl[e] = t[n]; return e } var _y = cl("animationend"), zy = cl("animationiteration"), By = cl("animationstart"), $y = cl("transitionend"), Uy = new Map, Wh = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function lr(e, t) { Uy.set(e, t), $r(t, [e]) } for (var Jl = 0; Jl < Wh.length; Jl++) { var ec = Wh[Jl], rS = ec.toLowerCase(), sS = ec[0].toUpperCase() + ec.slice(1); lr(rS, "on" + sS) } lr(_y, "onAnimationEnd"); lr(zy, "onAnimationIteration"); lr(By, "onAnimationStart"); lr("dblclick", "onDoubleClick"); lr("focusin", "onFocus"); lr("focusout", "onBlur"); lr($y, "onTransitionEnd"); Os("onMouseEnter", ["mouseout", "mouseover"]); Os("onMouseLeave", ["mouseout", "mouseover"]); Os("onPointerEnter", ["pointerout", "pointerover"]); Os("onPointerLeave", ["pointerout", "pointerover"]); $r("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); $r("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); $r("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); $r("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); $r("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); $r("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var xi = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), iS = new Set("cancel close invalid load scroll toggle".split(" ").concat(xi)); function Hh(e, t, n) { var r = e.type || "unknown-event"; e.currentTarget = n, rb(r, t, void 0, e), e.currentTarget = null } function Wy(e, t) { t = (t & 4) !== 0; for (var n = 0; n < e.length; n++) { var r = e[n], s = r.event; r = r.listeners; e: { var i = void 0; if (t) for (var o = r.length - 1; 0 <= o; o--) { var a = r[o], l = a.instance, c = a.currentTarget; if (a = a.listener, l !== i && s.isPropagationStopped()) break e; Hh(s, a, c), i = l } else for (o = 0; o < r.length; o++) { if (a = r[o], l = a.instance, c = a.currentTarget, a = a.listener, l !== i && s.isPropagationStopped()) break e; Hh(s, a, c), i = l } } } if (Ca) throw e = Zc, Ca = !1, Zc = null, e } function oe(e, t) { var n = t[lu]; n === void 0 && (n = t[lu] = new Set); var r = e + "__bubble"; n.has(r) || (Hy(t, e, 2, !1), n.add(r)) } function tc(e, t, n) { var r = 0; t && (r |= 4), Hy(n, e, r, t) } var _o = "_reactListening" + Math.random().toString(36).slice(2); function Ui(e) { if (!e[_o]) { e[_o] = !0, Zg.forEach(function (n) { n !== "selectionchange" && (iS.has(n) || tc(n, !1, e), tc(n, !0, e)) }); var t = e.nodeType === 9 ? e : e.ownerDocument; t === null || t[_o] || (t[_o] = !0, tc("selectionchange", !1, t)) } } function Hy(e, t, n, r) { switch (Py(t)) { case 1: var s = xb; break; case 4: s = wb; break; default: s = jd }n = s.bind(null, t, n, e), s = void 0, !Xc || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (s = !0), r ? s !== void 0 ? e.addEventListener(t, n, { capture: !0, passive: s }) : e.addEventListener(t, n, !0) : s !== void 0 ? e.addEventListener(t, n, { passive: s }) : e.addEventListener(t, n, !1) } function nc(e, t, n, r, s) { var i = r; if (!(t & 1) && !(t & 2) && r !== null) e: for (; ;) { if (r === null) return; var o = r.tag; if (o === 3 || o === 4) { var a = r.stateNode.containerInfo; if (a === s || a.nodeType === 8 && a.parentNode === s) break; if (o === 4) for (o = r.return; o !== null;) { var l = o.tag; if ((l === 3 || l === 4) && (l = o.stateNode.containerInfo, l === s || l.nodeType === 8 && l.parentNode === s)) return; o = o.return } for (; a !== null;) { if (o = wr(a), o === null) return; if (l = o.tag, l === 5 || l === 6) { r = i = o; continue e } a = a.parentNode } } r = r.return } py(function () { var c = i, d = Td(n), f = []; e: { var h = Uy.get(e); if (h !== void 0) { var p = Ad, w = e; switch (e) { case "keypress": if (oa(n) === 0) break e; case "keydown": case "keyup": p = Ob; break; case "focusin": w = "focus", p = Ql; break; case "focusout": w = "blur", p = Ql; break; case "beforeblur": case "afterblur": p = Ql; break; case "click": if (n.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": p = Dh; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": p = Cb; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": p = Vb; break; case _y: case zy: case By: p = Eb; break; case $y: p = zb; break; case "scroll": p = bb; break; case "wheel": p = $b; break; case "copy": case "cut": case "paste": p = Pb; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": p = Oh }var y = (t & 4) !== 0, b = !y && e === "scroll", g = y ? h !== null ? h + "Capture" : null : h; y = []; for (var m = c, v; m !== null;) { v = m; var S = v.stateNode; if (v.tag === 5 && S !== null && (v = S, g !== null && (S = Fi(m, g), S != null && y.push(Wi(m, S, v)))), b) break; m = m.return } 0 < y.length && (h = new p(h, w, null, n, d), f.push({ event: h, listeners: y })) } } if (!(t & 7)) { e: { if (h = e === "mouseover" || e === "pointerover", p = e === "mouseout" || e === "pointerout", h && n !== Qc && (w = n.relatedTarget || n.fromElement) && (wr(w) || w[pn])) break e; if ((p || h) && (h = d.window === d ? d : (h = d.ownerDocument) ? h.defaultView || h.parentWindow : window, p ? (w = n.relatedTarget || n.toElement, p = c, w = w ? wr(w) : null, w !== null && (b = Ur(w), w !== b || w.tag !== 5 && w.tag !== 6) && (w = null)) : (p = null, w = c), p !== w)) { if (y = Dh, S = "onMouseLeave", g = "onMouseEnter", m = "mouse", (e === "pointerout" || e === "pointerover") && (y = Oh, S = "onPointerLeave", g = "onPointerEnter", m = "pointer"), b = p == null ? h : is(p), v = w == null ? h : is(w), h = new y(S, m + "leave", p, n, d), h.target = b, h.relatedTarget = v, S = null, wr(d) === c && (y = new y(g, m + "enter", w, n, d), y.target = v, y.relatedTarget = b, S = y), b = S, p && w) t: { for (y = p, g = w, m = 0, v = y; v; v = Jr(v))m++; for (v = 0, S = g; S; S = Jr(S))v++; for (; 0 < m - v;)y = Jr(y), m--; for (; 0 < v - m;)g = Jr(g), v--; for (; m--;) { if (y === g || g !== null && y === g.alternate) break t; y = Jr(y), g = Jr(g) } y = null } else y = null; p !== null && Kh(f, h, p, y, !1), w !== null && b !== null && Kh(f, b, w, y, !0) } } e: { if (h = c ? is(c) : window, p = h.nodeName && h.nodeName.toLowerCase(), p === "select" || p === "input" && h.type === "file") var C = Qb; else if (Vh(h)) if (Ly) C = Jb; else { C = Xb; var k = qb } else (p = h.nodeName) && p.toLowerCase() === "input" && (h.type === "checkbox" || h.type === "radio") && (C = Zb); if (C && (C = C(e, c))) { Dy(f, C, n, d); break e } k && k(e, h, c), e === "focusout" && (k = h._wrapperState) && k.controlled && h.type === "number" && Wc(h, "number", h.value) } switch (k = c ? is(c) : window, e) { case "focusin": (Vh(k) || k.contentEditable === "true") && (rs = k, nu = c, Ti = null); break; case "focusout": Ti = nu = rs = null; break; case "mousedown": ru = !0; break; case "contextmenu": case "mouseup": case "dragend": ru = !1, Uh(f, n, d); break; case "selectionchange": if (nS) break; case "keydown": case "keyup": Uh(f, n, d) }var T; if (Dd) e: { switch (e) { case "compositionstart": var E = "onCompositionStart"; break e; case "compositionend": E = "onCompositionEnd"; break e; case "compositionupdate": E = "onCompositionUpdate"; break e }E = void 0 } else ns ? Ay(e, n) && (E = "onCompositionEnd") : e === "keydown" && n.keyCode === 229 && (E = "onCompositionStart"); E && (Ry && n.locale !== "ko" && (ns || E !== "onCompositionStart" ? E === "onCompositionEnd" && ns && (T = jy()) : ($n = d, Rd = "value" in $n ? $n.value : $n.textContent, ns = !0)), k = Pa(c, E), 0 < k.length && (E = new Lh(E, e, null, n, d), f.push({ event: E, listeners: k }), T ? E.data = T : (T = My(n), T !== null && (E.data = T)))), (T = Wb ? Hb(e, n) : Kb(e, n)) && (c = Pa(c, "onBeforeInput"), 0 < c.length && (d = new Lh("onBeforeInput", "beforeinput", null, n, d), f.push({ event: d, listeners: c }), d.data = T)) } Wy(f, t) }) } function Wi(e, t, n) { return { instance: e, listener: t, currentTarget: n } } function Pa(e, t) { for (var n = t + "Capture", r = []; e !== null;) { var s = e, i = s.stateNode; s.tag === 5 && i !== null && (s = i, i = Fi(e, n), i != null && r.unshift(Wi(e, i, s)), i = Fi(e, t), i != null && r.push(Wi(e, i, s))), e = e.return } return r } function Jr(e) { if (e === null) return null; do e = e.return; while (e && e.tag !== 5); return e || null } function Kh(e, t, n, r, s) { for (var i = t._reactName, o = []; n !== null && n !== r;) { var a = n, l = a.alternate, c = a.stateNode; if (l !== null && l === r) break; a.tag === 5 && c !== null && (a = c, s ? (l = Fi(n, i), l != null && o.unshift(Wi(n, l, a))) : s || (l = Fi(n, i), l != null && o.push(Wi(n, l, a)))), n = n.return } o.length !== 0 && e.push({ event: t, listeners: o }) } var oS = /\r\n?/g, aS = /\u0000|\uFFFD/g; function Yh(e) {
  return (typeof e == "string" ? e : "" + e).replace(oS, `
`).replace(aS, "")
} function zo(e, t, n) { if (t = Yh(t), Yh(e) !== t && n) throw Error(M(425)) } function ja() { } var su = null, iu = null; function ou(e, t) { return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null } var au = typeof setTimeout == "function" ? setTimeout : void 0, lS = typeof clearTimeout == "function" ? clearTimeout : void 0, Gh = typeof Promise == "function" ? Promise : void 0, cS = typeof queueMicrotask == "function" ? queueMicrotask : typeof Gh < "u" ? function (e) { return Gh.resolve(null).then(e).catch(uS) } : au; function uS(e) { setTimeout(function () { throw e }) } function rc(e, t) { var n = t, r = 0; do { var s = n.nextSibling; if (e.removeChild(n), s && s.nodeType === 8) if (n = s.data, n === "/$") { if (r === 0) { e.removeChild(s), zi(t); return } r-- } else n !== "$" && n !== "$?" && n !== "$!" || r++; n = s } while (n); zi(t) } function Gn(e) { for (; e != null; e = e.nextSibling) { var t = e.nodeType; if (t === 1 || t === 3) break; if (t === 8) { if (t = e.data, t === "$" || t === "$!" || t === "$?") break; if (t === "/$") return null } } return e } function Qh(e) { e = e.previousSibling; for (var t = 0; e;) { if (e.nodeType === 8) { var n = e.data; if (n === "$" || n === "$!" || n === "$?") { if (t === 0) return e; t-- } else n === "/$" && t++ } e = e.previousSibling } return null } var Gs = Math.random().toString(36).slice(2), Yt = "__reactFiber$" + Gs, Hi = "__reactProps$" + Gs, pn = "__reactContainer$" + Gs, lu = "__reactEvents$" + Gs, dS = "__reactListeners$" + Gs, fS = "__reactHandles$" + Gs; function wr(e) { var t = e[Yt]; if (t) return t; for (var n = e.parentNode; n;) { if (t = n[pn] || n[Yt]) { if (n = t.alternate, t.child !== null || n !== null && n.child !== null) for (e = Qh(e); e !== null;) { if (n = e[Yt]) return n; e = Qh(e) } return t } e = n, n = e.parentNode } return null } function go(e) { return e = e[Yt] || e[pn], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e } function is(e) { if (e.tag === 5 || e.tag === 6) return e.stateNode; throw Error(M(33)) } function ul(e) { return e[Hi] || null } var cu = [], os = -1; function cr(e) { return { current: e } } function ae(e) { 0 > os || (e.current = cu[os], cu[os] = null, os--) } function se(e, t) { os++, cu[os] = e.current, e.current = t } var tr = {}, $e = cr(tr), et = cr(!1), Or = tr; function Is(e, t) { var n = e.type.contextTypes; if (!n) return tr; var r = e.stateNode; if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext; var s = {}, i; for (i in n) s[i] = t[i]; return r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = s), s } function tt(e) { return e = e.childContextTypes, e != null } function Ra() { ae(et), ae($e) } function qh(e, t, n) { if ($e.current !== tr) throw Error(M(168)); se($e, t), se(et, n) } function Ky(e, t, n) { var r = e.stateNode; if (t = t.childContextTypes, typeof r.getChildContext != "function") return n; r = r.getChildContext(); for (var s in r) if (!(s in t)) throw Error(M(108, q1(e) || "Unknown", s)); return me({}, n, r) } function Aa(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || tr, Or = $e.current, se($e, e), se(et, et.current), !0 } function Xh(e, t, n) { var r = e.stateNode; if (!r) throw Error(M(169)); n ? (e = Ky(e, t, Or), r.__reactInternalMemoizedMergedChildContext = e, ae(et), ae($e), se($e, e)) : ae(et), se(et, n) } var ln = null, dl = !1, sc = !1; function Yy(e) { ln === null ? ln = [e] : ln.push(e) } function hS(e) { dl = !0, Yy(e) } function ur() { if (!sc && ln !== null) { sc = !0; var e = 0, t = ne; try { var n = ln; for (ne = 1; e < n.length; e++) { var r = n[e]; do r = r(!0); while (r !== null) } ln = null, dl = !1 } catch (s) { throw ln !== null && (ln = ln.slice(e + 1)), vy(Ed, ur), s } finally { ne = t, sc = !1 } } return null } var as = [], ls = 0, Ma = null, Da = 0, mt = [], gt = 0, Ir = null, un = 1, dn = ""; function yr(e, t) { as[ls++] = Da, as[ls++] = Ma, Ma = e, Da = t } function Gy(e, t, n) { mt[gt++] = un, mt[gt++] = dn, mt[gt++] = Ir, Ir = e; var r = un; e = dn; var s = 32 - It(r) - 1; r &= ~(1 << s), n += 1; var i = 32 - It(t) + s; if (30 < i) { var o = s - s % 5; i = (r & (1 << o) - 1).toString(32), r >>= o, s -= o, un = 1 << 32 - It(t) + s | n << s | r, dn = i + e } else un = 1 << i | n << s | r, dn = e } function Od(e) { e.return !== null && (yr(e, 1), Gy(e, 1, 0)) } function Id(e) { for (; e === Ma;)Ma = as[--ls], as[ls] = null, Da = as[--ls], as[ls] = null; for (; e === Ir;)Ir = mt[--gt], mt[gt] = null, dn = mt[--gt], mt[gt] = null, un = mt[--gt], mt[gt] = null } var at = null, ot = null, ce = !1, Ot = null; function Qy(e, t) { var n = yt(5, null, null, 0); n.elementType = "DELETED", n.stateNode = t, n.return = e, t = e.deletions, t === null ? (e.deletions = [n], e.flags |= 16) : t.push(n) } function Zh(e, t) { switch (e.tag) { case 5: var n = e.type; return t = t.nodeType !== 1 || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t, t !== null ? (e.stateNode = t, at = e, ot = Gn(t.firstChild), !0) : !1; case 6: return t = e.pendingProps === "" || t.nodeType !== 3 ? null : t, t !== null ? (e.stateNode = t, at = e, ot = null, !0) : !1; case 13: return t = t.nodeType !== 8 ? null : t, t !== null ? (n = Ir !== null ? { id: un, overflow: dn } : null, e.memoizedState = { dehydrated: t, treeContext: n, retryLane: 1073741824 }, n = yt(18, null, null, 0), n.stateNode = t, n.return = e, e.child = n, at = e, ot = null, !0) : !1; default: return !1 } } function uu(e) { return (e.mode & 1) !== 0 && (e.flags & 128) === 0 } function du(e) { if (ce) { var t = ot; if (t) { var n = t; if (!Zh(e, t)) { if (uu(e)) throw Error(M(418)); t = Gn(n.nextSibling); var r = at; t && Zh(e, t) ? Qy(r, n) : (e.flags = e.flags & -4097 | 2, ce = !1, at = e) } } else { if (uu(e)) throw Error(M(418)); e.flags = e.flags & -4097 | 2, ce = !1, at = e } } } function Jh(e) { for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13;)e = e.return; at = e } function Bo(e) { if (e !== at) return !1; if (!ce) return Jh(e), ce = !0, !1; var t; if ((t = e.tag !== 3) && !(t = e.tag !== 5) && (t = e.type, t = t !== "head" && t !== "body" && !ou(e.type, e.memoizedProps)), t && (t = ot)) { if (uu(e)) throw qy(), Error(M(418)); for (; t;)Qy(e, t), t = Gn(t.nextSibling) } if (Jh(e), e.tag === 13) { if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(M(317)); e: { for (e = e.nextSibling, t = 0; e;) { if (e.nodeType === 8) { var n = e.data; if (n === "/$") { if (t === 0) { ot = Gn(e.nextSibling); break e } t-- } else n !== "$" && n !== "$!" && n !== "$?" || t++ } e = e.nextSibling } ot = null } } else ot = at ? Gn(e.stateNode.nextSibling) : null; return !0 } function qy() { for (var e = ot; e;)e = Gn(e.nextSibling) } function Fs() { ot = at = null, ce = !1 } function Fd(e) { Ot === null ? Ot = [e] : Ot.push(e) } var pS = bn.ReactCurrentBatchConfig; function ui(e, t, n) { if (e = n.ref, e !== null && typeof e != "function" && typeof e != "object") { if (n._owner) { if (n = n._owner, n) { if (n.tag !== 1) throw Error(M(309)); var r = n.stateNode } if (!r) throw Error(M(147, e)); var s = r, i = "" + e; return t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === i ? t.ref : (t = function (o) { var a = s.refs; o === null ? delete a[i] : a[i] = o }, t._stringRef = i, t) } if (typeof e != "string") throw Error(M(284)); if (!n._owner) throw Error(M(290, e)) } return e } function $o(e, t) { throw e = Object.prototype.toString.call(t), Error(M(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e)) } function ep(e) { var t = e._init; return t(e._payload) } function Xy(e) { function t(g, m) { if (e) { var v = g.deletions; v === null ? (g.deletions = [m], g.flags |= 16) : v.push(m) } } function n(g, m) { if (!e) return null; for (; m !== null;)t(g, m), m = m.sibling; return null } function r(g, m) { for (g = new Map; m !== null;)m.key !== null ? g.set(m.key, m) : g.set(m.index, m), m = m.sibling; return g } function s(g, m) { return g = Zn(g, m), g.index = 0, g.sibling = null, g } function i(g, m, v) { return g.index = v, e ? (v = g.alternate, v !== null ? (v = v.index, v < m ? (g.flags |= 2, m) : v) : (g.flags |= 2, m)) : (g.flags |= 1048576, m) } function o(g) { return e && g.alternate === null && (g.flags |= 2), g } function a(g, m, v, S) { return m === null || m.tag !== 6 ? (m = dc(v, g.mode, S), m.return = g, m) : (m = s(m, v), m.return = g, m) } function l(g, m, v, S) { var C = v.type; return C === ts ? d(g, m, v.props.children, S, v.key) : m !== null && (m.elementType === C || typeof C == "object" && C !== null && C.$$typeof === Dn && ep(C) === m.type) ? (S = s(m, v.props), S.ref = ui(g, m, v), S.return = g, S) : (S = ha(v.type, v.key, v.props, null, g.mode, S), S.ref = ui(g, m, v), S.return = g, S) } function c(g, m, v, S) { return m === null || m.tag !== 4 || m.stateNode.containerInfo !== v.containerInfo || m.stateNode.implementation !== v.implementation ? (m = fc(v, g.mode, S), m.return = g, m) : (m = s(m, v.children || []), m.return = g, m) } function d(g, m, v, S, C) { return m === null || m.tag !== 7 ? (m = Mr(v, g.mode, S, C), m.return = g, m) : (m = s(m, v), m.return = g, m) } function f(g, m, v) { if (typeof m == "string" && m !== "" || typeof m == "number") return m = dc("" + m, g.mode, v), m.return = g, m; if (typeof m == "object" && m !== null) { switch (m.$$typeof) { case Ao: return v = ha(m.type, m.key, m.props, null, g.mode, v), v.ref = ui(g, null, m), v.return = g, v; case es: return m = fc(m, g.mode, v), m.return = g, m; case Dn: var S = m._init; return f(g, S(m._payload), v) }if (yi(m) || ii(m)) return m = Mr(m, g.mode, v, null), m.return = g, m; $o(g, m) } return null } function h(g, m, v, S) { var C = m !== null ? m.key : null; if (typeof v == "string" && v !== "" || typeof v == "number") return C !== null ? null : a(g, m, "" + v, S); if (typeof v == "object" && v !== null) { switch (v.$$typeof) { case Ao: return v.key === C ? l(g, m, v, S) : null; case es: return v.key === C ? c(g, m, v, S) : null; case Dn: return C = v._init, h(g, m, C(v._payload), S) }if (yi(v) || ii(v)) return C !== null ? null : d(g, m, v, S, null); $o(g, v) } return null } function p(g, m, v, S, C) { if (typeof S == "string" && S !== "" || typeof S == "number") return g = g.get(v) || null, a(m, g, "" + S, C); if (typeof S == "object" && S !== null) { switch (S.$$typeof) { case Ao: return g = g.get(S.key === null ? v : S.key) || null, l(m, g, S, C); case es: return g = g.get(S.key === null ? v : S.key) || null, c(m, g, S, C); case Dn: var k = S._init; return p(g, m, v, k(S._payload), C) }if (yi(S) || ii(S)) return g = g.get(v) || null, d(m, g, S, C, null); $o(m, S) } return null } function w(g, m, v, S) { for (var C = null, k = null, T = m, E = m = 0, A = null; T !== null && E < v.length; E++) { T.index > E ? (A = T, T = null) : A = T.sibling; var R = h(g, T, v[E], S); if (R === null) { T === null && (T = A); break } e && T && R.alternate === null && t(g, T), m = i(R, m, E), k === null ? C = R : k.sibling = R, k = R, T = A } if (E === v.length) return n(g, T), ce && yr(g, E), C; if (T === null) { for (; E < v.length; E++)T = f(g, v[E], S), T !== null && (m = i(T, m, E), k === null ? C = T : k.sibling = T, k = T); return ce && yr(g, E), C } for (T = r(g, T); E < v.length; E++)A = p(T, g, E, v[E], S), A !== null && (e && A.alternate !== null && T.delete(A.key === null ? E : A.key), m = i(A, m, E), k === null ? C = A : k.sibling = A, k = A); return e && T.forEach(function (_) { return t(g, _) }), ce && yr(g, E), C } function y(g, m, v, S) { var C = ii(v); if (typeof C != "function") throw Error(M(150)); if (v = C.call(v), v == null) throw Error(M(151)); for (var k = C = null, T = m, E = m = 0, A = null, R = v.next(); T !== null && !R.done; E++, R = v.next()) { T.index > E ? (A = T, T = null) : A = T.sibling; var _ = h(g, T, R.value, S); if (_ === null) { T === null && (T = A); break } e && T && _.alternate === null && t(g, T), m = i(_, m, E), k === null ? C = _ : k.sibling = _, k = _, T = A } if (R.done) return n(g, T), ce && yr(g, E), C; if (T === null) { for (; !R.done; E++, R = v.next())R = f(g, R.value, S), R !== null && (m = i(R, m, E), k === null ? C = R : k.sibling = R, k = R); return ce && yr(g, E), C } for (T = r(g, T); !R.done; E++, R = v.next())R = p(T, g, E, R.value, S), R !== null && (e && R.alternate !== null && T.delete(R.key === null ? E : R.key), m = i(R, m, E), k === null ? C = R : k.sibling = R, k = R); return e && T.forEach(function (I) { return t(g, I) }), ce && yr(g, E), C } function b(g, m, v, S) { if (typeof v == "object" && v !== null && v.type === ts && v.key === null && (v = v.props.children), typeof v == "object" && v !== null) { switch (v.$$typeof) { case Ao: e: { for (var C = v.key, k = m; k !== null;) { if (k.key === C) { if (C = v.type, C === ts) { if (k.tag === 7) { n(g, k.sibling), m = s(k, v.props.children), m.return = g, g = m; break e } } else if (k.elementType === C || typeof C == "object" && C !== null && C.$$typeof === Dn && ep(C) === k.type) { n(g, k.sibling), m = s(k, v.props), m.ref = ui(g, k, v), m.return = g, g = m; break e } n(g, k); break } else t(g, k); k = k.sibling } v.type === ts ? (m = Mr(v.props.children, g.mode, S, v.key), m.return = g, g = m) : (S = ha(v.type, v.key, v.props, null, g.mode, S), S.ref = ui(g, m, v), S.return = g, g = S) } return o(g); case es: e: { for (k = v.key; m !== null;) { if (m.key === k) if (m.tag === 4 && m.stateNode.containerInfo === v.containerInfo && m.stateNode.implementation === v.implementation) { n(g, m.sibling), m = s(m, v.children || []), m.return = g, g = m; break e } else { n(g, m); break } else t(g, m); m = m.sibling } m = fc(v, g.mode, S), m.return = g, g = m } return o(g); case Dn: return k = v._init, b(g, m, k(v._payload), S) }if (yi(v)) return w(g, m, v, S); if (ii(v)) return y(g, m, v, S); $o(g, v) } return typeof v == "string" && v !== "" || typeof v == "number" ? (v = "" + v, m !== null && m.tag === 6 ? (n(g, m.sibling), m = s(m, v), m.return = g, g = m) : (n(g, m), m = dc(v, g.mode, S), m.return = g, g = m), o(g)) : n(g, m) } return b } var Vs = Xy(!0), Zy = Xy(!1), La = cr(null), Oa = null, cs = null, Vd = null; function _d() { Vd = cs = Oa = null } function zd(e) { var t = La.current; ae(La), e._currentValue = t } function fu(e, t, n) { for (; e !== null;) { var r = e.alternate; if ((e.childLanes & t) !== t ? (e.childLanes |= t, r !== null && (r.childLanes |= t)) : r !== null && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break; e = e.return } } function bs(e, t) { Oa = e, Vd = cs = null, e = e.dependencies, e !== null && e.firstContext !== null && (e.lanes & t && (Ze = !0), e.firstContext = null) } function bt(e) { var t = e._currentValue; if (Vd !== e) if (e = { context: e, memoizedValue: t, next: null }, cs === null) { if (Oa === null) throw Error(M(308)); cs = e, Oa.dependencies = { lanes: 0, firstContext: e } } else cs = cs.next = e; return t } var br = null; function Bd(e) { br === null ? br = [e] : br.push(e) } function Jy(e, t, n, r) { var s = t.interleaved; return s === null ? (n.next = n, Bd(t)) : (n.next = s.next, s.next = n), t.interleaved = n, mn(e, r) } function mn(e, t) { e.lanes |= t; var n = e.alternate; for (n !== null && (n.lanes |= t), n = e, e = e.return; e !== null;)e.childLanes |= t, n = e.alternate, n !== null && (n.childLanes |= t), n = e, e = e.return; return n.tag === 3 ? n.stateNode : null } var Ln = !1; function $d(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function ev(e, t) { e = e.updateQueue, t.updateQueue === e && (t.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }) } function fn(e, t) { return { eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null } } function Qn(e, t, n) { var r = e.updateQueue; if (r === null) return null; if (r = r.shared, J & 2) { var s = r.pending; return s === null ? t.next = t : (t.next = s.next, s.next = t), r.pending = t, mn(e, n) } return s = r.interleaved, s === null ? (t.next = t, Bd(r)) : (t.next = s.next, s.next = t), r.interleaved = t, mn(e, n) } function aa(e, t, n) { if (t = t.updateQueue, t !== null && (t = t.shared, (n & 4194240) !== 0)) { var r = t.lanes; r &= e.pendingLanes, n |= r, t.lanes = n, Nd(e, n) } } function tp(e, t) { var n = e.updateQueue, r = e.alternate; if (r !== null && (r = r.updateQueue, n === r)) { var s = null, i = null; if (n = n.firstBaseUpdate, n !== null) { do { var o = { eventTime: n.eventTime, lane: n.lane, tag: n.tag, payload: n.payload, callback: n.callback, next: null }; i === null ? s = i = o : i = i.next = o, n = n.next } while (n !== null); i === null ? s = i = t : i = i.next = t } else s = i = t; n = { baseState: r.baseState, firstBaseUpdate: s, lastBaseUpdate: i, shared: r.shared, effects: r.effects }, e.updateQueue = n; return } e = n.lastBaseUpdate, e === null ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t } function Ia(e, t, n, r) { var s = e.updateQueue; Ln = !1; var i = s.firstBaseUpdate, o = s.lastBaseUpdate, a = s.shared.pending; if (a !== null) { s.shared.pending = null; var l = a, c = l.next; l.next = null, o === null ? i = c : o.next = c, o = l; var d = e.alternate; d !== null && (d = d.updateQueue, a = d.lastBaseUpdate, a !== o && (a === null ? d.firstBaseUpdate = c : a.next = c, d.lastBaseUpdate = l)) } if (i !== null) { var f = s.baseState; o = 0, d = c = l = null, a = i; do { var h = a.lane, p = a.eventTime; if ((r & h) === h) { d !== null && (d = d.next = { eventTime: p, lane: 0, tag: a.tag, payload: a.payload, callback: a.callback, next: null }); e: { var w = e, y = a; switch (h = t, p = n, y.tag) { case 1: if (w = y.payload, typeof w == "function") { f = w.call(p, f, h); break e } f = w; break e; case 3: w.flags = w.flags & -65537 | 128; case 0: if (w = y.payload, h = typeof w == "function" ? w.call(p, f, h) : w, h == null) break e; f = me({}, f, h); break e; case 2: Ln = !0 } } a.callback !== null && a.lane !== 0 && (e.flags |= 64, h = s.effects, h === null ? s.effects = [a] : h.push(a)) } else p = { eventTime: p, lane: h, tag: a.tag, payload: a.payload, callback: a.callback, next: null }, d === null ? (c = d = p, l = f) : d = d.next = p, o |= h; if (a = a.next, a === null) { if (a = s.shared.pending, a === null) break; h = a, a = h.next, h.next = null, s.lastBaseUpdate = h, s.shared.pending = null } } while (!0); if (d === null && (l = f), s.baseState = l, s.firstBaseUpdate = c, s.lastBaseUpdate = d, t = s.shared.interleaved, t !== null) { s = t; do o |= s.lane, s = s.next; while (s !== t) } else i === null && (s.shared.lanes = 0); Vr |= o, e.lanes = o, e.memoizedState = f } } function np(e, t, n) { if (e = t.effects, t.effects = null, e !== null) for (t = 0; t < e.length; t++) { var r = e[t], s = r.callback; if (s !== null) { if (r.callback = null, r = n, typeof s != "function") throw Error(M(191, s)); s.call(r) } } } var yo = {}, qt = cr(yo), Ki = cr(yo), Yi = cr(yo); function Sr(e) { if (e === yo) throw Error(M(174)); return e } function Ud(e, t) { switch (se(Yi, t), se(Ki, e), se(qt, yo), e = t.nodeType, e) { case 9: case 11: t = (t = t.documentElement) ? t.namespaceURI : Kc(null, ""); break; default: e = e === 8 ? t.parentNode : t, t = e.namespaceURI || null, e = e.tagName, t = Kc(t, e) }ae(qt), se(qt, t) } function _s() { ae(qt), ae(Ki), ae(Yi) } function tv(e) { Sr(Yi.current); var t = Sr(qt.current), n = Kc(t, e.type); t !== n && (se(Ki, e), se(qt, n)) } function Wd(e) { Ki.current === e && (ae(qt), ae(Ki)) } var de = cr(0); function Fa(e) { for (var t = e; t !== null;) { if (t.tag === 13) { var n = t.memoizedState; if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return t } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) { if (t.flags & 128) return t } else if (t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return null; t = t.return } t.sibling.return = t.return, t = t.sibling } return null } var ic = []; function Hd() { for (var e = 0; e < ic.length; e++)ic[e]._workInProgressVersionPrimary = null; ic.length = 0 } var la = bn.ReactCurrentDispatcher, oc = bn.ReactCurrentBatchConfig, Fr = 0, pe = null, Ee = null, je = null, Va = !1, Ei = !1, Gi = 0, mS = 0; function Fe() { throw Error(M(321)) } function Kd(e, t) { if (t === null) return !1; for (var n = 0; n < t.length && n < e.length; n++)if (!Vt(e[n], t[n])) return !1; return !0 } function Yd(e, t, n, r, s, i) { if (Fr = i, pe = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, la.current = e === null || e.memoizedState === null ? xS : wS, e = n(r, s), Ei) { i = 0; do { if (Ei = !1, Gi = 0, 25 <= i) throw Error(M(301)); i += 1, je = Ee = null, t.updateQueue = null, la.current = bS, e = n(r, s) } while (Ei) } if (la.current = _a, t = Ee !== null && Ee.next !== null, Fr = 0, je = Ee = pe = null, Va = !1, t) throw Error(M(300)); return e } function Gd() { var e = Gi !== 0; return Gi = 0, e } function Ut() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return je === null ? pe.memoizedState = je = e : je = je.next = e, je } function St() { if (Ee === null) { var e = pe.alternate; e = e !== null ? e.memoizedState : null } else e = Ee.next; var t = je === null ? pe.memoizedState : je.next; if (t !== null) je = t, Ee = e; else { if (e === null) throw Error(M(310)); Ee = e, e = { memoizedState: Ee.memoizedState, baseState: Ee.baseState, baseQueue: Ee.baseQueue, queue: Ee.queue, next: null }, je === null ? pe.memoizedState = je = e : je = je.next = e } return je } function Qi(e, t) { return typeof t == "function" ? t(e) : t } function ac(e) { var t = St(), n = t.queue; if (n === null) throw Error(M(311)); n.lastRenderedReducer = e; var r = Ee, s = r.baseQueue, i = n.pending; if (i !== null) { if (s !== null) { var o = s.next; s.next = i.next, i.next = o } r.baseQueue = s = i, n.pending = null } if (s !== null) { i = s.next, r = r.baseState; var a = o = null, l = null, c = i; do { var d = c.lane; if ((Fr & d) === d) l !== null && (l = l.next = { lane: 0, action: c.action, hasEagerState: c.hasEagerState, eagerState: c.eagerState, next: null }), r = c.hasEagerState ? c.eagerState : e(r, c.action); else { var f = { lane: d, action: c.action, hasEagerState: c.hasEagerState, eagerState: c.eagerState, next: null }; l === null ? (a = l = f, o = r) : l = l.next = f, pe.lanes |= d, Vr |= d } c = c.next } while (c !== null && c !== i); l === null ? o = r : l.next = a, Vt(r, t.memoizedState) || (Ze = !0), t.memoizedState = r, t.baseState = o, t.baseQueue = l, n.lastRenderedState = r } if (e = n.interleaved, e !== null) { s = e; do i = s.lane, pe.lanes |= i, Vr |= i, s = s.next; while (s !== e) } else s === null && (n.lanes = 0); return [t.memoizedState, n.dispatch] } function lc(e) { var t = St(), n = t.queue; if (n === null) throw Error(M(311)); n.lastRenderedReducer = e; var r = n.dispatch, s = n.pending, i = t.memoizedState; if (s !== null) { n.pending = null; var o = s = s.next; do i = e(i, o.action), o = o.next; while (o !== s); Vt(i, t.memoizedState) || (Ze = !0), t.memoizedState = i, t.baseQueue === null && (t.baseState = i), n.lastRenderedState = i } return [i, r] } function nv() { } function rv(e, t) { var n = pe, r = St(), s = t(), i = !Vt(r.memoizedState, s); if (i && (r.memoizedState = s, Ze = !0), r = r.queue, Qd(ov.bind(null, n, r, e), [e]), r.getSnapshot !== t || i || je !== null && je.memoizedState.tag & 1) { if (n.flags |= 2048, qi(9, iv.bind(null, n, r, s, t), void 0, null), Re === null) throw Error(M(349)); Fr & 30 || sv(n, t, s) } return s } function sv(e, t, n) { e.flags |= 16384, e = { getSnapshot: t, value: n }, t = pe.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, pe.updateQueue = t, t.stores = [e]) : (n = t.stores, n === null ? t.stores = [e] : n.push(e)) } function iv(e, t, n, r) { t.value = n, t.getSnapshot = r, av(t) && lv(e) } function ov(e, t, n) { return n(function () { av(t) && lv(e) }) } function av(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !Vt(e, n) } catch { return !0 } } function lv(e) { var t = mn(e, 1); t !== null && Ft(t, e, 1, -1) } function rp(e) { var t = Ut(); return typeof e == "function" && (e = e()), t.memoizedState = t.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Qi, lastRenderedState: e }, t.queue = e, e = e.dispatch = vS.bind(null, pe, e), [t.memoizedState, e] } function qi(e, t, n, r) { return e = { tag: e, create: t, destroy: n, deps: r, next: null }, t = pe.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, pe.updateQueue = t, t.lastEffect = e.next = e) : (n = t.lastEffect, n === null ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e)), e } function cv() { return St().memoizedState } function ca(e, t, n, r) { var s = Ut(); pe.flags |= e, s.memoizedState = qi(1 | t, n, void 0, r === void 0 ? null : r) } function fl(e, t, n, r) { var s = St(); r = r === void 0 ? null : r; var i = void 0; if (Ee !== null) { var o = Ee.memoizedState; if (i = o.destroy, r !== null && Kd(r, o.deps)) { s.memoizedState = qi(t, n, i, r); return } } pe.flags |= e, s.memoizedState = qi(1 | t, n, i, r) } function sp(e, t) { return ca(8390656, 8, e, t) } function Qd(e, t) { return fl(2048, 8, e, t) } function uv(e, t) { return fl(4, 2, e, t) } function dv(e, t) { return fl(4, 4, e, t) } function fv(e, t) { if (typeof t == "function") return e = e(), t(e), function () { t(null) }; if (t != null) return e = e(), t.current = e, function () { t.current = null } } function hv(e, t, n) { return n = n != null ? n.concat([e]) : null, fl(4, 4, fv.bind(null, t, e), n) } function qd() { } function pv(e, t) { var n = St(); t = t === void 0 ? null : t; var r = n.memoizedState; return r !== null && t !== null && Kd(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e) } function mv(e, t) { var n = St(); t = t === void 0 ? null : t; var r = n.memoizedState; return r !== null && t !== null && Kd(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [e, t], e) } function gv(e, t, n) { return Fr & 21 ? (Vt(n, t) || (n = by(), pe.lanes |= n, Vr |= n, e.baseState = !0), t) : (e.baseState && (e.baseState = !1, Ze = !0), e.memoizedState = n) } function gS(e, t) { var n = ne; ne = n !== 0 && 4 > n ? n : 4, e(!0); var r = oc.transition; oc.transition = {}; try { e(!1), t() } finally { ne = n, oc.transition = r } } function yv() { return St().memoizedState } function yS(e, t, n) { var r = Xn(e); if (n = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }, vv(e)) xv(t, n); else if (n = Jy(e, t, n, r), n !== null) { var s = Ye(); Ft(n, e, r, s), wv(n, t, r) } } function vS(e, t, n) { var r = Xn(e), s = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }; if (vv(e)) xv(t, s); else { var i = e.alternate; if (e.lanes === 0 && (i === null || i.lanes === 0) && (i = t.lastRenderedReducer, i !== null)) try { var o = t.lastRenderedState, a = i(o, n); if (s.hasEagerState = !0, s.eagerState = a, Vt(a, o)) { var l = t.interleaved; l === null ? (s.next = s, Bd(t)) : (s.next = l.next, l.next = s), t.interleaved = s; return } } catch { } finally { } n = Jy(e, t, s, r), n !== null && (s = Ye(), Ft(n, e, r, s), wv(n, t, r)) } } function vv(e) { var t = e.alternate; return e === pe || t !== null && t === pe } function xv(e, t) { Ei = Va = !0; var n = e.pending; n === null ? t.next = t : (t.next = n.next, n.next = t), e.pending = t } function wv(e, t, n) { if (n & 4194240) { var r = t.lanes; r &= e.pendingLanes, n |= r, t.lanes = n, Nd(e, n) } } var _a = { readContext: bt, useCallback: Fe, useContext: Fe, useEffect: Fe, useImperativeHandle: Fe, useInsertionEffect: Fe, useLayoutEffect: Fe, useMemo: Fe, useReducer: Fe, useRef: Fe, useState: Fe, useDebugValue: Fe, useDeferredValue: Fe, useTransition: Fe, useMutableSource: Fe, useSyncExternalStore: Fe, useId: Fe, unstable_isNewReconciler: !1 }, xS = { readContext: bt, useCallback: function (e, t) { return Ut().memoizedState = [e, t === void 0 ? null : t], e }, useContext: bt, useEffect: sp, useImperativeHandle: function (e, t, n) { return n = n != null ? n.concat([e]) : null, ca(4194308, 4, fv.bind(null, t, e), n) }, useLayoutEffect: function (e, t) { return ca(4194308, 4, e, t) }, useInsertionEffect: function (e, t) { return ca(4, 2, e, t) }, useMemo: function (e, t) { var n = Ut(); return t = t === void 0 ? null : t, e = e(), n.memoizedState = [e, t], e }, useReducer: function (e, t, n) { var r = Ut(); return t = n !== void 0 ? n(t) : t, r.memoizedState = r.baseState = t, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: t }, r.queue = e, e = e.dispatch = yS.bind(null, pe, e), [r.memoizedState, e] }, useRef: function (e) { var t = Ut(); return e = { current: e }, t.memoizedState = e }, useState: rp, useDebugValue: qd, useDeferredValue: function (e) { return Ut().memoizedState = e }, useTransition: function () { var e = rp(!1), t = e[0]; return e = gS.bind(null, e[1]), Ut().memoizedState = e, [t, e] }, useMutableSource: function () { }, useSyncExternalStore: function (e, t, n) { var r = pe, s = Ut(); if (ce) { if (n === void 0) throw Error(M(407)); n = n() } else { if (n = t(), Re === null) throw Error(M(349)); Fr & 30 || sv(r, t, n) } s.memoizedState = n; var i = { value: n, getSnapshot: t }; return s.queue = i, sp(ov.bind(null, r, i, e), [e]), r.flags |= 2048, qi(9, iv.bind(null, r, i, n, t), void 0, null), n }, useId: function () { var e = Ut(), t = Re.identifierPrefix; if (ce) { var n = dn, r = un; n = (r & ~(1 << 32 - It(r) - 1)).toString(32) + n, t = ":" + t + "R" + n, n = Gi++, 0 < n && (t += "H" + n.toString(32)), t += ":" } else n = mS++, t = ":" + t + "r" + n.toString(32) + ":"; return e.memoizedState = t }, unstable_isNewReconciler: !1 }, wS = { readContext: bt, useCallback: pv, useContext: bt, useEffect: Qd, useImperativeHandle: hv, useInsertionEffect: uv, useLayoutEffect: dv, useMemo: mv, useReducer: ac, useRef: cv, useState: function () { return ac(Qi) }, useDebugValue: qd, useDeferredValue: function (e) { var t = St(); return gv(t, Ee.memoizedState, e) }, useTransition: function () { var e = ac(Qi)[0], t = St().memoizedState; return [e, t] }, useMutableSource: nv, useSyncExternalStore: rv, useId: yv, unstable_isNewReconciler: !1 }, bS = { readContext: bt, useCallback: pv, useContext: bt, useEffect: Qd, useImperativeHandle: hv, useInsertionEffect: uv, useLayoutEffect: dv, useMemo: mv, useReducer: lc, useRef: cv, useState: function () { return lc(Qi) }, useDebugValue: qd, useDeferredValue: function (e) { var t = St(); return Ee === null ? t.memoizedState = e : gv(t, Ee.memoizedState, e) }, useTransition: function () { var e = lc(Qi)[0], t = St().memoizedState; return [e, t] }, useMutableSource: nv, useSyncExternalStore: rv, useId: yv, unstable_isNewReconciler: !1 }; function Rt(e, t) { if (e && e.defaultProps) { t = me({}, t), e = e.defaultProps; for (var n in e) t[n] === void 0 && (t[n] = e[n]); return t } return t } function hu(e, t, n, r) { t = e.memoizedState, n = n(r, t), n = n == null ? t : me({}, t, n), e.memoizedState = n, e.lanes === 0 && (e.updateQueue.baseState = n) } var hl = { isMounted: function (e) { return (e = e._reactInternals) ? Ur(e) === e : !1 }, enqueueSetState: function (e, t, n) { e = e._reactInternals; var r = Ye(), s = Xn(e), i = fn(r, s); i.payload = t, n != null && (i.callback = n), t = Qn(e, i, s), t !== null && (Ft(t, e, s, r), aa(t, e, s)) }, enqueueReplaceState: function (e, t, n) { e = e._reactInternals; var r = Ye(), s = Xn(e), i = fn(r, s); i.tag = 1, i.payload = t, n != null && (i.callback = n), t = Qn(e, i, s), t !== null && (Ft(t, e, s, r), aa(t, e, s)) }, enqueueForceUpdate: function (e, t) { e = e._reactInternals; var n = Ye(), r = Xn(e), s = fn(n, r); s.tag = 2, t != null && (s.callback = t), t = Qn(e, s, r), t !== null && (Ft(t, e, r, n), aa(t, e, r)) } }; function ip(e, t, n, r, s, i, o) { return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(r, i, o) : t.prototype && t.prototype.isPureReactComponent ? !$i(n, r) || !$i(s, i) : !0 } function bv(e, t, n) { var r = !1, s = tr, i = t.contextType; return typeof i == "object" && i !== null ? i = bt(i) : (s = tt(t) ? Or : $e.current, r = t.contextTypes, i = (r = r != null) ? Is(e, s) : tr), t = new t(n, i), e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null, t.updater = hl, e.stateNode = t, t._reactInternals = e, r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = s, e.__reactInternalMemoizedMaskedChildContext = i), t } function op(e, t, n, r) { e = t.state, typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(n, r), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && hl.enqueueReplaceState(t, t.state, null) } function pu(e, t, n, r) { var s = e.stateNode; s.props = n, s.state = e.memoizedState, s.refs = {}, $d(e); var i = t.contextType; typeof i == "object" && i !== null ? s.context = bt(i) : (i = tt(t) ? Or : $e.current, s.context = Is(e, i)), s.state = e.memoizedState, i = t.getDerivedStateFromProps, typeof i == "function" && (hu(e, t, i, n), s.state = e.memoizedState), typeof t.getDerivedStateFromProps == "function" || typeof s.getSnapshotBeforeUpdate == "function" || typeof s.UNSAFE_componentWillMount != "function" && typeof s.componentWillMount != "function" || (t = s.state, typeof s.componentWillMount == "function" && s.componentWillMount(), typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount(), t !== s.state && hl.enqueueReplaceState(s, s.state, null), Ia(e, n, s, r), s.state = e.memoizedState), typeof s.componentDidMount == "function" && (e.flags |= 4194308) } function zs(e, t) {
  try { var n = "", r = t; do n += Q1(r), r = r.return; while (r); var s = n } catch (i) {
    s = `
Error generating stack: `+ i.message + `
`+ i.stack
  } return { value: e, source: t, stack: s, digest: null }
} function cc(e, t, n) { return { value: e, source: null, stack: n ?? null, digest: t ?? null } } function mu(e, t) { try { console.error(t.value) } catch (n) { setTimeout(function () { throw n }) } } var SS = typeof WeakMap == "function" ? WeakMap : Map; function Sv(e, t, n) { n = fn(-1, n), n.tag = 3, n.payload = { element: null }; var r = t.value; return n.callback = function () { Ba || (Ba = !0, Tu = r), mu(e, t) }, n } function Cv(e, t, n) { n = fn(-1, n), n.tag = 3; var r = e.type.getDerivedStateFromError; if (typeof r == "function") { var s = t.value; n.payload = function () { return r(s) }, n.callback = function () { mu(e, t) } } var i = e.stateNode; return i !== null && typeof i.componentDidCatch == "function" && (n.callback = function () { mu(e, t), typeof r != "function" && (qn === null ? qn = new Set([this]) : qn.add(this)); var o = t.stack; this.componentDidCatch(t.value, { componentStack: o !== null ? o : "" }) }), n } function ap(e, t, n) { var r = e.pingCache; if (r === null) { r = e.pingCache = new SS; var s = new Set; r.set(t, s) } else s = r.get(t), s === void 0 && (s = new Set, r.set(t, s)); s.has(n) || (s.add(n), e = IS.bind(null, e, t, n), t.then(e, e)) } function lp(e) { do { var t; if ((t = e.tag === 13) && (t = e.memoizedState, t = t !== null ? t.dehydrated !== null : !0), t) return e; e = e.return } while (e !== null); return null } function cp(e, t, n, r, s) { return e.mode & 1 ? (e.flags |= 65536, e.lanes = s, e) : (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (t = fn(-1, 1), t.tag = 2, Qn(n, t, 1))), n.lanes |= 1), e) } var CS = bn.ReactCurrentOwner, Ze = !1; function We(e, t, n, r) { t.child = e === null ? Zy(t, null, n, r) : Vs(t, e.child, n, r) } function up(e, t, n, r, s) { n = n.render; var i = t.ref; return bs(t, s), r = Yd(e, t, n, r, i, s), n = Gd(), e !== null && !Ze ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~s, gn(e, t, s)) : (ce && n && Od(t), t.flags |= 1, We(e, t, r, s), t.child) } function dp(e, t, n, r, s) { if (e === null) { var i = n.type; return typeof i == "function" && !sf(i) && i.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (t.tag = 15, t.type = i, kv(e, t, i, r, s)) : (e = ha(n.type, null, r, t, t.mode, s), e.ref = t.ref, e.return = t, t.child = e) } if (i = e.child, !(e.lanes & s)) { var o = i.memoizedProps; if (n = n.compare, n = n !== null ? n : $i, n(o, r) && e.ref === t.ref) return gn(e, t, s) } return t.flags |= 1, e = Zn(i, r), e.ref = t.ref, e.return = t, t.child = e } function kv(e, t, n, r, s) { if (e !== null) { var i = e.memoizedProps; if ($i(i, r) && e.ref === t.ref) if (Ze = !1, t.pendingProps = r = i, (e.lanes & s) !== 0) e.flags & 131072 && (Ze = !0); else return t.lanes = e.lanes, gn(e, t, s) } return gu(e, t, n, r, s) } function Tv(e, t, n) { var r = t.pendingProps, s = r.children, i = e !== null ? e.memoizedState : null; if (r.mode === "hidden") if (!(t.mode & 1)) t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, se(ds, st), st |= n; else { if (!(n & 1073741824)) return e = i !== null ? i.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, t.updateQueue = null, se(ds, st), st |= e, null; t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, r = i !== null ? i.baseLanes : n, se(ds, st), st |= r } else i !== null ? (r = i.baseLanes | n, t.memoizedState = null) : r = n, se(ds, st), st |= r; return We(e, t, s, n), t.child } function Ev(e, t) { var n = t.ref; (e === null && n !== null || e !== null && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152) } function gu(e, t, n, r, s) { var i = tt(n) ? Or : $e.current; return i = Is(t, i), bs(t, s), n = Yd(e, t, n, r, i, s), r = Gd(), e !== null && !Ze ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~s, gn(e, t, s)) : (ce && r && Od(t), t.flags |= 1, We(e, t, n, s), t.child) } function fp(e, t, n, r, s) { if (tt(n)) { var i = !0; Aa(t) } else i = !1; if (bs(t, s), t.stateNode === null) ua(e, t), bv(t, n, r), pu(t, n, r, s), r = !0; else if (e === null) { var o = t.stateNode, a = t.memoizedProps; o.props = a; var l = o.context, c = n.contextType; typeof c == "object" && c !== null ? c = bt(c) : (c = tt(n) ? Or : $e.current, c = Is(t, c)); var d = n.getDerivedStateFromProps, f = typeof d == "function" || typeof o.getSnapshotBeforeUpdate == "function"; f || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== r || l !== c) && op(t, o, r, c), Ln = !1; var h = t.memoizedState; o.state = h, Ia(t, r, o, s), l = t.memoizedState, a !== r || h !== l || et.current || Ln ? (typeof d == "function" && (hu(t, n, d, r), l = t.memoizedState), (a = Ln || ip(t, n, a, r, h, l, c)) ? (f || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()), typeof o.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = l), o.props = r, o.state = l, o.context = c, r = a) : (typeof o.componentDidMount == "function" && (t.flags |= 4194308), r = !1) } else { o = t.stateNode, ev(e, t), a = t.memoizedProps, c = t.type === t.elementType ? a : Rt(t.type, a), o.props = c, f = t.pendingProps, h = o.context, l = n.contextType, typeof l == "object" && l !== null ? l = bt(l) : (l = tt(n) ? Or : $e.current, l = Is(t, l)); var p = n.getDerivedStateFromProps; (d = typeof p == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== f || h !== l) && op(t, o, r, l), Ln = !1, h = t.memoizedState, o.state = h, Ia(t, r, o, s); var w = t.memoizedState; a !== f || h !== w || et.current || Ln ? (typeof p == "function" && (hu(t, n, p, r), w = t.memoizedState), (c = Ln || ip(t, n, c, r, h, w, l) || !1) ? (d || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(r, w, l), typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(r, w, l)), typeof o.componentDidUpdate == "function" && (t.flags |= 4), typeof o.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = w), o.props = r, o.state = w, o.context = l, r = c) : (typeof o.componentDidUpdate != "function" || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), r = !1) } return yu(e, t, n, r, i, s) } function yu(e, t, n, r, s, i) { Ev(e, t); var o = (t.flags & 128) !== 0; if (!r && !o) return s && Xh(t, n, !1), gn(e, t, i); r = t.stateNode, CS.current = t; var a = o && typeof n.getDerivedStateFromError != "function" ? null : r.render(); return t.flags |= 1, e !== null && o ? (t.child = Vs(t, e.child, null, i), t.child = Vs(t, null, a, i)) : We(e, t, a, i), t.memoizedState = r.state, s && Xh(t, n, !0), t.child } function Nv(e) { var t = e.stateNode; t.pendingContext ? qh(e, t.pendingContext, t.pendingContext !== t.context) : t.context && qh(e, t.context, !1), Ud(e, t.containerInfo) } function hp(e, t, n, r, s) { return Fs(), Fd(s), t.flags |= 256, We(e, t, n, r), t.child } var vu = { dehydrated: null, treeContext: null, retryLane: 0 }; function xu(e) { return { baseLanes: e, cachePool: null, transitions: null } } function Pv(e, t, n) { var r = t.pendingProps, s = de.current, i = !1, o = (t.flags & 128) !== 0, a; if ((a = o) || (a = e !== null && e.memoizedState === null ? !1 : (s & 2) !== 0), a ? (i = !0, t.flags &= -129) : (e === null || e.memoizedState !== null) && (s |= 1), se(de, s & 1), e === null) return du(t), e = t.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? (t.mode & 1 ? e.data === "$!" ? t.lanes = 8 : t.lanes = 1073741824 : t.lanes = 1, null) : (o = r.children, e = r.fallback, i ? (r = t.mode, i = t.child, o = { mode: "hidden", children: o }, !(r & 1) && i !== null ? (i.childLanes = 0, i.pendingProps = o) : i = gl(o, r, 0, null), e = Mr(e, r, n, null), i.return = t, e.return = t, i.sibling = e, t.child = i, t.child.memoizedState = xu(n), t.memoizedState = vu, e) : Xd(t, o)); if (s = e.memoizedState, s !== null && (a = s.dehydrated, a !== null)) return kS(e, t, o, r, a, s, n); if (i) { i = r.fallback, o = t.mode, s = e.child, a = s.sibling; var l = { mode: "hidden", children: r.children }; return !(o & 1) && t.child !== s ? (r = t.child, r.childLanes = 0, r.pendingProps = l, t.deletions = null) : (r = Zn(s, l), r.subtreeFlags = s.subtreeFlags & 14680064), a !== null ? i = Zn(a, i) : (i = Mr(i, o, n, null), i.flags |= 2), i.return = t, r.return = t, r.sibling = i, t.child = r, r = i, i = t.child, o = e.child.memoizedState, o = o === null ? xu(n) : { baseLanes: o.baseLanes | n, cachePool: null, transitions: o.transitions }, i.memoizedState = o, i.childLanes = e.childLanes & ~n, t.memoizedState = vu, r } return i = e.child, e = i.sibling, r = Zn(i, { mode: "visible", children: r.children }), !(t.mode & 1) && (r.lanes = n), r.return = t, r.sibling = null, e !== null && (n = t.deletions, n === null ? (t.deletions = [e], t.flags |= 16) : n.push(e)), t.child = r, t.memoizedState = null, r } function Xd(e, t) { return t = gl({ mode: "visible", children: t }, e.mode, 0, null), t.return = e, e.child = t } function Uo(e, t, n, r) { return r !== null && Fd(r), Vs(t, e.child, null, n), e = Xd(t, t.pendingProps.children), e.flags |= 2, t.memoizedState = null, e } function kS(e, t, n, r, s, i, o) { if (n) return t.flags & 256 ? (t.flags &= -257, r = cc(Error(M(422))), Uo(e, t, o, r)) : t.memoizedState !== null ? (t.child = e.child, t.flags |= 128, null) : (i = r.fallback, s = t.mode, r = gl({ mode: "visible", children: r.children }, s, 0, null), i = Mr(i, s, o, null), i.flags |= 2, r.return = t, i.return = t, r.sibling = i, t.child = r, t.mode & 1 && Vs(t, e.child, null, o), t.child.memoizedState = xu(o), t.memoizedState = vu, i); if (!(t.mode & 1)) return Uo(e, t, o, null); if (s.data === "$!") { if (r = s.nextSibling && s.nextSibling.dataset, r) var a = r.dgst; return r = a, i = Error(M(419)), r = cc(i, r, void 0), Uo(e, t, o, r) } if (a = (o & e.childLanes) !== 0, Ze || a) { if (r = Re, r !== null) { switch (o & -o) { case 4: s = 2; break; case 16: s = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: s = 32; break; case 536870912: s = 268435456; break; default: s = 0 }s = s & (r.suspendedLanes | o) ? 0 : s, s !== 0 && s !== i.retryLane && (i.retryLane = s, mn(e, s), Ft(r, e, s, -1)) } return rf(), r = cc(Error(M(421))), Uo(e, t, o, r) } return s.data === "$?" ? (t.flags |= 128, t.child = e.child, t = FS.bind(null, e), s._reactRetry = t, null) : (e = i.treeContext, ot = Gn(s.nextSibling), at = t, ce = !0, Ot = null, e !== null && (mt[gt++] = un, mt[gt++] = dn, mt[gt++] = Ir, un = e.id, dn = e.overflow, Ir = t), t = Xd(t, r.children), t.flags |= 4096, t) } function pp(e, t, n) { e.lanes |= t; var r = e.alternate; r !== null && (r.lanes |= t), fu(e.return, t, n) } function uc(e, t, n, r, s) { var i = e.memoizedState; i === null ? e.memoizedState = { isBackwards: t, rendering: null, renderingStartTime: 0, last: r, tail: n, tailMode: s } : (i.isBackwards = t, i.rendering = null, i.renderingStartTime = 0, i.last = r, i.tail = n, i.tailMode = s) } function jv(e, t, n) { var r = t.pendingProps, s = r.revealOrder, i = r.tail; if (We(e, t, r.children, n), r = de.current, r & 2) r = r & 1 | 2, t.flags |= 128; else { if (e !== null && e.flags & 128) e: for (e = t.child; e !== null;) { if (e.tag === 13) e.memoizedState !== null && pp(e, n, t); else if (e.tag === 19) pp(e, n, t); else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === t) break e; for (; e.sibling === null;) { if (e.return === null || e.return === t) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } r &= 1 } if (se(de, r), !(t.mode & 1)) t.memoizedState = null; else switch (s) { case "forwards": for (n = t.child, s = null; n !== null;)e = n.alternate, e !== null && Fa(e) === null && (s = n), n = n.sibling; n = s, n === null ? (s = t.child, t.child = null) : (s = n.sibling, n.sibling = null), uc(t, !1, s, n, i); break; case "backwards": for (n = null, s = t.child, t.child = null; s !== null;) { if (e = s.alternate, e !== null && Fa(e) === null) { t.child = s; break } e = s.sibling, s.sibling = n, n = s, s = e } uc(t, !0, n, null, i); break; case "together": uc(t, !1, null, null, void 0); break; default: t.memoizedState = null }return t.child } function ua(e, t) { !(t.mode & 1) && e !== null && (e.alternate = null, t.alternate = null, t.flags |= 2) } function gn(e, t, n) { if (e !== null && (t.dependencies = e.dependencies), Vr |= t.lanes, !(n & t.childLanes)) return null; if (e !== null && t.child !== e.child) throw Error(M(153)); if (t.child !== null) { for (e = t.child, n = Zn(e, e.pendingProps), t.child = n, n.return = t; e.sibling !== null;)e = e.sibling, n = n.sibling = Zn(e, e.pendingProps), n.return = t; n.sibling = null } return t.child } function TS(e, t, n) { switch (t.tag) { case 3: Nv(t), Fs(); break; case 5: tv(t); break; case 1: tt(t.type) && Aa(t); break; case 4: Ud(t, t.stateNode.containerInfo); break; case 10: var r = t.type._context, s = t.memoizedProps.value; se(La, r._currentValue), r._currentValue = s; break; case 13: if (r = t.memoizedState, r !== null) return r.dehydrated !== null ? (se(de, de.current & 1), t.flags |= 128, null) : n & t.child.childLanes ? Pv(e, t, n) : (se(de, de.current & 1), e = gn(e, t, n), e !== null ? e.sibling : null); se(de, de.current & 1); break; case 19: if (r = (n & t.childLanes) !== 0, e.flags & 128) { if (r) return jv(e, t, n); t.flags |= 128 } if (s = t.memoizedState, s !== null && (s.rendering = null, s.tail = null, s.lastEffect = null), se(de, de.current), r) break; return null; case 22: case 23: return t.lanes = 0, Tv(e, t, n) }return gn(e, t, n) } var Rv, wu, Av, Mv; Rv = function (e, t) { for (var n = t.child; n !== null;) { if (n.tag === 5 || n.tag === 6) e.appendChild(n.stateNode); else if (n.tag !== 4 && n.child !== null) { n.child.return = n, n = n.child; continue } if (n === t) break; for (; n.sibling === null;) { if (n.return === null || n.return === t) return; n = n.return } n.sibling.return = n.return, n = n.sibling } }; wu = function () { }; Av = function (e, t, n, r) { var s = e.memoizedProps; if (s !== r) { e = t.stateNode, Sr(qt.current); var i = null; switch (n) { case "input": s = $c(e, s), r = $c(e, r), i = []; break; case "select": s = me({}, s, { value: void 0 }), r = me({}, r, { value: void 0 }), i = []; break; case "textarea": s = Hc(e, s), r = Hc(e, r), i = []; break; default: typeof s.onClick != "function" && typeof r.onClick == "function" && (e.onclick = ja) }Yc(n, r); var o; n = null; for (c in s) if (!r.hasOwnProperty(c) && s.hasOwnProperty(c) && s[c] != null) if (c === "style") { var a = s[c]; for (o in a) a.hasOwnProperty(o) && (n || (n = {}), n[o] = "") } else c !== "dangerouslySetInnerHTML" && c !== "children" && c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && c !== "autoFocus" && (Oi.hasOwnProperty(c) ? i || (i = []) : (i = i || []).push(c, null)); for (c in r) { var l = r[c]; if (a = s != null ? s[c] : void 0, r.hasOwnProperty(c) && l !== a && (l != null || a != null)) if (c === "style") if (a) { for (o in a) !a.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (n || (n = {}), n[o] = ""); for (o in l) l.hasOwnProperty(o) && a[o] !== l[o] && (n || (n = {}), n[o] = l[o]) } else n || (i || (i = []), i.push(c, n)), n = l; else c === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, a = a ? a.__html : void 0, l != null && a !== l && (i = i || []).push(c, l)) : c === "children" ? typeof l != "string" && typeof l != "number" || (i = i || []).push(c, "" + l) : c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && (Oi.hasOwnProperty(c) ? (l != null && c === "onScroll" && oe("scroll", e), i || a === l || (i = [])) : (i = i || []).push(c, l)) } n && (i = i || []).push("style", n); var c = i; (t.updateQueue = c) && (t.flags |= 4) } }; Mv = function (e, t, n, r) { n !== r && (t.flags |= 4) }; function di(e, t) { if (!ce) switch (e.tailMode) { case "hidden": t = e.tail; for (var n = null; t !== null;)t.alternate !== null && (n = t), t = t.sibling; n === null ? e.tail = null : n.sibling = null; break; case "collapsed": n = e.tail; for (var r = null; n !== null;)n.alternate !== null && (r = n), n = n.sibling; r === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : r.sibling = null } } function Ve(e) { var t = e.alternate !== null && e.alternate.child === e.child, n = 0, r = 0; if (t) for (var s = e.child; s !== null;)n |= s.lanes | s.childLanes, r |= s.subtreeFlags & 14680064, r |= s.flags & 14680064, s.return = e, s = s.sibling; else for (s = e.child; s !== null;)n |= s.lanes | s.childLanes, r |= s.subtreeFlags, r |= s.flags, s.return = e, s = s.sibling; return e.subtreeFlags |= r, e.childLanes = n, t } function ES(e, t, n) { var r = t.pendingProps; switch (Id(t), t.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Ve(t), null; case 1: return tt(t.type) && Ra(), Ve(t), null; case 3: return r = t.stateNode, _s(), ae(et), ae($e), Hd(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (e === null || e.child === null) && (Bo(t) ? t.flags |= 4 : e === null || e.memoizedState.isDehydrated && !(t.flags & 256) || (t.flags |= 1024, Ot !== null && (Pu(Ot), Ot = null))), wu(e, t), Ve(t), null; case 5: Wd(t); var s = Sr(Yi.current); if (n = t.type, e !== null && t.stateNode != null) Av(e, t, n, r, s), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152); else { if (!r) { if (t.stateNode === null) throw Error(M(166)); return Ve(t), null } if (e = Sr(qt.current), Bo(t)) { r = t.stateNode, n = t.type; var i = t.memoizedProps; switch (r[Yt] = t, r[Hi] = i, e = (t.mode & 1) !== 0, n) { case "dialog": oe("cancel", r), oe("close", r); break; case "iframe": case "object": case "embed": oe("load", r); break; case "video": case "audio": for (s = 0; s < xi.length; s++)oe(xi[s], r); break; case "source": oe("error", r); break; case "img": case "image": case "link": oe("error", r), oe("load", r); break; case "details": oe("toggle", r); break; case "input": Ch(r, i), oe("invalid", r); break; case "select": r._wrapperState = { wasMultiple: !!i.multiple }, oe("invalid", r); break; case "textarea": Th(r, i), oe("invalid", r) }Yc(n, i), s = null; for (var o in i) if (i.hasOwnProperty(o)) { var a = i[o]; o === "children" ? typeof a == "string" ? r.textContent !== a && (i.suppressHydrationWarning !== !0 && zo(r.textContent, a, e), s = ["children", a]) : typeof a == "number" && r.textContent !== "" + a && (i.suppressHydrationWarning !== !0 && zo(r.textContent, a, e), s = ["children", "" + a]) : Oi.hasOwnProperty(o) && a != null && o === "onScroll" && oe("scroll", r) } switch (n) { case "input": Mo(r), kh(r, i, !0); break; case "textarea": Mo(r), Eh(r); break; case "select": case "option": break; default: typeof i.onClick == "function" && (r.onclick = ja) }r = s, t.updateQueue = r, r !== null && (t.flags |= 4) } else { o = s.nodeType === 9 ? s : s.ownerDocument, e === "http://www.w3.org/1999/xhtml" && (e = oy(n)), e === "http://www.w3.org/1999/xhtml" ? n === "script" ? (e = o.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : typeof r.is == "string" ? e = o.createElement(n, { is: r.is }) : (e = o.createElement(n), n === "select" && (o = e, r.multiple ? o.multiple = !0 : r.size && (o.size = r.size))) : e = o.createElementNS(e, n), e[Yt] = t, e[Hi] = r, Rv(e, t, !1, !1), t.stateNode = e; e: { switch (o = Gc(n, r), n) { case "dialog": oe("cancel", e), oe("close", e), s = r; break; case "iframe": case "object": case "embed": oe("load", e), s = r; break; case "video": case "audio": for (s = 0; s < xi.length; s++)oe(xi[s], e); s = r; break; case "source": oe("error", e), s = r; break; case "img": case "image": case "link": oe("error", e), oe("load", e), s = r; break; case "details": oe("toggle", e), s = r; break; case "input": Ch(e, r), s = $c(e, r), oe("invalid", e); break; case "option": s = r; break; case "select": e._wrapperState = { wasMultiple: !!r.multiple }, s = me({}, r, { value: void 0 }), oe("invalid", e); break; case "textarea": Th(e, r), s = Hc(e, r), oe("invalid", e); break; default: s = r }Yc(n, s), a = s; for (i in a) if (a.hasOwnProperty(i)) { var l = a[i]; i === "style" ? cy(e, l) : i === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, l != null && ay(e, l)) : i === "children" ? typeof l == "string" ? (n !== "textarea" || l !== "") && Ii(e, l) : typeof l == "number" && Ii(e, "" + l) : i !== "suppressContentEditableWarning" && i !== "suppressHydrationWarning" && i !== "autoFocus" && (Oi.hasOwnProperty(i) ? l != null && i === "onScroll" && oe("scroll", e) : l != null && bd(e, i, l, o)) } switch (n) { case "input": Mo(e), kh(e, r, !1); break; case "textarea": Mo(e), Eh(e); break; case "option": r.value != null && e.setAttribute("value", "" + er(r.value)); break; case "select": e.multiple = !!r.multiple, i = r.value, i != null ? ys(e, !!r.multiple, i, !1) : r.defaultValue != null && ys(e, !!r.multiple, r.defaultValue, !0); break; default: typeof s.onClick == "function" && (e.onclick = ja) }switch (n) { case "button": case "input": case "select": case "textarea": r = !!r.autoFocus; break e; case "img": r = !0; break e; default: r = !1 } } r && (t.flags |= 4) } t.ref !== null && (t.flags |= 512, t.flags |= 2097152) } return Ve(t), null; case 6: if (e && t.stateNode != null) Mv(e, t, e.memoizedProps, r); else { if (typeof r != "string" && t.stateNode === null) throw Error(M(166)); if (n = Sr(Yi.current), Sr(qt.current), Bo(t)) { if (r = t.stateNode, n = t.memoizedProps, r[Yt] = t, (i = r.nodeValue !== n) && (e = at, e !== null)) switch (e.tag) { case 3: zo(r.nodeValue, n, (e.mode & 1) !== 0); break; case 5: e.memoizedProps.suppressHydrationWarning !== !0 && zo(r.nodeValue, n, (e.mode & 1) !== 0) }i && (t.flags |= 4) } else r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r), r[Yt] = t, t.stateNode = r } return Ve(t), null; case 13: if (ae(de), r = t.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) { if (ce && ot !== null && t.mode & 1 && !(t.flags & 128)) qy(), Fs(), t.flags |= 98560, i = !1; else if (i = Bo(t), r !== null && r.dehydrated !== null) { if (e === null) { if (!i) throw Error(M(318)); if (i = t.memoizedState, i = i !== null ? i.dehydrated : null, !i) throw Error(M(317)); i[Yt] = t } else Fs(), !(t.flags & 128) && (t.memoizedState = null), t.flags |= 4; Ve(t), i = !1 } else Ot !== null && (Pu(Ot), Ot = null), i = !0; if (!i) return t.flags & 65536 ? t : null } return t.flags & 128 ? (t.lanes = n, t) : (r = r !== null, r !== (e !== null && e.memoizedState !== null) && r && (t.child.flags |= 8192, t.mode & 1 && (e === null || de.current & 1 ? Pe === 0 && (Pe = 3) : rf())), t.updateQueue !== null && (t.flags |= 4), Ve(t), null); case 4: return _s(), wu(e, t), e === null && Ui(t.stateNode.containerInfo), Ve(t), null; case 10: return zd(t.type._context), Ve(t), null; case 17: return tt(t.type) && Ra(), Ve(t), null; case 19: if (ae(de), i = t.memoizedState, i === null) return Ve(t), null; if (r = (t.flags & 128) !== 0, o = i.rendering, o === null) if (r) di(i, !1); else { if (Pe !== 0 || e !== null && e.flags & 128) for (e = t.child; e !== null;) { if (o = Fa(e), o !== null) { for (t.flags |= 128, di(i, !1), r = o.updateQueue, r !== null && (t.updateQueue = r, t.flags |= 4), t.subtreeFlags = 0, r = n, n = t.child; n !== null;)i = n, e = r, i.flags &= 14680066, o = i.alternate, o === null ? (i.childLanes = 0, i.lanes = e, i.child = null, i.subtreeFlags = 0, i.memoizedProps = null, i.memoizedState = null, i.updateQueue = null, i.dependencies = null, i.stateNode = null) : (i.childLanes = o.childLanes, i.lanes = o.lanes, i.child = o.child, i.subtreeFlags = 0, i.deletions = null, i.memoizedProps = o.memoizedProps, i.memoizedState = o.memoizedState, i.updateQueue = o.updateQueue, i.type = o.type, e = o.dependencies, i.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }), n = n.sibling; return se(de, de.current & 1 | 2), t.child } e = e.sibling } i.tail !== null && xe() > Bs && (t.flags |= 128, r = !0, di(i, !1), t.lanes = 4194304) } else { if (!r) if (e = Fa(o), e !== null) { if (t.flags |= 128, r = !0, n = e.updateQueue, n !== null && (t.updateQueue = n, t.flags |= 4), di(i, !0), i.tail === null && i.tailMode === "hidden" && !o.alternate && !ce) return Ve(t), null } else 2 * xe() - i.renderingStartTime > Bs && n !== 1073741824 && (t.flags |= 128, r = !0, di(i, !1), t.lanes = 4194304); i.isBackwards ? (o.sibling = t.child, t.child = o) : (n = i.last, n !== null ? n.sibling = o : t.child = o, i.last = o) } return i.tail !== null ? (t = i.tail, i.rendering = t, i.tail = t.sibling, i.renderingStartTime = xe(), t.sibling = null, n = de.current, se(de, r ? n & 1 | 2 : n & 1), t) : (Ve(t), null); case 22: case 23: return nf(), r = t.memoizedState !== null, e !== null && e.memoizedState !== null !== r && (t.flags |= 8192), r && t.mode & 1 ? st & 1073741824 && (Ve(t), t.subtreeFlags & 6 && (t.flags |= 8192)) : Ve(t), null; case 24: return null; case 25: return null }throw Error(M(156, t.tag)) } function NS(e, t) { switch (Id(t), t.tag) { case 1: return tt(t.type) && Ra(), e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 3: return _s(), ae(et), ae($e), Hd(), e = t.flags, e & 65536 && !(e & 128) ? (t.flags = e & -65537 | 128, t) : null; case 5: return Wd(t), null; case 13: if (ae(de), e = t.memoizedState, e !== null && e.dehydrated !== null) { if (t.alternate === null) throw Error(M(340)); Fs() } return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 19: return ae(de), null; case 4: return _s(), null; case 10: return zd(t.type._context), null; case 22: case 23: return nf(), null; case 24: return null; default: return null } } var Wo = !1, ze = !1, PS = typeof WeakSet == "function" ? WeakSet : Set, F = null; function us(e, t) { var n = e.ref; if (n !== null) if (typeof n == "function") try { n(null) } catch (r) { ve(e, t, r) } else n.current = null } function bu(e, t, n) { try { n() } catch (r) { ve(e, t, r) } } var mp = !1; function jS(e, t) { if (su = Ea, e = Fy(), Ld(e)) { if ("selectionStart" in e) var n = { start: e.selectionStart, end: e.selectionEnd }; else e: { n = (n = e.ownerDocument) && n.defaultView || window; var r = n.getSelection && n.getSelection(); if (r && r.rangeCount !== 0) { n = r.anchorNode; var s = r.anchorOffset, i = r.focusNode; r = r.focusOffset; try { n.nodeType, i.nodeType } catch { n = null; break e } var o = 0, a = -1, l = -1, c = 0, d = 0, f = e, h = null; t: for (; ;) { for (var p; f !== n || s !== 0 && f.nodeType !== 3 || (a = o + s), f !== i || r !== 0 && f.nodeType !== 3 || (l = o + r), f.nodeType === 3 && (o += f.nodeValue.length), (p = f.firstChild) !== null;)h = f, f = p; for (; ;) { if (f === e) break t; if (h === n && ++c === s && (a = o), h === i && ++d === r && (l = o), (p = f.nextSibling) !== null) break; f = h, h = f.parentNode } f = p } n = a === -1 || l === -1 ? null : { start: a, end: l } } else n = null } n = n || { start: 0, end: 0 } } else n = null; for (iu = { focusedElem: e, selectionRange: n }, Ea = !1, F = t; F !== null;)if (t = F, e = t.child, (t.subtreeFlags & 1028) !== 0 && e !== null) e.return = t, F = e; else for (; F !== null;) { t = F; try { var w = t.alternate; if (t.flags & 1024) switch (t.tag) { case 0: case 11: case 15: break; case 1: if (w !== null) { var y = w.memoizedProps, b = w.memoizedState, g = t.stateNode, m = g.getSnapshotBeforeUpdate(t.elementType === t.type ? y : Rt(t.type, y), b); g.__reactInternalSnapshotBeforeUpdate = m } break; case 3: var v = t.stateNode.containerInfo; v.nodeType === 1 ? v.textContent = "" : v.nodeType === 9 && v.documentElement && v.removeChild(v.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(M(163)) } } catch (S) { ve(t, t.return, S) } if (e = t.sibling, e !== null) { e.return = t.return, F = e; break } F = t.return } return w = mp, mp = !1, w } function Ni(e, t, n) { var r = t.updateQueue; if (r = r !== null ? r.lastEffect : null, r !== null) { var s = r = r.next; do { if ((s.tag & e) === e) { var i = s.destroy; s.destroy = void 0, i !== void 0 && bu(t, n, i) } s = s.next } while (s !== r) } } function pl(e, t) { if (t = t.updateQueue, t = t !== null ? t.lastEffect : null, t !== null) { var n = t = t.next; do { if ((n.tag & e) === e) { var r = n.create; n.destroy = r() } n = n.next } while (n !== t) } } function Su(e) { var t = e.ref; if (t !== null) { var n = e.stateNode; switch (e.tag) { case 5: e = n; break; default: e = n }typeof t == "function" ? t(e) : t.current = e } } function Dv(e) { var t = e.alternate; t !== null && (e.alternate = null, Dv(t)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (t = e.stateNode, t !== null && (delete t[Yt], delete t[Hi], delete t[lu], delete t[dS], delete t[fS])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } function Lv(e) { return e.tag === 5 || e.tag === 3 || e.tag === 4 } function gp(e) { e: for (; ;) { for (; e.sibling === null;) { if (e.return === null || Lv(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) { if (e.flags & 2 || e.child === null || e.tag === 4) continue e; e.child.return = e, e = e.child } if (!(e.flags & 2)) return e.stateNode } } function Cu(e, t, n) { var r = e.tag; if (r === 5 || r === 6) e = e.stateNode, t ? n.nodeType === 8 ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (n.nodeType === 8 ? (t = n.parentNode, t.insertBefore(e, n)) : (t = n, t.appendChild(e)), n = n._reactRootContainer, n != null || t.onclick !== null || (t.onclick = ja)); else if (r !== 4 && (e = e.child, e !== null)) for (Cu(e, t, n), e = e.sibling; e !== null;)Cu(e, t, n), e = e.sibling } function ku(e, t, n) { var r = e.tag; if (r === 5 || r === 6) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e); else if (r !== 4 && (e = e.child, e !== null)) for (ku(e, t, n), e = e.sibling; e !== null;)ku(e, t, n), e = e.sibling } var Ae = null, Lt = !1; function Pn(e, t, n) { for (n = n.child; n !== null;)Ov(e, t, n), n = n.sibling } function Ov(e, t, n) { if (Qt && typeof Qt.onCommitFiberUnmount == "function") try { Qt.onCommitFiberUnmount(ol, n) } catch { } switch (n.tag) { case 5: ze || us(n, t); case 6: var r = Ae, s = Lt; Ae = null, Pn(e, t, n), Ae = r, Lt = s, Ae !== null && (Lt ? (e = Ae, n = n.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(n) : e.removeChild(n)) : Ae.removeChild(n.stateNode)); break; case 18: Ae !== null && (Lt ? (e = Ae, n = n.stateNode, e.nodeType === 8 ? rc(e.parentNode, n) : e.nodeType === 1 && rc(e, n), zi(e)) : rc(Ae, n.stateNode)); break; case 4: r = Ae, s = Lt, Ae = n.stateNode.containerInfo, Lt = !0, Pn(e, t, n), Ae = r, Lt = s; break; case 0: case 11: case 14: case 15: if (!ze && (r = n.updateQueue, r !== null && (r = r.lastEffect, r !== null))) { s = r = r.next; do { var i = s, o = i.destroy; i = i.tag, o !== void 0 && (i & 2 || i & 4) && bu(n, t, o), s = s.next } while (s !== r) } Pn(e, t, n); break; case 1: if (!ze && (us(n, t), r = n.stateNode, typeof r.componentWillUnmount == "function")) try { r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount() } catch (a) { ve(n, t, a) } Pn(e, t, n); break; case 21: Pn(e, t, n); break; case 22: n.mode & 1 ? (ze = (r = ze) || n.memoizedState !== null, Pn(e, t, n), ze = r) : Pn(e, t, n); break; default: Pn(e, t, n) } } function yp(e) { var t = e.updateQueue; if (t !== null) { e.updateQueue = null; var n = e.stateNode; n === null && (n = e.stateNode = new PS), t.forEach(function (r) { var s = VS.bind(null, e, r); n.has(r) || (n.add(r), r.then(s, s)) }) } } function Et(e, t) { var n = t.deletions; if (n !== null) for (var r = 0; r < n.length; r++) { var s = n[r]; try { var i = e, o = t, a = o; e: for (; a !== null;) { switch (a.tag) { case 5: Ae = a.stateNode, Lt = !1; break e; case 3: Ae = a.stateNode.containerInfo, Lt = !0; break e; case 4: Ae = a.stateNode.containerInfo, Lt = !0; break e }a = a.return } if (Ae === null) throw Error(M(160)); Ov(i, o, s), Ae = null, Lt = !1; var l = s.alternate; l !== null && (l.return = null), s.return = null } catch (c) { ve(s, t, c) } } if (t.subtreeFlags & 12854) for (t = t.child; t !== null;)Iv(t, e), t = t.sibling } function Iv(e, t) { var n = e.alternate, r = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: if (Et(t, e), $t(e), r & 4) { try { Ni(3, e, e.return), pl(3, e) } catch (y) { ve(e, e.return, y) } try { Ni(5, e, e.return) } catch (y) { ve(e, e.return, y) } } break; case 1: Et(t, e), $t(e), r & 512 && n !== null && us(n, n.return); break; case 5: if (Et(t, e), $t(e), r & 512 && n !== null && us(n, n.return), e.flags & 32) { var s = e.stateNode; try { Ii(s, "") } catch (y) { ve(e, e.return, y) } } if (r & 4 && (s = e.stateNode, s != null)) { var i = e.memoizedProps, o = n !== null ? n.memoizedProps : i, a = e.type, l = e.updateQueue; if (e.updateQueue = null, l !== null) try { a === "input" && i.type === "radio" && i.name != null && sy(s, i), Gc(a, o); var c = Gc(a, i); for (o = 0; o < l.length; o += 2) { var d = l[o], f = l[o + 1]; d === "style" ? cy(s, f) : d === "dangerouslySetInnerHTML" ? ay(s, f) : d === "children" ? Ii(s, f) : bd(s, d, f, c) } switch (a) { case "input": Uc(s, i); break; case "textarea": iy(s, i); break; case "select": var h = s._wrapperState.wasMultiple; s._wrapperState.wasMultiple = !!i.multiple; var p = i.value; p != null ? ys(s, !!i.multiple, p, !1) : h !== !!i.multiple && (i.defaultValue != null ? ys(s, !!i.multiple, i.defaultValue, !0) : ys(s, !!i.multiple, i.multiple ? [] : "", !1)) }s[Hi] = i } catch (y) { ve(e, e.return, y) } } break; case 6: if (Et(t, e), $t(e), r & 4) { if (e.stateNode === null) throw Error(M(162)); s = e.stateNode, i = e.memoizedProps; try { s.nodeValue = i } catch (y) { ve(e, e.return, y) } } break; case 3: if (Et(t, e), $t(e), r & 4 && n !== null && n.memoizedState.isDehydrated) try { zi(t.containerInfo) } catch (y) { ve(e, e.return, y) } break; case 4: Et(t, e), $t(e); break; case 13: Et(t, e), $t(e), s = e.child, s.flags & 8192 && (i = s.memoizedState !== null, s.stateNode.isHidden = i, !i || s.alternate !== null && s.alternate.memoizedState !== null || (ef = xe())), r & 4 && yp(e); break; case 22: if (d = n !== null && n.memoizedState !== null, e.mode & 1 ? (ze = (c = ze) || d, Et(t, e), ze = c) : Et(t, e), $t(e), r & 8192) { if (c = e.memoizedState !== null, (e.stateNode.isHidden = c) && !d && e.mode & 1) for (F = e, d = e.child; d !== null;) { for (f = F = d; F !== null;) { switch (h = F, p = h.child, h.tag) { case 0: case 11: case 14: case 15: Ni(4, h, h.return); break; case 1: us(h, h.return); var w = h.stateNode; if (typeof w.componentWillUnmount == "function") { r = h, n = h.return; try { t = r, w.props = t.memoizedProps, w.state = t.memoizedState, w.componentWillUnmount() } catch (y) { ve(r, n, y) } } break; case 5: us(h, h.return); break; case 22: if (h.memoizedState !== null) { xp(f); continue } }p !== null ? (p.return = h, F = p) : xp(f) } d = d.sibling } e: for (d = null, f = e; ;) { if (f.tag === 5) { if (d === null) { d = f; try { s = f.stateNode, c ? (i = s.style, typeof i.setProperty == "function" ? i.setProperty("display", "none", "important") : i.display = "none") : (a = f.stateNode, l = f.memoizedProps.style, o = l != null && l.hasOwnProperty("display") ? l.display : null, a.style.display = ly("display", o)) } catch (y) { ve(e, e.return, y) } } } else if (f.tag === 6) { if (d === null) try { f.stateNode.nodeValue = c ? "" : f.memoizedProps } catch (y) { ve(e, e.return, y) } } else if ((f.tag !== 22 && f.tag !== 23 || f.memoizedState === null || f === e) && f.child !== null) { f.child.return = f, f = f.child; continue } if (f === e) break e; for (; f.sibling === null;) { if (f.return === null || f.return === e) break e; d === f && (d = null), f = f.return } d === f && (d = null), f.sibling.return = f.return, f = f.sibling } } break; case 19: Et(t, e), $t(e), r & 4 && yp(e); break; case 21: break; default: Et(t, e), $t(e) } } function $t(e) { var t = e.flags; if (t & 2) { try { e: { for (var n = e.return; n !== null;) { if (Lv(n)) { var r = n; break e } n = n.return } throw Error(M(160)) } switch (r.tag) { case 5: var s = r.stateNode; r.flags & 32 && (Ii(s, ""), r.flags &= -33); var i = gp(e); ku(e, i, s); break; case 3: case 4: var o = r.stateNode.containerInfo, a = gp(e); Cu(e, a, o); break; default: throw Error(M(161)) } } catch (l) { ve(e, e.return, l) } e.flags &= -3 } t & 4096 && (e.flags &= -4097) } function RS(e, t, n) { F = e, Fv(e) } function Fv(e, t, n) { for (var r = (e.mode & 1) !== 0; F !== null;) { var s = F, i = s.child; if (s.tag === 22 && r) { var o = s.memoizedState !== null || Wo; if (!o) { var a = s.alternate, l = a !== null && a.memoizedState !== null || ze; a = Wo; var c = ze; if (Wo = o, (ze = l) && !c) for (F = s; F !== null;)o = F, l = o.child, o.tag === 22 && o.memoizedState !== null ? wp(s) : l !== null ? (l.return = o, F = l) : wp(s); for (; i !== null;)F = i, Fv(i), i = i.sibling; F = s, Wo = a, ze = c } vp(e) } else s.subtreeFlags & 8772 && i !== null ? (i.return = s, F = i) : vp(e) } } function vp(e) { for (; F !== null;) { var t = F; if (t.flags & 8772) { var n = t.alternate; try { if (t.flags & 8772) switch (t.tag) { case 0: case 11: case 15: ze || pl(5, t); break; case 1: var r = t.stateNode; if (t.flags & 4 && !ze) if (n === null) r.componentDidMount(); else { var s = t.elementType === t.type ? n.memoizedProps : Rt(t.type, n.memoizedProps); r.componentDidUpdate(s, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate) } var i = t.updateQueue; i !== null && np(t, i, r); break; case 3: var o = t.updateQueue; if (o !== null) { if (n = null, t.child !== null) switch (t.child.tag) { case 5: n = t.child.stateNode; break; case 1: n = t.child.stateNode }np(t, o, n) } break; case 5: var a = t.stateNode; if (n === null && t.flags & 4) { n = a; var l = t.memoizedProps; switch (t.type) { case "button": case "input": case "select": case "textarea": l.autoFocus && n.focus(); break; case "img": l.src && (n.src = l.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (t.memoizedState === null) { var c = t.alternate; if (c !== null) { var d = c.memoizedState; if (d !== null) { var f = d.dehydrated; f !== null && zi(f) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(M(163)) }ze || t.flags & 512 && Su(t) } catch (h) { ve(t, t.return, h) } } if (t === e) { F = null; break } if (n = t.sibling, n !== null) { n.return = t.return, F = n; break } F = t.return } } function xp(e) { for (; F !== null;) { var t = F; if (t === e) { F = null; break } var n = t.sibling; if (n !== null) { n.return = t.return, F = n; break } F = t.return } } function wp(e) { for (; F !== null;) { var t = F; try { switch (t.tag) { case 0: case 11: case 15: var n = t.return; try { pl(4, t) } catch (l) { ve(t, n, l) } break; case 1: var r = t.stateNode; if (typeof r.componentDidMount == "function") { var s = t.return; try { r.componentDidMount() } catch (l) { ve(t, s, l) } } var i = t.return; try { Su(t) } catch (l) { ve(t, i, l) } break; case 5: var o = t.return; try { Su(t) } catch (l) { ve(t, o, l) } } } catch (l) { ve(t, t.return, l) } if (t === e) { F = null; break } var a = t.sibling; if (a !== null) { a.return = t.return, F = a; break } F = t.return } } var AS = Math.ceil, za = bn.ReactCurrentDispatcher, Zd = bn.ReactCurrentOwner, xt = bn.ReactCurrentBatchConfig, J = 0, Re = null, Se = null, De = 0, st = 0, ds = cr(0), Pe = 0, Xi = null, Vr = 0, ml = 0, Jd = 0, Pi = null, Xe = null, ef = 0, Bs = 1 / 0, an = null, Ba = !1, Tu = null, qn = null, Ho = !1, Un = null, $a = 0, ji = 0, Eu = null, da = -1, fa = 0; function Ye() { return J & 6 ? xe() : da !== -1 ? da : da = xe() } function Xn(e) { return e.mode & 1 ? J & 2 && De !== 0 ? De & -De : pS.transition !== null ? (fa === 0 && (fa = by()), fa) : (e = ne, e !== 0 || (e = window.event, e = e === void 0 ? 16 : Py(e.type)), e) : 1 } function Ft(e, t, n, r) { if (50 < ji) throw ji = 0, Eu = null, Error(M(185)); po(e, n, r), (!(J & 2) || e !== Re) && (e === Re && (!(J & 2) && (ml |= n), Pe === 4 && In(e, De)), nt(e, r), n === 1 && J === 0 && !(t.mode & 1) && (Bs = xe() + 500, dl && ur())) } function nt(e, t) { var n = e.callbackNode; pb(e, t); var r = Ta(e, e === Re ? De : 0); if (r === 0) n !== null && jh(n), e.callbackNode = null, e.callbackPriority = 0; else if (t = r & -r, e.callbackPriority !== t) { if (n != null && jh(n), t === 1) e.tag === 0 ? hS(bp.bind(null, e)) : Yy(bp.bind(null, e)), cS(function () { !(J & 6) && ur() }), n = null; else { switch (Sy(r)) { case 1: n = Ed; break; case 4: n = xy; break; case 16: n = ka; break; case 536870912: n = wy; break; default: n = ka }n = Hv(n, Vv.bind(null, e)) } e.callbackPriority = t, e.callbackNode = n } } function Vv(e, t) { if (da = -1, fa = 0, J & 6) throw Error(M(327)); var n = e.callbackNode; if (Ss() && e.callbackNode !== n) return null; var r = Ta(e, e === Re ? De : 0); if (r === 0) return null; if (r & 30 || r & e.expiredLanes || t) t = Ua(e, r); else { t = r; var s = J; J |= 2; var i = zv(); (Re !== e || De !== t) && (an = null, Bs = xe() + 500, Ar(e, t)); do try { LS(); break } catch (a) { _v(e, a) } while (!0); _d(), za.current = i, J = s, Se !== null ? t = 0 : (Re = null, De = 0, t = Pe) } if (t !== 0) { if (t === 2 && (s = Jc(e), s !== 0 && (r = s, t = Nu(e, s))), t === 1) throw n = Xi, Ar(e, 0), In(e, r), nt(e, xe()), n; if (t === 6) In(e, r); else { if (s = e.current.alternate, !(r & 30) && !MS(s) && (t = Ua(e, r), t === 2 && (i = Jc(e), i !== 0 && (r = i, t = Nu(e, i))), t === 1)) throw n = Xi, Ar(e, 0), In(e, r), nt(e, xe()), n; switch (e.finishedWork = s, e.finishedLanes = r, t) { case 0: case 1: throw Error(M(345)); case 2: vr(e, Xe, an); break; case 3: if (In(e, r), (r & 130023424) === r && (t = ef + 500 - xe(), 10 < t)) { if (Ta(e, 0) !== 0) break; if (s = e.suspendedLanes, (s & r) !== r) { Ye(), e.pingedLanes |= e.suspendedLanes & s; break } e.timeoutHandle = au(vr.bind(null, e, Xe, an), t); break } vr(e, Xe, an); break; case 4: if (In(e, r), (r & 4194240) === r) break; for (t = e.eventTimes, s = -1; 0 < r;) { var o = 31 - It(r); i = 1 << o, o = t[o], o > s && (s = o), r &= ~i } if (r = s, r = xe() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * AS(r / 1960)) - r, 10 < r) { e.timeoutHandle = au(vr.bind(null, e, Xe, an), r); break } vr(e, Xe, an); break; case 5: vr(e, Xe, an); break; default: throw Error(M(329)) } } } return nt(e, xe()), e.callbackNode === n ? Vv.bind(null, e) : null } function Nu(e, t) { var n = Pi; return e.current.memoizedState.isDehydrated && (Ar(e, t).flags |= 256), e = Ua(e, t), e !== 2 && (t = Xe, Xe = n, t !== null && Pu(t)), e } function Pu(e) { Xe === null ? Xe = e : Xe.push.apply(Xe, e) } function MS(e) { for (var t = e; ;) { if (t.flags & 16384) { var n = t.updateQueue; if (n !== null && (n = n.stores, n !== null)) for (var r = 0; r < n.length; r++) { var s = n[r], i = s.getSnapshot; s = s.value; try { if (!Vt(i(), s)) return !1 } catch { return !1 } } } if (n = t.child, t.subtreeFlags & 16384 && n !== null) n.return = t, t = n; else { if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return !0; t = t.return } t.sibling.return = t.return, t = t.sibling } } return !0 } function In(e, t) { for (t &= ~Jd, t &= ~ml, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) { var n = 31 - It(t), r = 1 << n; e[n] = -1, t &= ~r } } function bp(e) { if (J & 6) throw Error(M(327)); Ss(); var t = Ta(e, 0); if (!(t & 1)) return nt(e, xe()), null; var n = Ua(e, t); if (e.tag !== 0 && n === 2) { var r = Jc(e); r !== 0 && (t = r, n = Nu(e, r)) } if (n === 1) throw n = Xi, Ar(e, 0), In(e, t), nt(e, xe()), n; if (n === 6) throw Error(M(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = t, vr(e, Xe, an), nt(e, xe()), null } function tf(e, t) { var n = J; J |= 1; try { return e(t) } finally { J = n, J === 0 && (Bs = xe() + 500, dl && ur()) } } function _r(e) { Un !== null && Un.tag === 0 && !(J & 6) && Ss(); var t = J; J |= 1; var n = xt.transition, r = ne; try { if (xt.transition = null, ne = 1, e) return e() } finally { ne = r, xt.transition = n, J = t, !(J & 6) && ur() } } function nf() { st = ds.current, ae(ds) } function Ar(e, t) { e.finishedWork = null, e.finishedLanes = 0; var n = e.timeoutHandle; if (n !== -1 && (e.timeoutHandle = -1, lS(n)), Se !== null) for (n = Se.return; n !== null;) { var r = n; switch (Id(r), r.tag) { case 1: r = r.type.childContextTypes, r != null && Ra(); break; case 3: _s(), ae(et), ae($e), Hd(); break; case 5: Wd(r); break; case 4: _s(); break; case 13: ae(de); break; case 19: ae(de); break; case 10: zd(r.type._context); break; case 22: case 23: nf() }n = n.return } if (Re = e, Se = e = Zn(e.current, null), De = st = t, Pe = 0, Xi = null, Jd = ml = Vr = 0, Xe = Pi = null, br !== null) { for (t = 0; t < br.length; t++)if (n = br[t], r = n.interleaved, r !== null) { n.interleaved = null; var s = r.next, i = n.pending; if (i !== null) { var o = i.next; i.next = s, r.next = o } n.pending = r } br = null } return e } function _v(e, t) { do { var n = Se; try { if (_d(), la.current = _a, Va) { for (var r = pe.memoizedState; r !== null;) { var s = r.queue; s !== null && (s.pending = null), r = r.next } Va = !1 } if (Fr = 0, je = Ee = pe = null, Ei = !1, Gi = 0, Zd.current = null, n === null || n.return === null) { Pe = 1, Xi = t, Se = null; break } e: { var i = e, o = n.return, a = n, l = t; if (t = De, a.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") { var c = l, d = a, f = d.tag; if (!(d.mode & 1) && (f === 0 || f === 11 || f === 15)) { var h = d.alternate; h ? (d.updateQueue = h.updateQueue, d.memoizedState = h.memoizedState, d.lanes = h.lanes) : (d.updateQueue = null, d.memoizedState = null) } var p = lp(o); if (p !== null) { p.flags &= -257, cp(p, o, a, i, t), p.mode & 1 && ap(i, c, t), t = p, l = c; var w = t.updateQueue; if (w === null) { var y = new Set; y.add(l), t.updateQueue = y } else w.add(l); break e } else { if (!(t & 1)) { ap(i, c, t), rf(); break e } l = Error(M(426)) } } else if (ce && a.mode & 1) { var b = lp(o); if (b !== null) { !(b.flags & 65536) && (b.flags |= 256), cp(b, o, a, i, t), Fd(zs(l, a)); break e } } i = l = zs(l, a), Pe !== 4 && (Pe = 2), Pi === null ? Pi = [i] : Pi.push(i), i = o; do { switch (i.tag) { case 3: i.flags |= 65536, t &= -t, i.lanes |= t; var g = Sv(i, l, t); tp(i, g); break e; case 1: a = l; var m = i.type, v = i.stateNode; if (!(i.flags & 128) && (typeof m.getDerivedStateFromError == "function" || v !== null && typeof v.componentDidCatch == "function" && (qn === null || !qn.has(v)))) { i.flags |= 65536, t &= -t, i.lanes |= t; var S = Cv(i, a, t); tp(i, S); break e } }i = i.return } while (i !== null) } $v(n) } catch (C) { t = C, Se === n && n !== null && (Se = n = n.return); continue } break } while (!0) } function zv() { var e = za.current; return za.current = _a, e === null ? _a : e } function rf() { (Pe === 0 || Pe === 3 || Pe === 2) && (Pe = 4), Re === null || !(Vr & 268435455) && !(ml & 268435455) || In(Re, De) } function Ua(e, t) { var n = J; J |= 2; var r = zv(); (Re !== e || De !== t) && (an = null, Ar(e, t)); do try { DS(); break } catch (s) { _v(e, s) } while (!0); if (_d(), J = n, za.current = r, Se !== null) throw Error(M(261)); return Re = null, De = 0, Pe } function DS() { for (; Se !== null;)Bv(Se) } function LS() { for (; Se !== null && !ib();)Bv(Se) } function Bv(e) { var t = Wv(e.alternate, e, st); e.memoizedProps = e.pendingProps, t === null ? $v(e) : Se = t, Zd.current = null } function $v(e) { var t = e; do { var n = t.alternate; if (e = t.return, t.flags & 32768) { if (n = NS(n, t), n !== null) { n.flags &= 32767, Se = n; return } if (e !== null) e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null; else { Pe = 6, Se = null; return } } else if (n = ES(n, t, st), n !== null) { Se = n; return } if (t = t.sibling, t !== null) { Se = t; return } Se = t = e } while (t !== null); Pe === 0 && (Pe = 5) } function vr(e, t, n) { var r = ne, s = xt.transition; try { xt.transition = null, ne = 1, OS(e, t, n, r) } finally { xt.transition = s, ne = r } return null } function OS(e, t, n, r) { do Ss(); while (Un !== null); if (J & 6) throw Error(M(327)); n = e.finishedWork; var s = e.finishedLanes; if (n === null) return null; if (e.finishedWork = null, e.finishedLanes = 0, n === e.current) throw Error(M(177)); e.callbackNode = null, e.callbackPriority = 0; var i = n.lanes | n.childLanes; if (mb(e, i), e === Re && (Se = Re = null, De = 0), !(n.subtreeFlags & 2064) && !(n.flags & 2064) || Ho || (Ho = !0, Hv(ka, function () { return Ss(), null })), i = (n.flags & 15990) !== 0, n.subtreeFlags & 15990 || i) { i = xt.transition, xt.transition = null; var o = ne; ne = 1; var a = J; J |= 4, Zd.current = null, jS(e, n), Iv(n, e), tS(iu), Ea = !!su, iu = su = null, e.current = n, RS(n), ob(), J = a, ne = o, xt.transition = i } else e.current = n; if (Ho && (Ho = !1, Un = e, $a = s), i = e.pendingLanes, i === 0 && (qn = null), cb(n.stateNode), nt(e, xe()), t !== null) for (r = e.onRecoverableError, n = 0; n < t.length; n++)s = t[n], r(s.value, { componentStack: s.stack, digest: s.digest }); if (Ba) throw Ba = !1, e = Tu, Tu = null, e; return $a & 1 && e.tag !== 0 && Ss(), i = e.pendingLanes, i & 1 ? e === Eu ? ji++ : (ji = 0, Eu = e) : ji = 0, ur(), null } function Ss() { if (Un !== null) { var e = Sy($a), t = xt.transition, n = ne; try { if (xt.transition = null, ne = 16 > e ? 16 : e, Un === null) var r = !1; else { if (e = Un, Un = null, $a = 0, J & 6) throw Error(M(331)); var s = J; for (J |= 4, F = e.current; F !== null;) { var i = F, o = i.child; if (F.flags & 16) { var a = i.deletions; if (a !== null) { for (var l = 0; l < a.length; l++) { var c = a[l]; for (F = c; F !== null;) { var d = F; switch (d.tag) { case 0: case 11: case 15: Ni(8, d, i) }var f = d.child; if (f !== null) f.return = d, F = f; else for (; F !== null;) { d = F; var h = d.sibling, p = d.return; if (Dv(d), d === c) { F = null; break } if (h !== null) { h.return = p, F = h; break } F = p } } } var w = i.alternate; if (w !== null) { var y = w.child; if (y !== null) { w.child = null; do { var b = y.sibling; y.sibling = null, y = b } while (y !== null) } } F = i } } if (i.subtreeFlags & 2064 && o !== null) o.return = i, F = o; else e: for (; F !== null;) { if (i = F, i.flags & 2048) switch (i.tag) { case 0: case 11: case 15: Ni(9, i, i.return) }var g = i.sibling; if (g !== null) { g.return = i.return, F = g; break e } F = i.return } } var m = e.current; for (F = m; F !== null;) { o = F; var v = o.child; if (o.subtreeFlags & 2064 && v !== null) v.return = o, F = v; else e: for (o = m; F !== null;) { if (a = F, a.flags & 2048) try { switch (a.tag) { case 0: case 11: case 15: pl(9, a) } } catch (C) { ve(a, a.return, C) } if (a === o) { F = null; break e } var S = a.sibling; if (S !== null) { S.return = a.return, F = S; break e } F = a.return } } if (J = s, ur(), Qt && typeof Qt.onPostCommitFiberRoot == "function") try { Qt.onPostCommitFiberRoot(ol, e) } catch { } r = !0 } return r } finally { ne = n, xt.transition = t } } return !1 } function Sp(e, t, n) { t = zs(n, t), t = Sv(e, t, 1), e = Qn(e, t, 1), t = Ye(), e !== null && (po(e, 1, t), nt(e, t)) } function ve(e, t, n) { if (e.tag === 3) Sp(e, e, n); else for (; t !== null;) { if (t.tag === 3) { Sp(t, e, n); break } else if (t.tag === 1) { var r = t.stateNode; if (typeof t.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (qn === null || !qn.has(r))) { e = zs(n, e), e = Cv(t, e, 1), t = Qn(t, e, 1), e = Ye(), t !== null && (po(t, 1, e), nt(t, e)); break } } t = t.return } } function IS(e, t, n) { var r = e.pingCache; r !== null && r.delete(t), t = Ye(), e.pingedLanes |= e.suspendedLanes & n, Re === e && (De & n) === n && (Pe === 4 || Pe === 3 && (De & 130023424) === De && 500 > xe() - ef ? Ar(e, 0) : Jd |= n), nt(e, t) } function Uv(e, t) { t === 0 && (e.mode & 1 ? (t = Oo, Oo <<= 1, !(Oo & 130023424) && (Oo = 4194304)) : t = 1); var n = Ye(); e = mn(e, t), e !== null && (po(e, t, n), nt(e, n)) } function FS(e) { var t = e.memoizedState, n = 0; t !== null && (n = t.retryLane), Uv(e, n) } function VS(e, t) { var n = 0; switch (e.tag) { case 13: var r = e.stateNode, s = e.memoizedState; s !== null && (n = s.retryLane); break; case 19: r = e.stateNode; break; default: throw Error(M(314)) }r !== null && r.delete(t), Uv(e, n) } var Wv; Wv = function (e, t, n) { if (e !== null) if (e.memoizedProps !== t.pendingProps || et.current) Ze = !0; else { if (!(e.lanes & n) && !(t.flags & 128)) return Ze = !1, TS(e, t, n); Ze = !!(e.flags & 131072) } else Ze = !1, ce && t.flags & 1048576 && Gy(t, Da, t.index); switch (t.lanes = 0, t.tag) { case 2: var r = t.type; ua(e, t), e = t.pendingProps; var s = Is(t, $e.current); bs(t, n), s = Yd(null, t, r, e, s, n); var i = Gd(); return t.flags |= 1, typeof s == "object" && s !== null && typeof s.render == "function" && s.$$typeof === void 0 ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, tt(r) ? (i = !0, Aa(t)) : i = !1, t.memoizedState = s.state !== null && s.state !== void 0 ? s.state : null, $d(t), s.updater = hl, t.stateNode = s, s._reactInternals = t, pu(t, r, e, n), t = yu(null, t, r, !0, i, n)) : (t.tag = 0, ce && i && Od(t), We(null, t, s, n), t = t.child), t; case 16: r = t.elementType; e: { switch (ua(e, t), e = t.pendingProps, s = r._init, r = s(r._payload), t.type = r, s = t.tag = zS(r), e = Rt(r, e), s) { case 0: t = gu(null, t, r, e, n); break e; case 1: t = fp(null, t, r, e, n); break e; case 11: t = up(null, t, r, e, n); break e; case 14: t = dp(null, t, r, Rt(r.type, e), n); break e }throw Error(M(306, r, "")) } return t; case 0: return r = t.type, s = t.pendingProps, s = t.elementType === r ? s : Rt(r, s), gu(e, t, r, s, n); case 1: return r = t.type, s = t.pendingProps, s = t.elementType === r ? s : Rt(r, s), fp(e, t, r, s, n); case 3: e: { if (Nv(t), e === null) throw Error(M(387)); r = t.pendingProps, i = t.memoizedState, s = i.element, ev(e, t), Ia(t, r, null, n); var o = t.memoizedState; if (r = o.element, i.isDehydrated) if (i = { element: r, isDehydrated: !1, cache: o.cache, pendingSuspenseBoundaries: o.pendingSuspenseBoundaries, transitions: o.transitions }, t.updateQueue.baseState = i, t.memoizedState = i, t.flags & 256) { s = zs(Error(M(423)), t), t = hp(e, t, r, n, s); break e } else if (r !== s) { s = zs(Error(M(424)), t), t = hp(e, t, r, n, s); break e } else for (ot = Gn(t.stateNode.containerInfo.firstChild), at = t, ce = !0, Ot = null, n = Zy(t, null, r, n), t.child = n; n;)n.flags = n.flags & -3 | 4096, n = n.sibling; else { if (Fs(), r === s) { t = gn(e, t, n); break e } We(e, t, r, n) } t = t.child } return t; case 5: return tv(t), e === null && du(t), r = t.type, s = t.pendingProps, i = e !== null ? e.memoizedProps : null, o = s.children, ou(r, s) ? o = null : i !== null && ou(r, i) && (t.flags |= 32), Ev(e, t), We(e, t, o, n), t.child; case 6: return e === null && du(t), null; case 13: return Pv(e, t, n); case 4: return Ud(t, t.stateNode.containerInfo), r = t.pendingProps, e === null ? t.child = Vs(t, null, r, n) : We(e, t, r, n), t.child; case 11: return r = t.type, s = t.pendingProps, s = t.elementType === r ? s : Rt(r, s), up(e, t, r, s, n); case 7: return We(e, t, t.pendingProps, n), t.child; case 8: return We(e, t, t.pendingProps.children, n), t.child; case 12: return We(e, t, t.pendingProps.children, n), t.child; case 10: e: { if (r = t.type._context, s = t.pendingProps, i = t.memoizedProps, o = s.value, se(La, r._currentValue), r._currentValue = o, i !== null) if (Vt(i.value, o)) { if (i.children === s.children && !et.current) { t = gn(e, t, n); break e } } else for (i = t.child, i !== null && (i.return = t); i !== null;) { var a = i.dependencies; if (a !== null) { o = i.child; for (var l = a.firstContext; l !== null;) { if (l.context === r) { if (i.tag === 1) { l = fn(-1, n & -n), l.tag = 2; var c = i.updateQueue; if (c !== null) { c = c.shared; var d = c.pending; d === null ? l.next = l : (l.next = d.next, d.next = l), c.pending = l } } i.lanes |= n, l = i.alternate, l !== null && (l.lanes |= n), fu(i.return, n, t), a.lanes |= n; break } l = l.next } } else if (i.tag === 10) o = i.type === t.type ? null : i.child; else if (i.tag === 18) { if (o = i.return, o === null) throw Error(M(341)); o.lanes |= n, a = o.alternate, a !== null && (a.lanes |= n), fu(o, n, t), o = i.sibling } else o = i.child; if (o !== null) o.return = i; else for (o = i; o !== null;) { if (o === t) { o = null; break } if (i = o.sibling, i !== null) { i.return = o.return, o = i; break } o = o.return } i = o } We(e, t, s.children, n), t = t.child } return t; case 9: return s = t.type, r = t.pendingProps.children, bs(t, n), s = bt(s), r = r(s), t.flags |= 1, We(e, t, r, n), t.child; case 14: return r = t.type, s = Rt(r, t.pendingProps), s = Rt(r.type, s), dp(e, t, r, s, n); case 15: return kv(e, t, t.type, t.pendingProps, n); case 17: return r = t.type, s = t.pendingProps, s = t.elementType === r ? s : Rt(r, s), ua(e, t), t.tag = 1, tt(r) ? (e = !0, Aa(t)) : e = !1, bs(t, n), bv(t, r, s), pu(t, r, s, n), yu(null, t, r, !0, e, n); case 19: return jv(e, t, n); case 22: return Tv(e, t, n) }throw Error(M(156, t.tag)) }; function Hv(e, t) { return vy(e, t) } function _S(e, t, n, r) { this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function yt(e, t, n, r) { return new _S(e, t, n, r) } function sf(e) { return e = e.prototype, !(!e || !e.isReactComponent) } function zS(e) { if (typeof e == "function") return sf(e) ? 1 : 0; if (e != null) { if (e = e.$$typeof, e === Cd) return 11; if (e === kd) return 14 } return 2 } function Zn(e, t) { var n = e.alternate; return n === null ? (n = yt(e.tag, t, e.key, e.mode), n.elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = e.flags & 14680064, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n } function ha(e, t, n, r, s, i) { var o = 2; if (r = e, typeof e == "function") sf(e) && (o = 1); else if (typeof e == "string") o = 5; else e: switch (e) { case ts: return Mr(n.children, s, i, t); case Sd: o = 8, s |= 8; break; case Vc: return e = yt(12, n, t, s | 2), e.elementType = Vc, e.lanes = i, e; case _c: return e = yt(13, n, t, s), e.elementType = _c, e.lanes = i, e; case zc: return e = yt(19, n, t, s), e.elementType = zc, e.lanes = i, e; case ty: return gl(n, s, i, t); default: if (typeof e == "object" && e !== null) switch (e.$$typeof) { case Jg: o = 10; break e; case ey: o = 9; break e; case Cd: o = 11; break e; case kd: o = 14; break e; case Dn: o = 16, r = null; break e }throw Error(M(130, e == null ? e : typeof e, "")) }return t = yt(o, n, t, s), t.elementType = e, t.type = r, t.lanes = i, t } function Mr(e, t, n, r) { return e = yt(7, e, r, t), e.lanes = n, e } function gl(e, t, n, r) { return e = yt(22, e, r, t), e.elementType = ty, e.lanes = n, e.stateNode = { isHidden: !1 }, e } function dc(e, t, n) { return e = yt(6, e, null, t), e.lanes = n, e } function fc(e, t, n) { return t = yt(4, e.children !== null ? e.children : [], e.key, t), t.lanes = n, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t } function BS(e, t, n, r, s) { this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Kl(0), this.expirationTimes = Kl(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Kl(0), this.identifierPrefix = r, this.onRecoverableError = s, this.mutableSourceEagerHydrationData = null } function of(e, t, n, r, s, i, o, a, l) { return e = new BS(e, t, n, a, l), t === 1 ? (t = 1, i === !0 && (t |= 8)) : t = 0, i = yt(3, null, null, t), e.current = i, i.stateNode = e, i.memoizedState = { element: r, isDehydrated: n, cache: null, transitions: null, pendingSuspenseBoundaries: null }, $d(i), e } function $S(e, t, n) { var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: es, key: r == null ? null : "" + r, children: e, containerInfo: t, implementation: n } } function Kv(e) { if (!e) return tr; e = e._reactInternals; e: { if (Ur(e) !== e || e.tag !== 1) throw Error(M(170)); var t = e; do { switch (t.tag) { case 3: t = t.stateNode.context; break e; case 1: if (tt(t.type)) { t = t.stateNode.__reactInternalMemoizedMergedChildContext; break e } }t = t.return } while (t !== null); throw Error(M(171)) } if (e.tag === 1) { var n = e.type; if (tt(n)) return Ky(e, n, t) } return t } function Yv(e, t, n, r, s, i, o, a, l) { return e = of(n, r, !0, e, s, i, o, a, l), e.context = Kv(null), n = e.current, r = Ye(), s = Xn(n), i = fn(r, s), i.callback = t ?? null, Qn(n, i, s), e.current.lanes = s, po(e, s, r), nt(e, r), e } function yl(e, t, n, r) { var s = t.current, i = Ye(), o = Xn(s); return n = Kv(n), t.context === null ? t.context = n : t.pendingContext = n, t = fn(i, o), t.payload = { element: e }, r = r === void 0 ? null : r, r !== null && (t.callback = r), e = Qn(s, t, o), e !== null && (Ft(e, s, o, i), aa(e, s, o)), o } function Wa(e) { if (e = e.current, !e.child) return null; switch (e.child.tag) { case 5: return e.child.stateNode; default: return e.child.stateNode } } function Cp(e, t) { if (e = e.memoizedState, e !== null && e.dehydrated !== null) { var n = e.retryLane; e.retryLane = n !== 0 && n < t ? n : t } } function af(e, t) { Cp(e, t), (e = e.alternate) && Cp(e, t) } function US() { return null } var Gv = typeof reportError == "function" ? reportError : function (e) { console.error(e) }; function lf(e) { this._internalRoot = e } vl.prototype.render = lf.prototype.render = function (e) { var t = this._internalRoot; if (t === null) throw Error(M(409)); yl(e, t, null, null) }; vl.prototype.unmount = lf.prototype.unmount = function () { var e = this._internalRoot; if (e !== null) { this._internalRoot = null; var t = e.containerInfo; _r(function () { yl(null, e, null, null) }), t[pn] = null } }; function vl(e) { this._internalRoot = e } vl.prototype.unstable_scheduleHydration = function (e) { if (e) { var t = Ty(); e = { blockedOn: null, target: e, priority: t }; for (var n = 0; n < On.length && t !== 0 && t < On[n].priority; n++); On.splice(n, 0, e), n === 0 && Ny(e) } }; function cf(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11) } function xl(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable ")) } function kp() { } function WS(e, t, n, r, s) { if (s) { if (typeof r == "function") { var i = r; r = function () { var c = Wa(o); i.call(c) } } var o = Yv(t, r, e, 0, null, !1, !1, "", kp); return e._reactRootContainer = o, e[pn] = o.current, Ui(e.nodeType === 8 ? e.parentNode : e), _r(), o } for (; s = e.lastChild;)e.removeChild(s); if (typeof r == "function") { var a = r; r = function () { var c = Wa(l); a.call(c) } } var l = of(e, 0, !1, null, null, !1, !1, "", kp); return e._reactRootContainer = l, e[pn] = l.current, Ui(e.nodeType === 8 ? e.parentNode : e), _r(function () { yl(t, l, n, r) }), l } function wl(e, t, n, r, s) { var i = n._reactRootContainer; if (i) { var o = i; if (typeof s == "function") { var a = s; s = function () { var l = Wa(o); a.call(l) } } yl(t, o, e, s) } else o = WS(n, t, e, s, r); return Wa(o) } Cy = function (e) { switch (e.tag) { case 3: var t = e.stateNode; if (t.current.memoizedState.isDehydrated) { var n = vi(t.pendingLanes); n !== 0 && (Nd(t, n | 1), nt(t, xe()), !(J & 6) && (Bs = xe() + 500, ur())) } break; case 13: _r(function () { var r = mn(e, 1); if (r !== null) { var s = Ye(); Ft(r, e, 1, s) } }), af(e, 1) } }; Pd = function (e) { if (e.tag === 13) { var t = mn(e, 134217728); if (t !== null) { var n = Ye(); Ft(t, e, 134217728, n) } af(e, 134217728) } }; ky = function (e) { if (e.tag === 13) { var t = Xn(e), n = mn(e, t); if (n !== null) { var r = Ye(); Ft(n, e, t, r) } af(e, t) } }; Ty = function () { return ne }; Ey = function (e, t) { var n = ne; try { return ne = e, t() } finally { ne = n } }; qc = function (e, t, n) { switch (t) { case "input": if (Uc(e, n), t = n.name, n.type === "radio" && t != null) { for (n = e; n.parentNode;)n = n.parentNode; for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) { var r = n[t]; if (r !== e && r.form === e.form) { var s = ul(r); if (!s) throw Error(M(90)); ry(r), Uc(r, s) } } } break; case "textarea": iy(e, n); break; case "select": t = n.value, t != null && ys(e, !!n.multiple, t, !1) } }; fy = tf; hy = _r; var HS = { usingClientEntryPoint: !1, Events: [go, is, ul, uy, dy, tf] }, fi = { findFiberByHostInstance: wr, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, KS = { bundleType: fi.bundleType, version: fi.version, rendererPackageName: fi.rendererPackageName, rendererConfig: fi.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: bn.ReactCurrentDispatcher, findHostInstanceByFiber: function (e) { return e = gy(e), e === null ? null : e.stateNode }, findFiberByHostInstance: fi.findFiberByHostInstance || US, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var Ko = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!Ko.isDisabled && Ko.supportsFiber) try { ol = Ko.inject(KS), Qt = Ko } catch { } } ut.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = HS; ut.createPortal = function (e, t) { var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!cf(t)) throw Error(M(200)); return $S(e, t, null, n) }; ut.createRoot = function (e, t) { if (!cf(e)) throw Error(M(299)); var n = !1, r = "", s = Gv; return t != null && (t.unstable_strictMode === !0 && (n = !0), t.identifierPrefix !== void 0 && (r = t.identifierPrefix), t.onRecoverableError !== void 0 && (s = t.onRecoverableError)), t = of(e, 1, !1, null, null, n, !1, r, s), e[pn] = t.current, Ui(e.nodeType === 8 ? e.parentNode : e), new lf(t) }; ut.findDOMNode = function (e) { if (e == null) return null; if (e.nodeType === 1) return e; var t = e._reactInternals; if (t === void 0) throw typeof e.render == "function" ? Error(M(188)) : (e = Object.keys(e).join(","), Error(M(268, e))); return e = gy(t), e = e === null ? null : e.stateNode, e }; ut.flushSync = function (e) { return _r(e) }; ut.hydrate = function (e, t, n) { if (!xl(t)) throw Error(M(200)); return wl(null, e, t, !0, n) }; ut.hydrateRoot = function (e, t, n) { if (!cf(e)) throw Error(M(405)); var r = n != null && n.hydratedSources || null, s = !1, i = "", o = Gv; if (n != null && (n.unstable_strictMode === !0 && (s = !0), n.identifierPrefix !== void 0 && (i = n.identifierPrefix), n.onRecoverableError !== void 0 && (o = n.onRecoverableError)), t = Yv(t, null, e, 1, n ?? null, s, !1, i, o), e[pn] = t.current, Ui(e), r) for (e = 0; e < r.length; e++)n = r[e], s = n._getVersion, s = s(n._source), t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [n, s] : t.mutableSourceEagerHydrationData.push(n, s); return new vl(t) }; ut.render = function (e, t, n) { if (!xl(t)) throw Error(M(200)); return wl(null, e, t, !1, n) }; ut.unmountComponentAtNode = function (e) { if (!xl(e)) throw Error(M(40)); return e._reactRootContainer ? (_r(function () { wl(null, null, e, !1, function () { e._reactRootContainer = null, e[pn] = null }) }), !0) : !1 }; ut.unstable_batchedUpdates = tf; ut.unstable_renderSubtreeIntoContainer = function (e, t, n, r) { if (!xl(n)) throw Error(M(200)); if (e == null || e._reactInternals === void 0) throw Error(M(38)); return wl(e, t, n, !1, r) }; ut.version = "18.3.1-next-f1338f8080-20240426"; function Qv() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Qv) } catch (e) { console.error(e) } } Qv(), Qg.exports = ut; var vo = Qg.exports; const qv = Ig(vo); var Xv, Tp = vo; Xv = Tp.createRoot, Tp.hydrateRoot; const YS = 1, GS = 1e6; let hc = 0; function QS() { return hc = (hc + 1) % Number.MAX_SAFE_INTEGER, hc.toString() } const pc = new Map, Ep = e => { if (pc.has(e)) return; const t = setTimeout(() => { pc.delete(e), Ri({ type: "REMOVE_TOAST", toastId: e }) }, GS); pc.set(e, t) }, qS = (e, t) => { switch (t.type) { case "ADD_TOAST": return { ...e, toasts: [t.toast, ...e.toasts].slice(0, YS) }; case "UPDATE_TOAST": return { ...e, toasts: e.toasts.map(n => n.id === t.toast.id ? { ...n, ...t.toast } : n) }; case "DISMISS_TOAST": { const { toastId: n } = t; return n ? Ep(n) : e.toasts.forEach(r => { Ep(r.id) }), { ...e, toasts: e.toasts.map(r => r.id === n || n === void 0 ? { ...r, open: !1 } : r) } } case "REMOVE_TOAST": return t.toastId === void 0 ? { ...e, toasts: [] } : { ...e, toasts: e.toasts.filter(n => n.id !== t.toastId) } } }, pa = []; let ma = { toasts: [] }; function Ri(e) { ma = qS(ma, e), pa.forEach(t => { t(ma) }) } function Zv({ ...e }) { const t = QS(), n = s => Ri({ type: "UPDATE_TOAST", toast: { ...s, id: t } }), r = () => Ri({ type: "DISMISS_TOAST", toastId: t }); return Ri({ type: "ADD_TOAST", toast: { ...e, id: t, open: !0, onOpenChange: s => { s || r() } } }), { id: t, dismiss: r, update: n } } function XS() { const [e, t] = x.useState(ma); return x.useEffect(() => (pa.push(t), () => { const n = pa.indexOf(t); n > -1 && pa.splice(n, 1) }), [e]), { ...e, toast: Zv, dismiss: n => Ri({ type: "DISMISS_TOAST", toastId: n }) } } function Ne(e, t, { checkForDefaultPrevented: n = !0 } = {}) { return function (s) { if (e == null || e(s), n === !1 || !s.defaultPrevented) return t == null ? void 0 : t(s) } } function Np(e, t) { if (typeof e == "function") return e(t); e != null && (e.current = t) } function Jv(...e) { return t => { let n = !1; const r = e.map(s => { const i = Np(s, t); return !n && typeof i == "function" && (n = !0), i }); if (n) return () => { for (let s = 0; s < r.length; s++) { const i = r[s]; typeof i == "function" ? i() : Np(e[s], null) } } } } function _t(...e) { return x.useCallback(Jv(...e), e) } function bl(e, t = []) { let n = []; function r(i, o) { const a = x.createContext(o), l = n.length; n = [...n, o]; const c = f => { var g; const { scope: h, children: p, ...w } = f, y = ((g = h == null ? void 0 : h[e]) == null ? void 0 : g[l]) || a, b = x.useMemo(() => w, Object.values(w)); return u.jsx(y.Provider, { value: b, children: p }) }; c.displayName = i + "Provider"; function d(f, h) { var y; const p = ((y = h == null ? void 0 : h[e]) == null ? void 0 : y[l]) || a, w = x.useContext(p); if (w) return w; if (o !== void 0) return o; throw new Error(`\`${f}\` must be used within \`${i}\``) } return [c, d] } const s = () => { const i = n.map(o => x.createContext(o)); return function (a) { const l = (a == null ? void 0 : a[e]) || i; return x.useMemo(() => ({ [`__scope${e}`]: { ...a, [e]: l } }), [a, l]) } }; return s.scopeName = e, [r, ZS(s, ...t)] } function ZS(...e) { const t = e[0]; if (e.length === 1) return t; const n = () => { const r = e.map(s => ({ useScope: s(), scopeName: s.scopeName })); return function (i) { const o = r.reduce((a, { useScope: l, scopeName: c }) => { const f = l(i)[`__scope${c}`]; return { ...a, ...f } }, {}); return x.useMemo(() => ({ [`__scope${t.scopeName}`]: o }), [o]) } }; return n.scopeName = t.scopeName, n } function ju(e) { const t = JS(e), n = x.forwardRef((r, s) => { const { children: i, ...o } = r, a = x.Children.toArray(i), l = a.find(tC); if (l) { const c = l.props.children, d = a.map(f => f === l ? x.Children.count(c) > 1 ? x.Children.only(null) : x.isValidElement(c) ? c.props.children : null : f); return u.jsx(t, { ...o, ref: s, children: x.isValidElement(c) ? x.cloneElement(c, void 0, d) : null }) } return u.jsx(t, { ...o, ref: s, children: i }) }); return n.displayName = `${e}.Slot`, n } function JS(e) { const t = x.forwardRef((n, r) => { const { children: s, ...i } = n; if (x.isValidElement(s)) { const o = rC(s), a = nC(i, s.props); return s.type !== x.Fragment && (a.ref = r ? Jv(r, o) : o), x.cloneElement(s, a) } return x.Children.count(s) > 1 ? x.Children.only(null) : null }); return t.displayName = `${e}.SlotClone`, t } var e0 = Symbol("radix.slottable"); function eC(e) { const t = ({ children: n }) => u.jsx(u.Fragment, { children: n }); return t.displayName = `${e}.Slottable`, t.__radixId = e0, t } function tC(e) { return x.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === e0 } function nC(e, t) { const n = { ...t }; for (const r in t) { const s = e[r], i = t[r]; /^on[A-Z]/.test(r) ? s && i ? n[r] = (...a) => { const l = i(...a); return s(...a), l } : s && (n[r] = s) : r === "style" ? n[r] = { ...s, ...i } : r === "className" && (n[r] = [s, i].filter(Boolean).join(" ")) } return { ...e, ...n } } function rC(e) { var r, s; let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning; return n ? e.ref : (t = (s = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : s.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref) } function sC(e) { const t = e + "CollectionProvider", [n, r] = bl(t), [s, i] = n(t, { collectionRef: { current: null }, itemMap: new Map }), o = y => { const { scope: b, children: g } = y, m = D.useRef(null), v = D.useRef(new Map).current; return u.jsx(s, { scope: b, itemMap: v, collectionRef: m, children: g }) }; o.displayName = t; const a = e + "CollectionSlot", l = ju(a), c = D.forwardRef((y, b) => { const { scope: g, children: m } = y, v = i(a, g), S = _t(b, v.collectionRef); return u.jsx(l, { ref: S, children: m }) }); c.displayName = a; const d = e + "CollectionItemSlot", f = "data-radix-collection-item", h = ju(d), p = D.forwardRef((y, b) => { const { scope: g, children: m, ...v } = y, S = D.useRef(null), C = _t(b, S), k = i(d, g); return D.useEffect(() => (k.itemMap.set(S, { ref: S, ...v }), () => void k.itemMap.delete(S))), u.jsx(h, { [f]: "", ref: C, children: m }) }); p.displayName = d; function w(y) { const b = i(e + "CollectionConsumer", y); return D.useCallback(() => { const m = b.collectionRef.current; if (!m) return []; const v = Array.from(m.querySelectorAll(`[${f}]`)); return Array.from(b.itemMap.values()).sort((k, T) => v.indexOf(k.ref.current) - v.indexOf(T.ref.current)) }, [b.collectionRef, b.itemMap]) } return [{ Provider: o, Slot: c, ItemSlot: p }, w, r] } var iC = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "select", "span", "svg", "ul"], rt = iC.reduce((e, t) => { const n = ju(`Primitive.${t}`), r = x.forwardRef((s, i) => { const { asChild: o, ...a } = s, l = o ? n : t; return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), u.jsx(l, { ...a, ref: i }) }); return r.displayName = `Primitive.${t}`, { ...e, [t]: r } }, {}); function t0(e, t) { e && vo.flushSync(() => e.dispatchEvent(t)) } function nr(e) { const t = x.useRef(e); return x.useEffect(() => { t.current = e }), x.useMemo(() => (...n) => { var r; return (r = t.current) == null ? void 0 : r.call(t, ...n) }, []) } function oC(e, t = globalThis == null ? void 0 : globalThis.document) { const n = nr(e); x.useEffect(() => { const r = s => { s.key === "Escape" && n(s) }; return t.addEventListener("keydown", r, { capture: !0 }), () => t.removeEventListener("keydown", r, { capture: !0 }) }, [n, t]) } var aC = "DismissableLayer", Ru = "dismissableLayer.update", lC = "dismissableLayer.pointerDownOutside", cC = "dismissableLayer.focusOutside", Pp, n0 = x.createContext({ layers: new Set, layersWithOutsidePointerEventsDisabled: new Set, branches: new Set }), uf = x.forwardRef((e, t) => { const { disableOutsidePointerEvents: n = !1, onEscapeKeyDown: r, onPointerDownOutside: s, onFocusOutside: i, onInteractOutside: o, onDismiss: a, ...l } = e, c = x.useContext(n0), [d, f] = x.useState(null), h = (d == null ? void 0 : d.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, p] = x.useState({}), w = _t(t, T => f(T)), y = Array.from(c.layers), [b] = [...c.layersWithOutsidePointerEventsDisabled].slice(-1), g = y.indexOf(b), m = d ? y.indexOf(d) : -1, v = c.layersWithOutsidePointerEventsDisabled.size > 0, S = m >= g, C = dC(T => { const E = T.target, A = [...c.branches].some(R => R.contains(E)); !S || A || (s == null || s(T), o == null || o(T), T.defaultPrevented || a == null || a()) }, h), k = fC(T => { const E = T.target;[...c.branches].some(R => R.contains(E)) || (i == null || i(T), o == null || o(T), T.defaultPrevented || a == null || a()) }, h); return oC(T => { m === c.layers.size - 1 && (r == null || r(T), !T.defaultPrevented && a && (T.preventDefault(), a())) }, h), x.useEffect(() => { if (d) return n && (c.layersWithOutsidePointerEventsDisabled.size === 0 && (Pp = h.body.style.pointerEvents, h.body.style.pointerEvents = "none"), c.layersWithOutsidePointerEventsDisabled.add(d)), c.layers.add(d), jp(), () => { n && c.layersWithOutsidePointerEventsDisabled.size === 1 && (h.body.style.pointerEvents = Pp) } }, [d, h, n, c]), x.useEffect(() => () => { d && (c.layers.delete(d), c.layersWithOutsidePointerEventsDisabled.delete(d), jp()) }, [d, c]), x.useEffect(() => { const T = () => p({}); return document.addEventListener(Ru, T), () => document.removeEventListener(Ru, T) }, []), u.jsx(rt.div, { ...l, ref: w, style: { pointerEvents: v ? S ? "auto" : "none" : void 0, ...e.style }, onFocusCapture: Ne(e.onFocusCapture, k.onFocusCapture), onBlurCapture: Ne(e.onBlurCapture, k.onBlurCapture), onPointerDownCapture: Ne(e.onPointerDownCapture, C.onPointerDownCapture) }) }); uf.displayName = aC; var uC = "DismissableLayerBranch", r0 = x.forwardRef((e, t) => { const n = x.useContext(n0), r = x.useRef(null), s = _t(t, r); return x.useEffect(() => { const i = r.current; if (i) return n.branches.add(i), () => { n.branches.delete(i) } }, [n.branches]), u.jsx(rt.div, { ...e, ref: s }) }); r0.displayName = uC; function dC(e, t = globalThis == null ? void 0 : globalThis.document) { const n = nr(e), r = x.useRef(!1), s = x.useRef(() => { }); return x.useEffect(() => { const i = a => { if (a.target && !r.current) { let l = function () { s0(lC, n, c, { discrete: !0 }) }; const c = { originalEvent: a }; a.pointerType === "touch" ? (t.removeEventListener("click", s.current), s.current = l, t.addEventListener("click", s.current, { once: !0 })) : l() } else t.removeEventListener("click", s.current); r.current = !1 }, o = window.setTimeout(() => { t.addEventListener("pointerdown", i) }, 0); return () => { window.clearTimeout(o), t.removeEventListener("pointerdown", i), t.removeEventListener("click", s.current) } }, [t, n]), { onPointerDownCapture: () => r.current = !0 } } function fC(e, t = globalThis == null ? void 0 : globalThis.document) { const n = nr(e), r = x.useRef(!1); return x.useEffect(() => { const s = i => { i.target && !r.current && s0(cC, n, { originalEvent: i }, { discrete: !1 }) }; return t.addEventListener("focusin", s), () => t.removeEventListener("focusin", s) }, [t, n]), { onFocusCapture: () => r.current = !0, onBlurCapture: () => r.current = !1 } } function jp() { const e = new CustomEvent(Ru); document.dispatchEvent(e) } function s0(e, t, n, { discrete: r }) { const s = n.originalEvent.target, i = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n }); t && s.addEventListener(e, t, { once: !0 }), r ? t0(s, i) : s.dispatchEvent(i) } var hC = uf, pC = r0, rr = globalThis != null && globalThis.document ? x.useLayoutEffect : () => { }, mC = "Portal", i0 = x.forwardRef((e, t) => { var a; const { container: n, ...r } = e, [s, i] = x.useState(!1); rr(() => i(!0), []); const o = n || s && ((a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : a.body); return o ? qv.createPortal(u.jsx(rt.div, { ...r, ref: t }), o) : null }); i0.displayName = mC; function gC(e, t) { return x.useReducer((n, r) => t[n][r] ?? n, e) } var df = e => { const { present: t, children: n } = e, r = yC(t), s = typeof n == "function" ? n({ present: r.isPresent }) : x.Children.only(n), i = _t(r.ref, vC(s)); return typeof n == "function" || r.isPresent ? x.cloneElement(s, { ref: i }) : null }; df.displayName = "Presence"; function yC(e) { const [t, n] = x.useState(), r = x.useRef(null), s = x.useRef(e), i = x.useRef("none"), o = e ? "mounted" : "unmounted", [a, l] = gC(o, { mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" }, unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" }, unmounted: { MOUNT: "mounted" } }); return x.useEffect(() => { const c = Yo(r.current); i.current = a === "mounted" ? c : "none" }, [a]), rr(() => { const c = r.current, d = s.current; if (d !== e) { const h = i.current, p = Yo(c); e ? l("MOUNT") : p === "none" || (c == null ? void 0 : c.display) === "none" ? l("UNMOUNT") : l(d && h !== p ? "ANIMATION_OUT" : "UNMOUNT"), s.current = e } }, [e, l]), rr(() => { if (t) { let c; const d = t.ownerDocument.defaultView ?? window, f = p => { const y = Yo(r.current).includes(p.animationName); if (p.target === t && y && (l("ANIMATION_END"), !s.current)) { const b = t.style.animationFillMode; t.style.animationFillMode = "forwards", c = d.setTimeout(() => { t.style.animationFillMode === "forwards" && (t.style.animationFillMode = b) }) } }, h = p => { p.target === t && (i.current = Yo(r.current)) }; return t.addEventListener("animationstart", h), t.addEventListener("animationcancel", f), t.addEventListener("animationend", f), () => { d.clearTimeout(c), t.removeEventListener("animationstart", h), t.removeEventListener("animationcancel", f), t.removeEventListener("animationend", f) } } else l("ANIMATION_END") }, [t, l]), { isPresent: ["mounted", "unmountSuspended"].includes(a), ref: x.useCallback(c => { r.current = c ? getComputedStyle(c) : null, n(c) }, []) } } function Yo(e) { return (e == null ? void 0 : e.animationName) || "none" } function vC(e) { var r, s; let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning; return n ? e.ref : (t = (s = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : s.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref) } var xC = Yg[" useInsertionEffect ".trim().toString()] || rr; function wC({ prop: e, defaultProp: t, onChange: n = () => { }, caller: r }) { const [s, i, o] = bC({ defaultProp: t, onChange: n }), a = e !== void 0, l = a ? e : s; { const d = x.useRef(e !== void 0); x.useEffect(() => { const f = d.current; f !== a && console.warn(`${r} is changing from ${f ? "controlled" : "uncontrolled"} to ${a ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`), d.current = a }, [a, r]) } const c = x.useCallback(d => { var f; if (a) { const h = SC(d) ? d(e) : d; h !== e && ((f = o.current) == null || f.call(o, h)) } else i(d) }, [a, e, i, o]); return [l, c] } function bC({ defaultProp: e, onChange: t }) { const [n, r] = x.useState(e), s = x.useRef(n), i = x.useRef(t); return xC(() => { i.current = t }, [t]), x.useEffect(() => { var o; s.current !== n && ((o = i.current) == null || o.call(i, n), s.current = n) }, [n, s]), [n, r, i] } function SC(e) { return typeof e == "function" } var CC = Object.freeze({ position: "absolute", border: 0, width: 1, height: 1, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", wordWrap: "normal" }), kC = "VisuallyHidden", Sl = x.forwardRef((e, t) => u.jsx(rt.span, { ...e, ref: t, style: { ...CC, ...e.style } })); Sl.displayName = kC; var TC = Sl, ff = "ToastProvider", [hf, EC, NC] = sC("Toast"), [o0, AM] = bl("Toast", [NC]), [PC, Cl] = o0(ff), a0 = e => { const { __scopeToast: t, label: n = "Notification", duration: r = 5e3, swipeDirection: s = "right", swipeThreshold: i = 50, children: o } = e, [a, l] = x.useState(null), [c, d] = x.useState(0), f = x.useRef(!1), h = x.useRef(!1); return n.trim() || console.error(`Invalid prop \`label\` supplied to \`${ff}\`. Expected non-empty \`string\`.`), u.jsx(hf.Provider, { scope: t, children: u.jsx(PC, { scope: t, label: n, duration: r, swipeDirection: s, swipeThreshold: i, toastCount: c, viewport: a, onViewportChange: l, onToastAdd: x.useCallback(() => d(p => p + 1), []), onToastRemove: x.useCallback(() => d(p => p - 1), []), isFocusedToastEscapeKeyDownRef: f, isClosePausedRef: h, children: o }) }) }; a0.displayName = ff; var l0 = "ToastViewport", jC = ["F8"], Au = "toast.viewportPause", Mu = "toast.viewportResume", c0 = x.forwardRef((e, t) => { const { __scopeToast: n, hotkey: r = jC, label: s = "Notifications ({hotkey})", ...i } = e, o = Cl(l0, n), a = EC(n), l = x.useRef(null), c = x.useRef(null), d = x.useRef(null), f = x.useRef(null), h = _t(t, f, o.onViewportChange), p = r.join("+").replace(/Key/g, "").replace(/Digit/g, ""), w = o.toastCount > 0; x.useEffect(() => { const b = g => { var v; r.length !== 0 && r.every(S => g[S] || g.code === S) && ((v = f.current) == null || v.focus()) }; return document.addEventListener("keydown", b), () => document.removeEventListener("keydown", b) }, [r]), x.useEffect(() => { const b = l.current, g = f.current; if (w && b && g) { const m = () => { if (!o.isClosePausedRef.current) { const k = new CustomEvent(Au); g.dispatchEvent(k), o.isClosePausedRef.current = !0 } }, v = () => { if (o.isClosePausedRef.current) { const k = new CustomEvent(Mu); g.dispatchEvent(k), o.isClosePausedRef.current = !1 } }, S = k => { !b.contains(k.relatedTarget) && v() }, C = () => { b.contains(document.activeElement) || v() }; return b.addEventListener("focusin", m), b.addEventListener("focusout", S), b.addEventListener("pointermove", m), b.addEventListener("pointerleave", C), window.addEventListener("blur", m), window.addEventListener("focus", v), () => { b.removeEventListener("focusin", m), b.removeEventListener("focusout", S), b.removeEventListener("pointermove", m), b.removeEventListener("pointerleave", C), window.removeEventListener("blur", m), window.removeEventListener("focus", v) } } }, [w, o.isClosePausedRef]); const y = x.useCallback(({ tabbingDirection: b }) => { const m = a().map(v => { const S = v.ref.current, C = [S, ...$C(S)]; return b === "forwards" ? C : C.reverse() }); return (b === "forwards" ? m.reverse() : m).flat() }, [a]); return x.useEffect(() => { const b = f.current; if (b) { const g = m => { var C, k, T; const v = m.altKey || m.ctrlKey || m.metaKey; if (m.key === "Tab" && !v) { const E = document.activeElement, A = m.shiftKey; if (m.target === b && A) { (C = c.current) == null || C.focus(); return } const I = y({ tabbingDirection: A ? "backwards" : "forwards" }), G = I.findIndex(L => L === E); mc(I.slice(G + 1)) ? m.preventDefault() : A ? (k = c.current) == null || k.focus() : (T = d.current) == null || T.focus() } }; return b.addEventListener("keydown", g), () => b.removeEventListener("keydown", g) } }, [a, y]), u.jsxs(pC, { ref: l, role: "region", "aria-label": s.replace("{hotkey}", p), tabIndex: -1, style: { pointerEvents: w ? void 0 : "none" }, children: [w && u.jsx(Du, { ref: c, onFocusFromOutsideViewport: () => { const b = y({ tabbingDirection: "forwards" }); mc(b) } }), u.jsx(hf.Slot, { scope: n, children: u.jsx(rt.ol, { tabIndex: -1, ...i, ref: h }) }), w && u.jsx(Du, { ref: d, onFocusFromOutsideViewport: () => { const b = y({ tabbingDirection: "backwards" }); mc(b) } })] }) }); c0.displayName = l0; var u0 = "ToastFocusProxy", Du = x.forwardRef((e, t) => { const { __scopeToast: n, onFocusFromOutsideViewport: r, ...s } = e, i = Cl(u0, n); return u.jsx(Sl, { "aria-hidden": !0, tabIndex: 0, ...s, ref: t, style: { position: "fixed" }, onFocus: o => { var c; const a = o.relatedTarget; !((c = i.viewport) != null && c.contains(a)) && r() } }) }); Du.displayName = u0; var xo = "Toast", RC = "toast.swipeStart", AC = "toast.swipeMove", MC = "toast.swipeCancel", DC = "toast.swipeEnd", d0 = x.forwardRef((e, t) => { const { forceMount: n, open: r, defaultOpen: s, onOpenChange: i, ...o } = e, [a, l] = wC({ prop: r, defaultProp: s ?? !0, onChange: i, caller: xo }); return u.jsx(df, { present: n || a, children: u.jsx(IC, { open: a, ...o, ref: t, onClose: () => l(!1), onPause: nr(e.onPause), onResume: nr(e.onResume), onSwipeStart: Ne(e.onSwipeStart, c => { c.currentTarget.setAttribute("data-swipe", "start") }), onSwipeMove: Ne(e.onSwipeMove, c => { const { x: d, y: f } = c.detail.delta; c.currentTarget.setAttribute("data-swipe", "move"), c.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${d}px`), c.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${f}px`) }), onSwipeCancel: Ne(e.onSwipeCancel, c => { c.currentTarget.setAttribute("data-swipe", "cancel"), c.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), c.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), c.currentTarget.style.removeProperty("--radix-toast-swipe-end-x"), c.currentTarget.style.removeProperty("--radix-toast-swipe-end-y") }), onSwipeEnd: Ne(e.onSwipeEnd, c => { const { x: d, y: f } = c.detail.delta; c.currentTarget.setAttribute("data-swipe", "end"), c.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), c.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), c.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${d}px`), c.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${f}px`), l(!1) }) }) }) }); d0.displayName = xo; var [LC, OC] = o0(xo, { onClose() { } }), IC = x.forwardRef((e, t) => { const { __scopeToast: n, type: r = "foreground", duration: s, open: i, onClose: o, onEscapeKeyDown: a, onPause: l, onResume: c, onSwipeStart: d, onSwipeMove: f, onSwipeCancel: h, onSwipeEnd: p, ...w } = e, y = Cl(xo, n), [b, g] = x.useState(null), m = _t(t, L => g(L)), v = x.useRef(null), S = x.useRef(null), C = s || y.duration, k = x.useRef(0), T = x.useRef(C), E = x.useRef(0), { onToastAdd: A, onToastRemove: R } = y, _ = nr(() => { var Q; (b == null ? void 0 : b.contains(document.activeElement)) && ((Q = y.viewport) == null || Q.focus()), o() }), I = x.useCallback(L => { !L || L === 1 / 0 || (window.clearTimeout(E.current), k.current = new Date().getTime(), E.current = window.setTimeout(_, L)) }, [_]); x.useEffect(() => { const L = y.viewport; if (L) { const Q = () => { I(T.current), c == null || c() }, $ = () => { const V = new Date().getTime() - k.current; T.current = T.current - V, window.clearTimeout(E.current), l == null || l() }; return L.addEventListener(Au, $), L.addEventListener(Mu, Q), () => { L.removeEventListener(Au, $), L.removeEventListener(Mu, Q) } } }, [y.viewport, C, l, c, I]), x.useEffect(() => { i && !y.isClosePausedRef.current && I(C) }, [i, C, y.isClosePausedRef, I]), x.useEffect(() => (A(), () => R()), [A, R]); const G = x.useMemo(() => b ? v0(b) : null, [b]); return y.viewport ? u.jsxs(u.Fragment, { children: [G && u.jsx(FC, { __scopeToast: n, role: "status", "aria-live": r === "foreground" ? "assertive" : "polite", "aria-atomic": !0, children: G }), u.jsx(LC, { scope: n, onClose: _, children: vo.createPortal(u.jsx(hf.ItemSlot, { scope: n, children: u.jsx(hC, { asChild: !0, onEscapeKeyDown: Ne(a, () => { y.isFocusedToastEscapeKeyDownRef.current || _(), y.isFocusedToastEscapeKeyDownRef.current = !1 }), children: u.jsx(rt.li, { role: "status", "aria-live": "off", "aria-atomic": !0, tabIndex: 0, "data-state": i ? "open" : "closed", "data-swipe-direction": y.swipeDirection, ...w, ref: m, style: { userSelect: "none", touchAction: "none", ...e.style }, onKeyDown: Ne(e.onKeyDown, L => { L.key === "Escape" && (a == null || a(L.nativeEvent), L.nativeEvent.defaultPrevented || (y.isFocusedToastEscapeKeyDownRef.current = !0, _())) }), onPointerDown: Ne(e.onPointerDown, L => { L.button === 0 && (v.current = { x: L.clientX, y: L.clientY }) }), onPointerMove: Ne(e.onPointerMove, L => { if (!v.current) return; const Q = L.clientX - v.current.x, $ = L.clientY - v.current.y, V = !!S.current, N = ["left", "right"].includes(y.swipeDirection), j = ["left", "up"].includes(y.swipeDirection) ? Math.min : Math.max, O = N ? j(0, Q) : 0, U = N ? 0 : j(0, $), z = L.pointerType === "touch" ? 10 : 2, q = { x: O, y: U }, Z = { originalEvent: L, delta: q }; V ? (S.current = q, Go(AC, f, Z, { discrete: !1 })) : Rp(q, y.swipeDirection, z) ? (S.current = q, Go(RC, d, Z, { discrete: !1 }), L.target.setPointerCapture(L.pointerId)) : (Math.abs(Q) > z || Math.abs($) > z) && (v.current = null) }), onPointerUp: Ne(e.onPointerUp, L => { const Q = S.current, $ = L.target; if ($.hasPointerCapture(L.pointerId) && $.releasePointerCapture(L.pointerId), S.current = null, v.current = null, Q) { const V = L.currentTarget, N = { originalEvent: L, delta: Q }; Rp(Q, y.swipeDirection, y.swipeThreshold) ? Go(DC, p, N, { discrete: !0 }) : Go(MC, h, N, { discrete: !0 }), V.addEventListener("click", j => j.preventDefault(), { once: !0 }) } }) }) }) }), y.viewport) })] }) : null }), FC = e => { const { __scopeToast: t, children: n, ...r } = e, s = Cl(xo, t), [i, o] = x.useState(!1), [a, l] = x.useState(!1); return zC(() => o(!0)), x.useEffect(() => { const c = window.setTimeout(() => l(!0), 1e3); return () => window.clearTimeout(c) }, []), a ? null : u.jsx(i0, { asChild: !0, children: u.jsx(Sl, { ...r, children: i && u.jsxs(u.Fragment, { children: [s.label, " ", n] }) }) }) }, VC = "ToastTitle", f0 = x.forwardRef((e, t) => { const { __scopeToast: n, ...r } = e; return u.jsx(rt.div, { ...r, ref: t }) }); f0.displayName = VC; var _C = "ToastDescription", h0 = x.forwardRef((e, t) => { const { __scopeToast: n, ...r } = e; return u.jsx(rt.div, { ...r, ref: t }) }); h0.displayName = _C; var p0 = "ToastAction", m0 = x.forwardRef((e, t) => { const { altText: n, ...r } = e; return n.trim() ? u.jsx(y0, { altText: n, asChild: !0, children: u.jsx(pf, { ...r, ref: t }) }) : (console.error(`Invalid prop \`altText\` supplied to \`${p0}\`. Expected non-empty \`string\`.`), null) }); m0.displayName = p0; var g0 = "ToastClose", pf = x.forwardRef((e, t) => { const { __scopeToast: n, ...r } = e, s = OC(g0, n); return u.jsx(y0, { asChild: !0, children: u.jsx(rt.button, { type: "button", ...r, ref: t, onClick: Ne(e.onClick, s.onClose) }) }) }); pf.displayName = g0; var y0 = x.forwardRef((e, t) => { const { __scopeToast: n, altText: r, ...s } = e; return u.jsx(rt.div, { "data-radix-toast-announce-exclude": "", "data-radix-toast-announce-alt": r || void 0, ...s, ref: t }) }); function v0(e) { const t = []; return Array.from(e.childNodes).forEach(r => { if (r.nodeType === r.TEXT_NODE && r.textContent && t.push(r.textContent), BC(r)) { const s = r.ariaHidden || r.hidden || r.style.display === "none", i = r.dataset.radixToastAnnounceExclude === ""; if (!s) if (i) { const o = r.dataset.radixToastAnnounceAlt; o && t.push(o) } else t.push(...v0(r)) } }), t } function Go(e, t, n, { discrete: r }) { const s = n.originalEvent.currentTarget, i = new CustomEvent(e, { bubbles: !0, cancelable: !0, detail: n }); t && s.addEventListener(e, t, { once: !0 }), r ? t0(s, i) : s.dispatchEvent(i) } var Rp = (e, t, n = 0) => { const r = Math.abs(e.x), s = Math.abs(e.y), i = r > s; return t === "left" || t === "right" ? i && r > n : !i && s > n }; function zC(e = () => { }) { const t = nr(e); rr(() => { let n = 0, r = 0; return n = window.requestAnimationFrame(() => r = window.requestAnimationFrame(t)), () => { window.cancelAnimationFrame(n), window.cancelAnimationFrame(r) } }, [t]) } function BC(e) { return e.nodeType === e.ELEMENT_NODE } function $C(e) { const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, { acceptNode: r => { const s = r.tagName === "INPUT" && r.type === "hidden"; return r.disabled || r.hidden || s ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP } }); for (; n.nextNode();)t.push(n.currentNode); return t } function mc(e) { const t = document.activeElement; return e.some(n => n === t ? !0 : (n.focus(), document.activeElement !== t)) } var UC = a0, x0 = c0, w0 = d0, b0 = f0, S0 = h0, C0 = m0, k0 = pf; function T0(e) { var t, n, r = ""; if (typeof e == "string" || typeof e == "number") r += e; else if (typeof e == "object") if (Array.isArray(e)) { var s = e.length; for (t = 0; t < s; t++)e[t] && (n = T0(e[t])) && (r && (r += " "), r += n) } else for (n in e) e[n] && (r && (r += " "), r += n); return r } function E0() { for (var e, t, n = 0, r = "", s = arguments.length; n < s; n++)(e = arguments[n]) && (t = T0(e)) && (r && (r += " "), r += t); return r } const Ap = e => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e, Mp = E0, WC = (e, t) => n => { var r; if ((t == null ? void 0 : t.variants) == null) return Mp(e, n == null ? void 0 : n.class, n == null ? void 0 : n.className); const { variants: s, defaultVariants: i } = t, o = Object.keys(s).map(c => { const d = n == null ? void 0 : n[c], f = i == null ? void 0 : i[c]; if (d === null) return null; const h = Ap(d) || Ap(f); return s[c][h] }), a = n && Object.entries(n).reduce((c, d) => { let [f, h] = d; return h === void 0 || (c[f] = h), c }, {}), l = t == null || (r = t.compoundVariants) === null || r === void 0 ? void 0 : r.reduce((c, d) => { let { class: f, className: h, ...p } = d; return Object.entries(p).every(w => { let [y, b] = w; return Array.isArray(b) ? b.includes({ ...i, ...a }[y]) : { ...i, ...a }[y] === b }) ? [...c, f, h] : c }, []); return Mp(e, o, l, n == null ? void 0 : n.class, n == null ? void 0 : n.className) };/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const HC = e => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), N0 = (...e) => e.filter((t, n, r) => !!t && t.trim() !== "" && r.indexOf(t) === n).join(" ").trim();/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var KC = { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" };/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const YC = x.forwardRef(({ color: e = "currentColor", size: t = 24, strokeWidth: n = 2, absoluteStrokeWidth: r, className: s = "", children: i, iconNode: o, ...a }, l) => x.createElement("svg", { ref: l, ...KC, width: t, height: t, stroke: e, strokeWidth: r ? Number(n) * 24 / Number(t) : n, className: N0("lucide", s), ...a }, [...o.map(([c, d]) => x.createElement(c, d)), ...Array.isArray(i) ? i : [i]]));/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const ke = (e, t) => { const n = x.forwardRef(({ className: r, ...s }, i) => x.createElement(YC, { ref: i, iconNode: t, className: N0(`lucide-${HC(e)}`, r), ...s })); return n.displayName = `${e}`, n };/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Zi = ke("Calendar", [["path", { d: "M8 2v4", key: "1cmpym" }], ["path", { d: "M16 2v4", key: "4m81vk" }], ["rect", { width: "18", height: "18", x: "3", y: "4", rx: "2", key: "1hopcy" }], ["path", { d: "M3 10h18", key: "8toen8" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const GC = ke("Car", [["path", { d: "M19 17h2c.6 0 1-.4 1-1v-3c0-.9-.7-1.7-1.5-1.9C18.7 10.6 16 10 16 10s-1.3-1.4-2.2-2.3c-.5-.4-1.1-.7-1.8-.7H5c-.6 0-1.1.4-1.4.9l-1.4 2.9A3.7 3.7 0 0 0 2 12v4c0 .6.4 1 1 1h2", key: "5owen" }], ["circle", { cx: "7", cy: "17", r: "2", key: "u2ysq9" }], ["path", { d: "M9 17h6", key: "r8uit2" }], ["circle", { cx: "17", cy: "17", r: "2", key: "axvx0g" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Xt = ke("ChevronRight", [["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const QC = ke("CircleAlert", [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }], ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const qC = ke("CircleSlash", [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["line", { x1: "9", x2: "15", y1: "15", y2: "9", key: "1dfufj" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Cs = ke("Clock", [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["polyline", { points: "12 6 12 12 16 14", key: "68esgv" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const XC = ke("Download", [["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }], ["polyline", { points: "7 10 12 15 17 10", key: "2ggqvy" }], ["line", { x1: "12", x2: "12", y1: "15", y2: "3", key: "1vk2je" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const ZC = ke("Facebook", [["path", { d: "M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z", key: "1jg4f8" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const JC = ke("Instagram", [["rect", { width: "20", height: "20", x: "2", y: "2", rx: "5", ry: "5", key: "2e1cvw" }], ["path", { d: "M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z", key: "9exkf1" }], ["line", { x1: "17.5", x2: "17.51", y1: "6.5", y2: "6.5", key: "r4j83e" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const gc = ke("Leaf", [["path", { d: "M11 20A7 7 0 0 1 9.8 6.1C15.5 5 17 4.48 19 2c1 2 2 4.18 2 8 0 5.5-4.78 10-10 10Z", key: "nnexq3" }], ["path", { d: "M2 21c0-3 1.85-5.36 5.08-6C9.5 14.52 12 13 13 12", key: "mt58a7" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const mf = ke("Mail", [["rect", { width: "20", height: "16", x: "2", y: "4", rx: "2", key: "18n3k1" }], ["path", { d: "m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7", key: "1ocrg3" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const gf = ke("MapPin", [["path", { d: "M20 10c0 4.993-5.539 10.193-7.399 11.799a1 1 0 0 1-1.202 0C9.539 20.193 4 14.993 4 10a8 8 0 0 1 16 0", key: "1r0f0z" }], ["circle", { cx: "12", cy: "10", r: "3", key: "ilqhr7" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const ek = ke("Menu", [["line", { x1: "4", x2: "20", y1: "12", y2: "12", key: "1e0a9i" }], ["line", { x1: "4", x2: "20", y1: "6", y2: "6", key: "1owob3" }], ["line", { x1: "4", x2: "20", y1: "18", y2: "18", key: "yk5zj1" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const zr = ke("Phone", [["path", { d: "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z", key: "foiqr5" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const tk = ke("Search", [["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }], ["path", { d: "m21 21-4.3-4.3", key: "1qie3q" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const nk = ke("Star", [["path", { d: "M11.525 2.295a.53.53 0 0 1 .95 0l2.31 4.679a2.123 2.123 0 0 0 1.595 1.16l5.166.756a.53.53 0 0 1 .294.904l-3.736 3.638a2.123 2.123 0 0 0-.611 1.878l.882 5.14a.53.53 0 0 1-.771.56l-4.618-2.428a2.122 2.122 0 0 0-1.973 0L6.396 21.01a.53.53 0 0 1-.77-.56l.881-5.139a2.122 2.122 0 0 0-.611-1.879L2.16 9.795a.53.53 0 0 1 .294-.906l5.165-.755a2.122 2.122 0 0 0 1.597-1.16z", key: "r04s7s" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const rk = ke("Twitter", [["path", { d: "M22 4s-.7 2.1-2 3.4c1.6 10-9.4 17.3-18 11.6 2.2.1 4.4-.6 6-2C3 15.5.5 9.6 3 5c2.2 2.6 5.6 4.1 9 4-.9-4.2 4-6.6 7-3.8 1.1 0 3-1.2 3-1.2z", key: "pff0z6" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const sk = ke("User", [["path", { d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2", key: "975kel" }], ["circle", { cx: "12", cy: "7", r: "4", key: "17ys0d" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Dp = ke("Users", [["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }], ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }], ["path", { d: "M22 21v-2a4 4 0 0 0-3-3.87", key: "kshegd" }], ["path", { d: "M16 3.13a4 4 0 0 1 0 7.75", key: "1da9ce" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Lu = ke("X", [["path", { d: "M18 6 6 18", key: "1bl5f8" }], ["path", { d: "m6 6 12 12", key: "d8bk6v" }]]), yf = "-", ik = e => { const t = ak(e), { conflictingClassGroups: n, conflictingClassGroupModifiers: r } = e; return { getClassGroupId: o => { const a = o.split(yf); return a[0] === "" && a.length !== 1 && a.shift(), P0(a, t) || ok(o) }, getConflictingClassGroupIds: (o, a) => { const l = n[o] || []; return a && r[o] ? [...l, ...r[o]] : l } } }, P0 = (e, t) => { var o; if (e.length === 0) return t.classGroupId; const n = e[0], r = t.nextPart.get(n), s = r ? P0(e.slice(1), r) : void 0; if (s) return s; if (t.validators.length === 0) return; const i = e.join(yf); return (o = t.validators.find(({ validator: a }) => a(i))) == null ? void 0 : o.classGroupId }, Lp = /^\[(.+)\]$/, ok = e => { if (Lp.test(e)) { const t = Lp.exec(e)[1], n = t == null ? void 0 : t.substring(0, t.indexOf(":")); if (n) return "arbitrary.." + n } }, ak = e => { const { theme: t, prefix: n } = e, r = { nextPart: new Map, validators: [] }; return ck(Object.entries(e.classGroups), n).forEach(([i, o]) => { Ou(o, r, i, t) }), r }, Ou = (e, t, n, r) => { e.forEach(s => { if (typeof s == "string") { const i = s === "" ? t : Op(t, s); i.classGroupId = n; return } if (typeof s == "function") { if (lk(s)) { Ou(s(r), t, n, r); return } t.validators.push({ validator: s, classGroupId: n }); return } Object.entries(s).forEach(([i, o]) => { Ou(o, Op(t, i), n, r) }) }) }, Op = (e, t) => { let n = e; return t.split(yf).forEach(r => { n.nextPart.has(r) || n.nextPart.set(r, { nextPart: new Map, validators: [] }), n = n.nextPart.get(r) }), n }, lk = e => e.isThemeGetter, ck = (e, t) => t ? e.map(([n, r]) => { const s = r.map(i => typeof i == "string" ? t + i : typeof i == "object" ? Object.fromEntries(Object.entries(i).map(([o, a]) => [t + o, a])) : i); return [n, s] }) : e, uk = e => { if (e < 1) return { get: () => { }, set: () => { } }; let t = 0, n = new Map, r = new Map; const s = (i, o) => { n.set(i, o), t++, t > e && (t = 0, r = n, n = new Map) }; return { get(i) { let o = n.get(i); if (o !== void 0) return o; if ((o = r.get(i)) !== void 0) return s(i, o), o }, set(i, o) { n.has(i) ? n.set(i, o) : s(i, o) } } }, j0 = "!", dk = e => { const { separator: t, experimentalParseClassName: n } = e, r = t.length === 1, s = t[0], i = t.length, o = a => { const l = []; let c = 0, d = 0, f; for (let b = 0; b < a.length; b++) { let g = a[b]; if (c === 0) { if (g === s && (r || a.slice(b, b + i) === t)) { l.push(a.slice(d, b)), d = b + i; continue } if (g === "/") { f = b; continue } } g === "[" ? c++ : g === "]" && c-- } const h = l.length === 0 ? a : a.substring(d), p = h.startsWith(j0), w = p ? h.substring(1) : h, y = f && f > d ? f - d : void 0; return { modifiers: l, hasImportantModifier: p, baseClassName: w, maybePostfixModifierPosition: y } }; return n ? a => n({ className: a, parseClassName: o }) : o }, fk = e => { if (e.length <= 1) return e; const t = []; let n = []; return e.forEach(r => { r[0] === "[" ? (t.push(...n.sort(), r), n = []) : n.push(r) }), t.push(...n.sort()), t }, hk = e => ({ cache: uk(e.cacheSize), parseClassName: dk(e), ...ik(e) }), pk = /\s+/, mk = (e, t) => { const { parseClassName: n, getClassGroupId: r, getConflictingClassGroupIds: s } = t, i = [], o = e.trim().split(pk); let a = ""; for (let l = o.length - 1; l >= 0; l -= 1) { const c = o[l], { modifiers: d, hasImportantModifier: f, baseClassName: h, maybePostfixModifierPosition: p } = n(c); let w = !!p, y = r(w ? h.substring(0, p) : h); if (!y) { if (!w) { a = c + (a.length > 0 ? " " + a : a); continue } if (y = r(h), !y) { a = c + (a.length > 0 ? " " + a : a); continue } w = !1 } const b = fk(d).join(":"), g = f ? b + j0 : b, m = g + y; if (i.includes(m)) continue; i.push(m); const v = s(y, w); for (let S = 0; S < v.length; ++S) { const C = v[S]; i.push(g + C) } a = c + (a.length > 0 ? " " + a : a) } return a }; function gk() { let e = 0, t, n, r = ""; for (; e < arguments.length;)(t = arguments[e++]) && (n = R0(t)) && (r && (r += " "), r += n); return r } const R0 = e => { if (typeof e == "string") return e; let t, n = ""; for (let r = 0; r < e.length; r++)e[r] && (t = R0(e[r])) && (n && (n += " "), n += t); return n }; function yk(e, ...t) { let n, r, s, i = o; function o(l) { const c = t.reduce((d, f) => f(d), e()); return n = hk(c), r = n.cache.get, s = n.cache.set, i = a, a(l) } function a(l) { const c = r(l); if (c) return c; const d = mk(l, n); return s(l, d), d } return function () { return i(gk.apply(null, arguments)) } } const ie = e => { const t = n => n[e] || []; return t.isThemeGetter = !0, t }, A0 = /^\[(?:([a-z-]+):)?(.+)\]$/i, vk = /^\d+\/\d+$/, xk = new Set(["px", "full", "screen"]), wk = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, bk = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, Sk = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, Ck = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, kk = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, rn = e => ks(e) || xk.has(e) || vk.test(e), jn = e => Qs(e, "length", Mk), ks = e => !!e && !Number.isNaN(Number(e)), yc = e => Qs(e, "number", ks), hi = e => !!e && Number.isInteger(Number(e)), Tk = e => e.endsWith("%") && ks(e.slice(0, -1)), Y = e => A0.test(e), Rn = e => wk.test(e), Ek = new Set(["length", "size", "percentage"]), Nk = e => Qs(e, Ek, M0), Pk = e => Qs(e, "position", M0), jk = new Set(["image", "url"]), Rk = e => Qs(e, jk, Lk), Ak = e => Qs(e, "", Dk), pi = () => !0, Qs = (e, t, n) => { const r = A0.exec(e); return r ? r[1] ? typeof t == "string" ? r[1] === t : t.has(r[1]) : n(r[2]) : !1 }, Mk = e => bk.test(e) && !Sk.test(e), M0 = () => !1, Dk = e => Ck.test(e), Lk = e => kk.test(e), Ok = () => { const e = ie("colors"), t = ie("spacing"), n = ie("blur"), r = ie("brightness"), s = ie("borderColor"), i = ie("borderRadius"), o = ie("borderSpacing"), a = ie("borderWidth"), l = ie("contrast"), c = ie("grayscale"), d = ie("hueRotate"), f = ie("invert"), h = ie("gap"), p = ie("gradientColorStops"), w = ie("gradientColorStopPositions"), y = ie("inset"), b = ie("margin"), g = ie("opacity"), m = ie("padding"), v = ie("saturate"), S = ie("scale"), C = ie("sepia"), k = ie("skew"), T = ie("space"), E = ie("translate"), A = () => ["auto", "contain", "none"], R = () => ["auto", "hidden", "clip", "visible", "scroll"], _ = () => ["auto", Y, t], I = () => [Y, t], G = () => ["", rn, jn], L = () => ["auto", ks, Y], Q = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], $ = () => ["solid", "dashed", "dotted", "double", "none"], V = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], N = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], j = () => ["", "0", Y], O = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], U = () => [ks, Y]; return { cacheSize: 500, separator: ":", theme: { colors: [pi], spacing: [rn, jn], blur: ["none", "", Rn, Y], brightness: U(), borderColor: [e], borderRadius: ["none", "", "full", Rn, Y], borderSpacing: I(), borderWidth: G(), contrast: U(), grayscale: j(), hueRotate: U(), invert: j(), gap: I(), gradientColorStops: [e], gradientColorStopPositions: [Tk, jn], inset: _(), margin: _(), opacity: U(), padding: I(), saturate: U(), scale: U(), sepia: j(), skew: U(), space: I(), translate: I() }, classGroups: { aspect: [{ aspect: ["auto", "square", "video", Y] }], container: ["container"], columns: [{ columns: [Rn] }], "break-after": [{ "break-after": O() }], "break-before": [{ "break-before": O() }], "break-inside": [{ "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] }], "box-decoration": [{ "box-decoration": ["slice", "clone"] }], box: [{ box: ["border", "content"] }], display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"], float: [{ float: ["right", "left", "none", "start", "end"] }], clear: [{ clear: ["left", "right", "both", "none", "start", "end"] }], isolation: ["isolate", "isolation-auto"], "object-fit": [{ object: ["contain", "cover", "fill", "none", "scale-down"] }], "object-position": [{ object: [...Q(), Y] }], overflow: [{ overflow: R() }], "overflow-x": [{ "overflow-x": R() }], "overflow-y": [{ "overflow-y": R() }], overscroll: [{ overscroll: A() }], "overscroll-x": [{ "overscroll-x": A() }], "overscroll-y": [{ "overscroll-y": A() }], position: ["static", "fixed", "absolute", "relative", "sticky"], inset: [{ inset: [y] }], "inset-x": [{ "inset-x": [y] }], "inset-y": [{ "inset-y": [y] }], start: [{ start: [y] }], end: [{ end: [y] }], top: [{ top: [y] }], right: [{ right: [y] }], bottom: [{ bottom: [y] }], left: [{ left: [y] }], visibility: ["visible", "invisible", "collapse"], z: [{ z: ["auto", hi, Y] }], basis: [{ basis: _() }], "flex-direction": [{ flex: ["row", "row-reverse", "col", "col-reverse"] }], "flex-wrap": [{ flex: ["wrap", "wrap-reverse", "nowrap"] }], flex: [{ flex: ["1", "auto", "initial", "none", Y] }], grow: [{ grow: j() }], shrink: [{ shrink: j() }], order: [{ order: ["first", "last", "none", hi, Y] }], "grid-cols": [{ "grid-cols": [pi] }], "col-start-end": [{ col: ["auto", { span: ["full", hi, Y] }, Y] }], "col-start": [{ "col-start": L() }], "col-end": [{ "col-end": L() }], "grid-rows": [{ "grid-rows": [pi] }], "row-start-end": [{ row: ["auto", { span: [hi, Y] }, Y] }], "row-start": [{ "row-start": L() }], "row-end": [{ "row-end": L() }], "grid-flow": [{ "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] }], "auto-cols": [{ "auto-cols": ["auto", "min", "max", "fr", Y] }], "auto-rows": [{ "auto-rows": ["auto", "min", "max", "fr", Y] }], gap: [{ gap: [h] }], "gap-x": [{ "gap-x": [h] }], "gap-y": [{ "gap-y": [h] }], "justify-content": [{ justify: ["normal", ...N()] }], "justify-items": [{ "justify-items": ["start", "end", "center", "stretch"] }], "justify-self": [{ "justify-self": ["auto", "start", "end", "center", "stretch"] }], "align-content": [{ content: ["normal", ...N(), "baseline"] }], "align-items": [{ items: ["start", "end", "center", "baseline", "stretch"] }], "align-self": [{ self: ["auto", "start", "end", "center", "stretch", "baseline"] }], "place-content": [{ "place-content": [...N(), "baseline"] }], "place-items": [{ "place-items": ["start", "end", "center", "baseline", "stretch"] }], "place-self": [{ "place-self": ["auto", "start", "end", "center", "stretch"] }], p: [{ p: [m] }], px: [{ px: [m] }], py: [{ py: [m] }], ps: [{ ps: [m] }], pe: [{ pe: [m] }], pt: [{ pt: [m] }], pr: [{ pr: [m] }], pb: [{ pb: [m] }], pl: [{ pl: [m] }], m: [{ m: [b] }], mx: [{ mx: [b] }], my: [{ my: [b] }], ms: [{ ms: [b] }], me: [{ me: [b] }], mt: [{ mt: [b] }], mr: [{ mr: [b] }], mb: [{ mb: [b] }], ml: [{ ml: [b] }], "space-x": [{ "space-x": [T] }], "space-x-reverse": ["space-x-reverse"], "space-y": [{ "space-y": [T] }], "space-y-reverse": ["space-y-reverse"], w: [{ w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", Y, t] }], "min-w": [{ "min-w": [Y, t, "min", "max", "fit"] }], "max-w": [{ "max-w": [Y, t, "none", "full", "min", "max", "fit", "prose", { screen: [Rn] }, Rn] }], h: [{ h: [Y, t, "auto", "min", "max", "fit", "svh", "lvh", "dvh"] }], "min-h": [{ "min-h": [Y, t, "min", "max", "fit", "svh", "lvh", "dvh"] }], "max-h": [{ "max-h": [Y, t, "min", "max", "fit", "svh", "lvh", "dvh"] }], size: [{ size: [Y, t, "auto", "min", "max", "fit"] }], "font-size": [{ text: ["base", Rn, jn] }], "font-smoothing": ["antialiased", "subpixel-antialiased"], "font-style": ["italic", "not-italic"], "font-weight": [{ font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", yc] }], "font-family": [{ font: [pi] }], "fvn-normal": ["normal-nums"], "fvn-ordinal": ["ordinal"], "fvn-slashed-zero": ["slashed-zero"], "fvn-figure": ["lining-nums", "oldstyle-nums"], "fvn-spacing": ["proportional-nums", "tabular-nums"], "fvn-fraction": ["diagonal-fractions", "stacked-fractions"], tracking: [{ tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", Y] }], "line-clamp": [{ "line-clamp": ["none", ks, yc] }], leading: [{ leading: ["none", "tight", "snug", "normal", "relaxed", "loose", rn, Y] }], "list-image": [{ "list-image": ["none", Y] }], "list-style-type": [{ list: ["none", "disc", "decimal", Y] }], "list-style-position": [{ list: ["inside", "outside"] }], "placeholder-color": [{ placeholder: [e] }], "placeholder-opacity": [{ "placeholder-opacity": [g] }], "text-alignment": [{ text: ["left", "center", "right", "justify", "start", "end"] }], "text-color": [{ text: [e] }], "text-opacity": [{ "text-opacity": [g] }], "text-decoration": ["underline", "overline", "line-through", "no-underline"], "text-decoration-style": [{ decoration: [...$(), "wavy"] }], "text-decoration-thickness": [{ decoration: ["auto", "from-font", rn, jn] }], "underline-offset": [{ "underline-offset": ["auto", rn, Y] }], "text-decoration-color": [{ decoration: [e] }], "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"], "text-overflow": ["truncate", "text-ellipsis", "text-clip"], "text-wrap": [{ text: ["wrap", "nowrap", "balance", "pretty"] }], indent: [{ indent: I() }], "vertical-align": [{ align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", Y] }], whitespace: [{ whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"] }], break: [{ break: ["normal", "words", "all", "keep"] }], hyphens: [{ hyphens: ["none", "manual", "auto"] }], content: [{ content: ["none", Y] }], "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }], "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }], "bg-opacity": [{ "bg-opacity": [g] }], "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }], "bg-position": [{ bg: [...Q(), Pk] }], "bg-repeat": [{ bg: ["no-repeat", { repeat: ["", "x", "y", "round", "space"] }] }], "bg-size": [{ bg: ["auto", "cover", "contain", Nk] }], "bg-image": [{ bg: ["none", { "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"] }, Rk] }], "bg-color": [{ bg: [e] }], "gradient-from-pos": [{ from: [w] }], "gradient-via-pos": [{ via: [w] }], "gradient-to-pos": [{ to: [w] }], "gradient-from": [{ from: [p] }], "gradient-via": [{ via: [p] }], "gradient-to": [{ to: [p] }], rounded: [{ rounded: [i] }], "rounded-s": [{ "rounded-s": [i] }], "rounded-e": [{ "rounded-e": [i] }], "rounded-t": [{ "rounded-t": [i] }], "rounded-r": [{ "rounded-r": [i] }], "rounded-b": [{ "rounded-b": [i] }], "rounded-l": [{ "rounded-l": [i] }], "rounded-ss": [{ "rounded-ss": [i] }], "rounded-se": [{ "rounded-se": [i] }], "rounded-ee": [{ "rounded-ee": [i] }], "rounded-es": [{ "rounded-es": [i] }], "rounded-tl": [{ "rounded-tl": [i] }], "rounded-tr": [{ "rounded-tr": [i] }], "rounded-br": [{ "rounded-br": [i] }], "rounded-bl": [{ "rounded-bl": [i] }], "border-w": [{ border: [a] }], "border-w-x": [{ "border-x": [a] }], "border-w-y": [{ "border-y": [a] }], "border-w-s": [{ "border-s": [a] }], "border-w-e": [{ "border-e": [a] }], "border-w-t": [{ "border-t": [a] }], "border-w-r": [{ "border-r": [a] }], "border-w-b": [{ "border-b": [a] }], "border-w-l": [{ "border-l": [a] }], "border-opacity": [{ "border-opacity": [g] }], "border-style": [{ border: [...$(), "hidden"] }], "divide-x": [{ "divide-x": [a] }], "divide-x-reverse": ["divide-x-reverse"], "divide-y": [{ "divide-y": [a] }], "divide-y-reverse": ["divide-y-reverse"], "divide-opacity": [{ "divide-opacity": [g] }], "divide-style": [{ divide: $() }], "border-color": [{ border: [s] }], "border-color-x": [{ "border-x": [s] }], "border-color-y": [{ "border-y": [s] }], "border-color-s": [{ "border-s": [s] }], "border-color-e": [{ "border-e": [s] }], "border-color-t": [{ "border-t": [s] }], "border-color-r": [{ "border-r": [s] }], "border-color-b": [{ "border-b": [s] }], "border-color-l": [{ "border-l": [s] }], "divide-color": [{ divide: [s] }], "outline-style": [{ outline: ["", ...$()] }], "outline-offset": [{ "outline-offset": [rn, Y] }], "outline-w": [{ outline: [rn, jn] }], "outline-color": [{ outline: [e] }], "ring-w": [{ ring: G() }], "ring-w-inset": ["ring-inset"], "ring-color": [{ ring: [e] }], "ring-opacity": [{ "ring-opacity": [g] }], "ring-offset-w": [{ "ring-offset": [rn, jn] }], "ring-offset-color": [{ "ring-offset": [e] }], shadow: [{ shadow: ["", "inner", "none", Rn, Ak] }], "shadow-color": [{ shadow: [pi] }], opacity: [{ opacity: [g] }], "mix-blend": [{ "mix-blend": [...V(), "plus-lighter", "plus-darker"] }], "bg-blend": [{ "bg-blend": V() }], filter: [{ filter: ["", "none"] }], blur: [{ blur: [n] }], brightness: [{ brightness: [r] }], contrast: [{ contrast: [l] }], "drop-shadow": [{ "drop-shadow": ["", "none", Rn, Y] }], grayscale: [{ grayscale: [c] }], "hue-rotate": [{ "hue-rotate": [d] }], invert: [{ invert: [f] }], saturate: [{ saturate: [v] }], sepia: [{ sepia: [C] }], "backdrop-filter": [{ "backdrop-filter": ["", "none"] }], "backdrop-blur": [{ "backdrop-blur": [n] }], "backdrop-brightness": [{ "backdrop-brightness": [r] }], "backdrop-contrast": [{ "backdrop-contrast": [l] }], "backdrop-grayscale": [{ "backdrop-grayscale": [c] }], "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [d] }], "backdrop-invert": [{ "backdrop-invert": [f] }], "backdrop-opacity": [{ "backdrop-opacity": [g] }], "backdrop-saturate": [{ "backdrop-saturate": [v] }], "backdrop-sepia": [{ "backdrop-sepia": [C] }], "border-collapse": [{ border: ["collapse", "separate"] }], "border-spacing": [{ "border-spacing": [o] }], "border-spacing-x": [{ "border-spacing-x": [o] }], "border-spacing-y": [{ "border-spacing-y": [o] }], "table-layout": [{ table: ["auto", "fixed"] }], caption: [{ caption: ["top", "bottom"] }], transition: [{ transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", Y] }], duration: [{ duration: U() }], ease: [{ ease: ["linear", "in", "out", "in-out", Y] }], delay: [{ delay: U() }], animate: [{ animate: ["none", "spin", "ping", "pulse", "bounce", Y] }], transform: [{ transform: ["", "gpu", "none"] }], scale: [{ scale: [S] }], "scale-x": [{ "scale-x": [S] }], "scale-y": [{ "scale-y": [S] }], rotate: [{ rotate: [hi, Y] }], "translate-x": [{ "translate-x": [E] }], "translate-y": [{ "translate-y": [E] }], "skew-x": [{ "skew-x": [k] }], "skew-y": [{ "skew-y": [k] }], "transform-origin": [{ origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", Y] }], accent: [{ accent: ["auto", e] }], appearance: [{ appearance: ["none", "auto"] }], cursor: [{ cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", Y] }], "caret-color": [{ caret: [e] }], "pointer-events": [{ "pointer-events": ["none", "auto"] }], resize: [{ resize: ["none", "y", "x", ""] }], "scroll-behavior": [{ scroll: ["auto", "smooth"] }], "scroll-m": [{ "scroll-m": I() }], "scroll-mx": [{ "scroll-mx": I() }], "scroll-my": [{ "scroll-my": I() }], "scroll-ms": [{ "scroll-ms": I() }], "scroll-me": [{ "scroll-me": I() }], "scroll-mt": [{ "scroll-mt": I() }], "scroll-mr": [{ "scroll-mr": I() }], "scroll-mb": [{ "scroll-mb": I() }], "scroll-ml": [{ "scroll-ml": I() }], "scroll-p": [{ "scroll-p": I() }], "scroll-px": [{ "scroll-px": I() }], "scroll-py": [{ "scroll-py": I() }], "scroll-ps": [{ "scroll-ps": I() }], "scroll-pe": [{ "scroll-pe": I() }], "scroll-pt": [{ "scroll-pt": I() }], "scroll-pr": [{ "scroll-pr": I() }], "scroll-pb": [{ "scroll-pb": I() }], "scroll-pl": [{ "scroll-pl": I() }], "snap-align": [{ snap: ["start", "end", "center", "align-none"] }], "snap-stop": [{ snap: ["normal", "always"] }], "snap-type": [{ snap: ["none", "x", "y", "both"] }], "snap-strictness": [{ snap: ["mandatory", "proximity"] }], touch: [{ touch: ["auto", "none", "manipulation"] }], "touch-x": [{ "touch-pan": ["x", "left", "right"] }], "touch-y": [{ "touch-pan": ["y", "up", "down"] }], "touch-pz": ["touch-pinch-zoom"], select: [{ select: ["none", "text", "all", "auto"] }], "will-change": [{ "will-change": ["auto", "scroll", "contents", "transform", Y] }], fill: [{ fill: [e, "none"] }], "stroke-w": [{ stroke: [rn, jn, yc] }], stroke: [{ stroke: [e, "none"] }], sr: ["sr-only", "not-sr-only"], "forced-color-adjust": [{ "forced-color-adjust": ["auto", "none"] }] }, conflictingClassGroups: { overflow: ["overflow-x", "overflow-y"], overscroll: ["overscroll-x", "overscroll-y"], inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"], "inset-x": ["right", "left"], "inset-y": ["top", "bottom"], flex: ["basis", "grow", "shrink"], gap: ["gap-x", "gap-y"], p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"], px: ["pr", "pl"], py: ["pt", "pb"], m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"], mx: ["mr", "ml"], my: ["mt", "mb"], size: ["w", "h"], "font-size": ["leading"], "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"], "fvn-ordinal": ["fvn-normal"], "fvn-slashed-zero": ["fvn-normal"], "fvn-figure": ["fvn-normal"], "fvn-spacing": ["fvn-normal"], "fvn-fraction": ["fvn-normal"], "line-clamp": ["display", "overflow"], rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"], "rounded-s": ["rounded-ss", "rounded-es"], "rounded-e": ["rounded-se", "rounded-ee"], "rounded-t": ["rounded-tl", "rounded-tr"], "rounded-r": ["rounded-tr", "rounded-br"], "rounded-b": ["rounded-br", "rounded-bl"], "rounded-l": ["rounded-tl", "rounded-bl"], "border-spacing": ["border-spacing-x", "border-spacing-y"], "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"], "border-w-x": ["border-w-r", "border-w-l"], "border-w-y": ["border-w-t", "border-w-b"], "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"], "border-color-x": ["border-color-r", "border-color-l"], "border-color-y": ["border-color-t", "border-color-b"], "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"], "scroll-mx": ["scroll-mr", "scroll-ml"], "scroll-my": ["scroll-mt", "scroll-mb"], "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"], "scroll-px": ["scroll-pr", "scroll-pl"], "scroll-py": ["scroll-pt", "scroll-pb"], touch: ["touch-x", "touch-y", "touch-pz"], "touch-x": ["touch"], "touch-y": ["touch"], "touch-pz": ["touch"] }, conflictingClassGroupModifiers: { "font-size": ["leading"] } } }, Ik = yk(Ok); function Wr(...e) { return Ik(E0(e)) } const Fk = UC, D0 = x.forwardRef(({ className: e, ...t }, n) => u.jsx(x0, { ref: n, className: Wr("fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]", e), ...t })); D0.displayName = x0.displayName; const Vk = WC("group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full", { variants: { variant: { default: "border bg-background text-foreground", destructive: "destructive group border-destructive bg-destructive text-destructive-foreground" } }, defaultVariants: { variant: "default" } }), L0 = x.forwardRef(({ className: e, variant: t, ...n }, r) => u.jsx(w0, { ref: r, className: Wr(Vk({ variant: t }), e), ...n })); L0.displayName = w0.displayName; const _k = x.forwardRef(({ className: e, ...t }, n) => u.jsx(C0, { ref: n, className: Wr("inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors group-[.destructive]:border-muted/40 hover:bg-secondary group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 group-[.destructive]:focus:ring-destructive disabled:pointer-events-none disabled:opacity-50", e), ...t })); _k.displayName = C0.displayName; const O0 = x.forwardRef(({ className: e, ...t }, n) => u.jsx(k0, { ref: n, className: Wr("absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity group-hover:opacity-100 group-[.destructive]:text-red-300 hover:text-foreground group-[.destructive]:hover:text-red-50 focus:opacity-100 focus:outline-none focus:ring-2 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600", e), "toast-close": "", ...t, children: u.jsx(Lu, { className: "h-4 w-4" }) })); O0.displayName = k0.displayName; const I0 = x.forwardRef(({ className: e, ...t }, n) => u.jsx(b0, { ref: n, className: Wr("text-sm font-semibold", e), ...t })); I0.displayName = b0.displayName; const F0 = x.forwardRef(({ className: e, ...t }, n) => u.jsx(S0, { ref: n, className: Wr("text-sm opacity-90", e), ...t })); F0.displayName = S0.displayName; function zk() { const { toasts: e } = XS(); return u.jsxs(Fk, { children: [e.map(function ({ id: t, title: n, description: r, action: s, ...i }) { return u.jsxs(L0, { ...i, children: [u.jsxs("div", { className: "grid gap-1", children: [n && u.jsx(I0, { children: n }), r && u.jsx(F0, { children: r })] }), s, u.jsx(O0, {})] }, t) }), u.jsx(D0, {})] }) } var Ip = ["light", "dark"], Bk = "(prefers-color-scheme: dark)", $k = x.createContext(void 0), Uk = { setTheme: e => { }, themes: [] }, Wk = () => { var e; return (e = x.useContext($k)) != null ? e : Uk }; x.memo(({ forcedTheme: e, storageKey: t, attribute: n, enableSystem: r, enableColorScheme: s, defaultTheme: i, value: o, attrs: a, nonce: l }) => { let c = i === "system", d = n === "class" ? `var d=document.documentElement,c=d.classList;${`c.remove(${a.map(w => `'${w}'`).join(",")})`};` : `var d=document.documentElement,n='${n}',s='setAttribute';`, f = s ? Ip.includes(i) && i ? `if(e==='light'||e==='dark'||!e)d.style.colorScheme=e||'${i}'` : "if(e==='light'||e==='dark')d.style.colorScheme=e" : "", h = (w, y = !1, b = !0) => { let g = o ? o[w] : w, m = y ? w + "|| ''" : `'${g}'`, v = ""; return s && b && !y && Ip.includes(w) && (v += `d.style.colorScheme = '${w}';`), n === "class" ? y || g ? v += `c.add(${m})` : v += "null" : g && (v += `d[s](n,${m})`), v }, p = e ? `!function(){${d}${h(e)}}()` : r ? `!function(){try{${d}var e=localStorage.getItem('${t}');if('system'===e||(!e&&${c})){var t='${Bk}',m=window.matchMedia(t);if(m.media!==t||m.matches){${h("dark")}}else{${h("light")}}}else if(e){${o ? `var x=${JSON.stringify(o)};` : ""}${h(o ? "x[e]" : "e", !0)}}${c ? "" : "else{" + h(i, !1, !1) + "}"}${f}}catch(e){}}()` : `!function(){try{${d}var e=localStorage.getItem('${t}');if(e){${o ? `var x=${JSON.stringify(o)};` : ""}${h(o ? "x[e]" : "e", !0)}}else{${h(i, !1, !1)};}${f}}catch(t){}}();`; return x.createElement("script", { nonce: l, dangerouslySetInnerHTML: { __html: p } }) }); var Hk = e => { switch (e) { case "success": return Gk; case "info": return qk; case "warning": return Qk; case "error": return Xk; default: return null } }, Kk = Array(12).fill(0), Yk = ({ visible: e, className: t }) => D.createElement("div", { className: ["sonner-loading-wrapper", t].filter(Boolean).join(" "), "data-visible": e }, D.createElement("div", { className: "sonner-spinner" }, Kk.map((n, r) => D.createElement("div", { className: "sonner-loading-bar", key: `spinner-bar-${r}` })))), Gk = D.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, D.createElement("path", { fillRule: "evenodd", d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z", clipRule: "evenodd" })), Qk = D.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor", height: "20", width: "20" }, D.createElement("path", { fillRule: "evenodd", d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z", clipRule: "evenodd" })), qk = D.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, D.createElement("path", { fillRule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z", clipRule: "evenodd" })), Xk = D.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, D.createElement("path", { fillRule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z", clipRule: "evenodd" })), Zk = D.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "12", height: "12", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }, D.createElement("line", { x1: "18", y1: "6", x2: "6", y2: "18" }), D.createElement("line", { x1: "6", y1: "6", x2: "18", y2: "18" })), Jk = () => { let [e, t] = D.useState(document.hidden); return D.useEffect(() => { let n = () => { t(document.hidden) }; return document.addEventListener("visibilitychange", n), () => window.removeEventListener("visibilitychange", n) }, []), e }, Iu = 1, eT = class { constructor() { this.subscribe = e => (this.subscribers.push(e), () => { let t = this.subscribers.indexOf(e); this.subscribers.splice(t, 1) }), this.publish = e => { this.subscribers.forEach(t => t(e)) }, this.addToast = e => { this.publish(e), this.toasts = [...this.toasts, e] }, this.create = e => { var t; let { message: n, ...r } = e, s = typeof (e == null ? void 0 : e.id) == "number" || ((t = e.id) == null ? void 0 : t.length) > 0 ? e.id : Iu++, i = this.toasts.find(a => a.id === s), o = e.dismissible === void 0 ? !0 : e.dismissible; return this.dismissedToasts.has(s) && this.dismissedToasts.delete(s), i ? this.toasts = this.toasts.map(a => a.id === s ? (this.publish({ ...a, ...e, id: s, title: n }), { ...a, ...e, id: s, dismissible: o, title: n }) : a) : this.addToast({ title: n, ...r, dismissible: o, id: s }), s }, this.dismiss = e => (this.dismissedToasts.add(e), e || this.toasts.forEach(t => { this.subscribers.forEach(n => n({ id: t.id, dismiss: !0 })) }), this.subscribers.forEach(t => t({ id: e, dismiss: !0 })), e), this.message = (e, t) => this.create({ ...t, message: e }), this.error = (e, t) => this.create({ ...t, message: e, type: "error" }), this.success = (e, t) => this.create({ ...t, type: "success", message: e }), this.info = (e, t) => this.create({ ...t, type: "info", message: e }), this.warning = (e, t) => this.create({ ...t, type: "warning", message: e }), this.loading = (e, t) => this.create({ ...t, type: "loading", message: e }), this.promise = (e, t) => { if (!t) return; let n; t.loading !== void 0 && (n = this.create({ ...t, promise: e, type: "loading", message: t.loading, description: typeof t.description != "function" ? t.description : void 0 })); let r = e instanceof Promise ? e : e(), s = n !== void 0, i, o = r.then(async l => { if (i = ["resolve", l], D.isValidElement(l)) s = !1, this.create({ id: n, type: "default", message: l }); else if (nT(l) && !l.ok) { s = !1; let c = typeof t.error == "function" ? await t.error(`HTTP error! status: ${l.status}`) : t.error, d = typeof t.description == "function" ? await t.description(`HTTP error! status: ${l.status}`) : t.description; this.create({ id: n, type: "error", message: c, description: d }) } else if (t.success !== void 0) { s = !1; let c = typeof t.success == "function" ? await t.success(l) : t.success, d = typeof t.description == "function" ? await t.description(l) : t.description; this.create({ id: n, type: "success", message: c, description: d }) } }).catch(async l => { if (i = ["reject", l], t.error !== void 0) { s = !1; let c = typeof t.error == "function" ? await t.error(l) : t.error, d = typeof t.description == "function" ? await t.description(l) : t.description; this.create({ id: n, type: "error", message: c, description: d }) } }).finally(() => { var l; s && (this.dismiss(n), n = void 0), (l = t.finally) == null || l.call(t) }), a = () => new Promise((l, c) => o.then(() => i[0] === "reject" ? c(i[1]) : l(i[1])).catch(c)); return typeof n != "string" && typeof n != "number" ? { unwrap: a } : Object.assign(n, { unwrap: a }) }, this.custom = (e, t) => { let n = (t == null ? void 0 : t.id) || Iu++; return this.create({ jsx: e(n), id: n, ...t }), n }, this.getActiveToasts = () => this.toasts.filter(e => !this.dismissedToasts.has(e.id)), this.subscribers = [], this.toasts = [], this.dismissedToasts = new Set } }, qe = new eT, tT = (e, t) => { let n = (t == null ? void 0 : t.id) || Iu++; return qe.addToast({ title: e, ...t, id: n }), n }, nT = e => e && typeof e == "object" && "ok" in e && typeof e.ok == "boolean" && "status" in e && typeof e.status == "number", rT = tT, sT = () => qe.toasts, iT = () => qe.getActiveToasts(); Object.assign(rT, { success: qe.success, info: qe.info, warning: qe.warning, error: qe.error, custom: qe.custom, message: qe.message, promise: qe.promise, dismiss: qe.dismiss, loading: qe.loading }, { getHistory: sT, getToasts: iT }); function oT(e, { insertAt: t } = {}) { if (typeof document > "u") return; let n = document.head || document.getElementsByTagName("head")[0], r = document.createElement("style"); r.type = "text/css", t === "top" && n.firstChild ? n.insertBefore(r, n.firstChild) : n.appendChild(r), r.styleSheet ? r.styleSheet.cssText = e : r.appendChild(document.createTextNode(e)) } oT(`:where(html[dir="ltr"]),:where([data-sonner-toaster][dir="ltr"]){--toast-icon-margin-start: -3px;--toast-icon-margin-end: 4px;--toast-svg-margin-start: -1px;--toast-svg-margin-end: 0px;--toast-button-margin-start: auto;--toast-button-margin-end: 0;--toast-close-button-start: 0;--toast-close-button-end: unset;--toast-close-button-transform: translate(-35%, -35%)}:where(html[dir="rtl"]),:where([data-sonner-toaster][dir="rtl"]){--toast-icon-margin-start: 4px;--toast-icon-margin-end: -3px;--toast-svg-margin-start: 0px;--toast-svg-margin-end: -1px;--toast-button-margin-start: 0;--toast-button-margin-end: auto;--toast-close-button-start: unset;--toast-close-button-end: 0;--toast-close-button-transform: translate(35%, -35%)}:where([data-sonner-toaster]){position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1: hsl(0, 0%, 99%);--gray2: hsl(0, 0%, 97.3%);--gray3: hsl(0, 0%, 95.1%);--gray4: hsl(0, 0%, 93%);--gray5: hsl(0, 0%, 90.9%);--gray6: hsl(0, 0%, 88.7%);--gray7: hsl(0, 0%, 85.8%);--gray8: hsl(0, 0%, 78%);--gray9: hsl(0, 0%, 56.1%);--gray10: hsl(0, 0%, 52.3%);--gray11: hsl(0, 0%, 43.5%);--gray12: hsl(0, 0%, 9%);--border-radius: 8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:none;z-index:999999999;transition:transform .4s ease}:where([data-sonner-toaster][data-lifted="true"]){transform:translateY(-10px)}@media (hover: none) and (pointer: coarse){:where([data-sonner-toaster][data-lifted="true"]){transform:none}}:where([data-sonner-toaster][data-x-position="right"]){right:var(--offset-right)}:where([data-sonner-toaster][data-x-position="left"]){left:var(--offset-left)}:where([data-sonner-toaster][data-x-position="center"]){left:50%;transform:translate(-50%)}:where([data-sonner-toaster][data-y-position="top"]){top:var(--offset-top)}:where([data-sonner-toaster][data-y-position="bottom"]){bottom:var(--offset-bottom)}:where([data-sonner-toast]){--y: translateY(100%);--lift-amount: calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);filter:blur(0);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:none;overflow-wrap:anywhere}:where([data-sonner-toast][data-styled="true"]){padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px #0000001a;width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}:where([data-sonner-toast]:focus-visible){box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast][data-y-position="top"]){top:0;--y: translateY(-100%);--lift: 1;--lift-amount: calc(1 * var(--gap))}:where([data-sonner-toast][data-y-position="bottom"]){bottom:0;--y: translateY(100%);--lift: -1;--lift-amount: calc(var(--lift) * var(--gap))}:where([data-sonner-toast]) :where([data-description]){font-weight:400;line-height:1.4;color:inherit}:where([data-sonner-toast]) :where([data-title]){font-weight:500;line-height:1.5;color:inherit}:where([data-sonner-toast]) :where([data-icon]){display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}:where([data-sonner-toast][data-promise="true"]) :where([data-icon])>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}:where([data-sonner-toast]) :where([data-icon])>*{flex-shrink:0}:where([data-sonner-toast]) :where([data-icon]) svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}:where([data-sonner-toast]) :where([data-content]){display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;cursor:pointer;outline:none;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}:where([data-sonner-toast]) :where([data-button]):focus-visible{box-shadow:0 0 0 2px #0006}:where([data-sonner-toast]) :where([data-button]):first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}:where([data-sonner-toast]) :where([data-cancel]){color:var(--normal-text);background:rgba(0,0,0,.08)}:where([data-sonner-toast][data-theme="dark"]) :where([data-cancel]){background:rgba(255,255,255,.3)}:where([data-sonner-toast]) :where([data-close-button]){position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;color:var(--gray12);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast] [data-close-button]{background:var(--gray1)}:where([data-sonner-toast]) :where([data-close-button]):focus-visible{box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast]) :where([data-disabled="true"]){cursor:not-allowed}:where([data-sonner-toast]):hover :where([data-close-button]):hover{background:var(--gray2);border-color:var(--gray5)}:where([data-sonner-toast][data-swiping="true"]):before{content:"";position:absolute;left:-50%;right:-50%;height:100%;z-index:-1}:where([data-sonner-toast][data-y-position="top"][data-swiping="true"]):before{bottom:50%;transform:scaleY(3) translateY(50%)}:where([data-sonner-toast][data-y-position="bottom"][data-swiping="true"]):before{top:50%;transform:scaleY(3) translateY(-50%)}:where([data-sonner-toast][data-swiping="false"][data-removed="true"]):before{content:"";position:absolute;inset:0;transform:scaleY(2)}:where([data-sonner-toast]):after{content:"";position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}:where([data-sonner-toast][data-mounted="true"]){--y: translateY(0);opacity:1}:where([data-sonner-toast][data-expanded="false"][data-front="false"]){--scale: var(--toasts-before) * .05 + 1;--y: translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}:where([data-sonner-toast])>*{transition:opacity .4s}:where([data-sonner-toast][data-expanded="false"][data-front="false"][data-styled="true"])>*{opacity:0}:where([data-sonner-toast][data-visible="false"]){opacity:0;pointer-events:none}:where([data-sonner-toast][data-mounted="true"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}:where([data-sonner-toast][data-removed="true"][data-front="true"][data-swipe-out="false"]){--y: translateY(calc(var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="false"]){--y: translateY(40%);opacity:0;transition:transform .5s,opacity .2s}:where([data-sonner-toast][data-removed="true"][data-front="false"]):before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount-y, 0px)) translate(var(--swipe-amount-x, 0px));transition:none}[data-sonner-toast][data-swiped=true]{user-select:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation-duration:.2s;animation-timing-function:ease-out;animation-fill-mode:forwards}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=left]{animation-name:swipe-out-left}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=right]{animation-name:swipe-out-right}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=up]{animation-name:swipe-out-up}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=down]{animation-name:swipe-out-down}@keyframes swipe-out-left{0%{transform:var(--y) translate(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translate(calc(var(--swipe-amount-x) - 100%));opacity:0}}@keyframes swipe-out-right{0%{transform:var(--y) translate(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translate(calc(var(--swipe-amount-x) + 100%));opacity:0}}@keyframes swipe-out-up{0%{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) - 100%));opacity:0}}@keyframes swipe-out-down{0%{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) + 100%));opacity:0}}@media (max-width: 600px){[data-sonner-toaster]{position:fixed;right:var(--mobile-offset-right);left:var(--mobile-offset-left);width:100%}[data-sonner-toaster][dir=rtl]{left:calc(var(--mobile-offset-left) * -1)}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset-left) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset-left)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--mobile-offset-bottom)}[data-sonner-toaster][data-y-position=top]{top:var(--mobile-offset-top)}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset-left);right:var(--mobile-offset-right);transform:none}}[data-sonner-toaster][data-theme=light]{--normal-bg: #fff;--normal-border: var(--gray4);--normal-text: var(--gray12);--success-bg: hsl(143, 85%, 96%);--success-border: hsl(145, 92%, 91%);--success-text: hsl(140, 100%, 27%);--info-bg: hsl(208, 100%, 97%);--info-border: hsl(221, 91%, 91%);--info-text: hsl(210, 92%, 45%);--warning-bg: hsl(49, 100%, 97%);--warning-border: hsl(49, 91%, 91%);--warning-text: hsl(31, 92%, 45%);--error-bg: hsl(359, 100%, 97%);--error-border: hsl(359, 100%, 94%);--error-text: hsl(360, 100%, 45%)}[data-sonner-toaster][data-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg: #000;--normal-border: hsl(0, 0%, 20%);--normal-text: var(--gray1)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg: #fff;--normal-border: var(--gray3);--normal-text: var(--gray12)}[data-sonner-toaster][data-theme=dark]{--normal-bg: #000;--normal-bg-hover: hsl(0, 0%, 12%);--normal-border: hsl(0, 0%, 20%);--normal-border-hover: hsl(0, 0%, 25%);--normal-text: var(--gray1);--success-bg: hsl(150, 100%, 6%);--success-border: hsl(147, 100%, 12%);--success-text: hsl(150, 86%, 65%);--info-bg: hsl(215, 100%, 6%);--info-border: hsl(223, 100%, 12%);--info-text: hsl(216, 87%, 65%);--warning-bg: hsl(64, 100%, 6%);--warning-border: hsl(60, 100%, 12%);--warning-text: hsl(46, 87%, 65%);--error-bg: hsl(358, 76%, 10%);--error-border: hsl(357, 89%, 16%);--error-text: hsl(358, 100%, 81%)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast] [data-close-button]{background:var(--normal-bg);border-color:var(--normal-border);color:var(--normal-text)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast] [data-close-button]:hover{background:var(--normal-bg-hover);border-color:var(--normal-border-hover)}[data-rich-colors=true][data-sonner-toast][data-type=success],[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info],[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning],[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error],[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size: 16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:nth-child(1){animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}to{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}to{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}to{opacity:.15}}@media (prefers-reduced-motion){[data-sonner-toast],[data-sonner-toast]>*,.sonner-loading-bar{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}
`); function Qo(e) { return e.label !== void 0 } var aT = 3, lT = "32px", cT = "16px", Fp = 4e3, uT = 356, dT = 14, fT = 20, hT = 200; function Nt(...e) { return e.filter(Boolean).join(" ") } function pT(e) { let [t, n] = e.split("-"), r = []; return t && r.push(t), n && r.push(n), r } var mT = e => { var t, n, r, s, i, o, a, l, c, d, f; let { invert: h, toast: p, unstyled: w, interacting: y, setHeights: b, visibleToasts: g, heights: m, index: v, toasts: S, expanded: C, removeToast: k, defaultRichColors: T, closeButton: E, style: A, cancelButtonStyle: R, actionButtonStyle: _, className: I = "", descriptionClassName: G = "", duration: L, position: Q, gap: $, loadingIcon: V, expandByDefault: N, classNames: j, icons: O, closeButtonAriaLabel: U = "Close toast", pauseWhenPageIsHidden: z } = e, [q, Z] = D.useState(null), [we, Oe] = D.useState(null), [te, Yr] = D.useState(!1), [Sn, hr] = D.useState(!1), [Cn, Gr] = D.useState(!1), [kn, Eo] = D.useState(!1), [Il, No] = D.useState(!1), [Fl, ri] = D.useState(0), [Qr, uh] = D.useState(0), si = D.useRef(p.duration || L || Fp), dh = D.useRef(null), pr = D.useRef(null), f1 = v === 0, h1 = v + 1 <= g, ft = p.type, qr = p.dismissible !== !1, p1 = p.className || "", m1 = p.descriptionClassName || "", Po = D.useMemo(() => m.findIndex(W => W.toastId === p.id) || 0, [m, p.id]), g1 = D.useMemo(() => { var W; return (W = p.closeButton) != null ? W : E }, [p.closeButton, E]), fh = D.useMemo(() => p.duration || L || Fp, [p.duration, L]), Vl = D.useRef(0), Xr = D.useRef(0), hh = D.useRef(0), Zr = D.useRef(null), [y1, v1] = Q.split("-"), ph = D.useMemo(() => m.reduce((W, re, le) => le >= Po ? W : W + re.height, 0), [m, Po]), mh = Jk(), x1 = p.invert || h, _l = ft === "loading"; Xr.current = D.useMemo(() => Po * $ + ph, [Po, ph]), D.useEffect(() => { si.current = fh }, [fh]), D.useEffect(() => { Yr(!0) }, []), D.useEffect(() => { let W = pr.current; if (W) { let re = W.getBoundingClientRect().height; return uh(re), b(le => [{ toastId: p.id, height: re, position: p.position }, ...le]), () => b(le => le.filter(Ct => Ct.toastId !== p.id)) } }, [b, p.id]), D.useLayoutEffect(() => { if (!te) return; let W = pr.current, re = W.style.height; W.style.height = "auto"; let le = W.getBoundingClientRect().height; W.style.height = re, uh(le), b(Ct => Ct.find(kt => kt.toastId === p.id) ? Ct.map(kt => kt.toastId === p.id ? { ...kt, height: le } : kt) : [{ toastId: p.id, height: le, position: p.position }, ...Ct]) }, [te, p.title, p.description, b, p.id]); let Tn = D.useCallback(() => { hr(!0), ri(Xr.current), b(W => W.filter(re => re.toastId !== p.id)), setTimeout(() => { k(p) }, hT) }, [p, k, b, Xr]); D.useEffect(() => { if (p.promise && ft === "loading" || p.duration === 1 / 0 || p.type === "loading") return; let W; return C || y || z && mh ? (() => { if (hh.current < Vl.current) { let re = new Date().getTime() - Vl.current; si.current = si.current - re } hh.current = new Date().getTime() })() : si.current !== 1 / 0 && (Vl.current = new Date().getTime(), W = setTimeout(() => { var re; (re = p.onAutoClose) == null || re.call(p, p), Tn() }, si.current)), () => clearTimeout(W) }, [C, y, p, ft, z, mh, Tn]), D.useEffect(() => { p.delete && Tn() }, [Tn, p.delete]); function w1() { var W, re, le; return O != null && O.loading ? D.createElement("div", { className: Nt(j == null ? void 0 : j.loader, (W = p == null ? void 0 : p.classNames) == null ? void 0 : W.loader, "sonner-loader"), "data-visible": ft === "loading" }, O.loading) : V ? D.createElement("div", { className: Nt(j == null ? void 0 : j.loader, (re = p == null ? void 0 : p.classNames) == null ? void 0 : re.loader, "sonner-loader"), "data-visible": ft === "loading" }, V) : D.createElement(Yk, { className: Nt(j == null ? void 0 : j.loader, (le = p == null ? void 0 : p.classNames) == null ? void 0 : le.loader), visible: ft === "loading" }) } return D.createElement("li", { tabIndex: 0, ref: pr, className: Nt(I, p1, j == null ? void 0 : j.toast, (t = p == null ? void 0 : p.classNames) == null ? void 0 : t.toast, j == null ? void 0 : j.default, j == null ? void 0 : j[ft], (n = p == null ? void 0 : p.classNames) == null ? void 0 : n[ft]), "data-sonner-toast": "", "data-rich-colors": (r = p.richColors) != null ? r : T, "data-styled": !(p.jsx || p.unstyled || w), "data-mounted": te, "data-promise": !!p.promise, "data-swiped": Il, "data-removed": Sn, "data-visible": h1, "data-y-position": y1, "data-x-position": v1, "data-index": v, "data-front": f1, "data-swiping": Cn, "data-dismissible": qr, "data-type": ft, "data-invert": x1, "data-swipe-out": kn, "data-swipe-direction": we, "data-expanded": !!(C || N && te), style: { "--index": v, "--toasts-before": v, "--z-index": S.length - v, "--offset": `${Sn ? Fl : Xr.current}px`, "--initial-height": N ? "auto" : `${Qr}px`, ...A, ...p.style }, onDragEnd: () => { Gr(!1), Z(null), Zr.current = null }, onPointerDown: W => { _l || !qr || (dh.current = new Date, ri(Xr.current), W.target.setPointerCapture(W.pointerId), W.target.tagName !== "BUTTON" && (Gr(!0), Zr.current = { x: W.clientX, y: W.clientY })) }, onPointerUp: () => { var W, re, le, Ct; if (kn || !qr) return; Zr.current = null; let kt = Number(((W = pr.current) == null ? void 0 : W.style.getPropertyValue("--swipe-amount-x").replace("px", "")) || 0), En = Number(((re = pr.current) == null ? void 0 : re.style.getPropertyValue("--swipe-amount-y").replace("px", "")) || 0), mr = new Date().getTime() - ((le = dh.current) == null ? void 0 : le.getTime()), Tt = q === "x" ? kt : En, Nn = Math.abs(Tt) / mr; if (Math.abs(Tt) >= fT || Nn > .11) { ri(Xr.current), (Ct = p.onDismiss) == null || Ct.call(p, p), Oe(q === "x" ? kt > 0 ? "right" : "left" : En > 0 ? "down" : "up"), Tn(), Eo(!0), No(!1); return } Gr(!1), Z(null) }, onPointerMove: W => { var re, le, Ct, kt; if (!Zr.current || !qr || ((re = window.getSelection()) == null ? void 0 : re.toString().length) > 0) return; let En = W.clientY - Zr.current.y, mr = W.clientX - Zr.current.x, Tt = (le = e.swipeDirections) != null ? le : pT(Q); !q && (Math.abs(mr) > 1 || Math.abs(En) > 1) && Z(Math.abs(mr) > Math.abs(En) ? "x" : "y"); let Nn = { x: 0, y: 0 }; q === "y" ? (Tt.includes("top") || Tt.includes("bottom")) && (Tt.includes("top") && En < 0 || Tt.includes("bottom") && En > 0) && (Nn.y = En) : q === "x" && (Tt.includes("left") || Tt.includes("right")) && (Tt.includes("left") && mr < 0 || Tt.includes("right") && mr > 0) && (Nn.x = mr), (Math.abs(Nn.x) > 0 || Math.abs(Nn.y) > 0) && No(!0), (Ct = pr.current) == null || Ct.style.setProperty("--swipe-amount-x", `${Nn.x}px`), (kt = pr.current) == null || kt.style.setProperty("--swipe-amount-y", `${Nn.y}px`) } }, g1 && !p.jsx ? D.createElement("button", { "aria-label": U, "data-disabled": _l, "data-close-button": !0, onClick: _l || !qr ? () => { } : () => { var W; Tn(), (W = p.onDismiss) == null || W.call(p, p) }, className: Nt(j == null ? void 0 : j.closeButton, (s = p == null ? void 0 : p.classNames) == null ? void 0 : s.closeButton) }, (i = O == null ? void 0 : O.close) != null ? i : Zk) : null, p.jsx || x.isValidElement(p.title) ? p.jsx ? p.jsx : typeof p.title == "function" ? p.title() : p.title : D.createElement(D.Fragment, null, ft || p.icon || p.promise ? D.createElement("div", { "data-icon": "", className: Nt(j == null ? void 0 : j.icon, (o = p == null ? void 0 : p.classNames) == null ? void 0 : o.icon) }, p.promise || p.type === "loading" && !p.icon ? p.icon || w1() : null, p.type !== "loading" ? p.icon || (O == null ? void 0 : O[ft]) || Hk(ft) : null) : null, D.createElement("div", { "data-content": "", className: Nt(j == null ? void 0 : j.content, (a = p == null ? void 0 : p.classNames) == null ? void 0 : a.content) }, D.createElement("div", { "data-title": "", className: Nt(j == null ? void 0 : j.title, (l = p == null ? void 0 : p.classNames) == null ? void 0 : l.title) }, typeof p.title == "function" ? p.title() : p.title), p.description ? D.createElement("div", { "data-description": "", className: Nt(G, m1, j == null ? void 0 : j.description, (c = p == null ? void 0 : p.classNames) == null ? void 0 : c.description) }, typeof p.description == "function" ? p.description() : p.description) : null), x.isValidElement(p.cancel) ? p.cancel : p.cancel && Qo(p.cancel) ? D.createElement("button", { "data-button": !0, "data-cancel": !0, style: p.cancelButtonStyle || R, onClick: W => { var re, le; Qo(p.cancel) && qr && ((le = (re = p.cancel).onClick) == null || le.call(re, W), Tn()) }, className: Nt(j == null ? void 0 : j.cancelButton, (d = p == null ? void 0 : p.classNames) == null ? void 0 : d.cancelButton) }, p.cancel.label) : null, x.isValidElement(p.action) ? p.action : p.action && Qo(p.action) ? D.createElement("button", { "data-button": !0, "data-action": !0, style: p.actionButtonStyle || _, onClick: W => { var re, le; Qo(p.action) && ((le = (re = p.action).onClick) == null || le.call(re, W), !W.defaultPrevented && Tn()) }, className: Nt(j == null ? void 0 : j.actionButton, (f = p == null ? void 0 : p.classNames) == null ? void 0 : f.actionButton) }, p.action.label) : null)) }; function Vp() { if (typeof window > "u" || typeof document > "u") return "ltr"; let e = document.documentElement.getAttribute("dir"); return e === "auto" || !e ? window.getComputedStyle(document.documentElement).direction : e } function gT(e, t) { let n = {}; return [e, t].forEach((r, s) => { let i = s === 1, o = i ? "--mobile-offset" : "--offset", a = i ? cT : lT; function l(c) { ["top", "right", "bottom", "left"].forEach(d => { n[`${o}-${d}`] = typeof c == "number" ? `${c}px` : c }) } typeof r == "number" || typeof r == "string" ? l(r) : typeof r == "object" ? ["top", "right", "bottom", "left"].forEach(c => { r[c] === void 0 ? n[`${o}-${c}`] = a : n[`${o}-${c}`] = typeof r[c] == "number" ? `${r[c]}px` : r[c] }) : l(a) }), n } var yT = x.forwardRef(function (e, t) { let { invert: n, position: r = "bottom-right", hotkey: s = ["altKey", "KeyT"], expand: i, closeButton: o, className: a, offset: l, mobileOffset: c, theme: d = "light", richColors: f, duration: h, style: p, visibleToasts: w = aT, toastOptions: y, dir: b = Vp(), gap: g = dT, loadingIcon: m, icons: v, containerAriaLabel: S = "Notifications", pauseWhenPageIsHidden: C } = e, [k, T] = D.useState([]), E = D.useMemo(() => Array.from(new Set([r].concat(k.filter(z => z.position).map(z => z.position)))), [k, r]), [A, R] = D.useState([]), [_, I] = D.useState(!1), [G, L] = D.useState(!1), [Q, $] = D.useState(d !== "system" ? d : typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"), V = D.useRef(null), N = s.join("+").replace(/Key/g, "").replace(/Digit/g, ""), j = D.useRef(null), O = D.useRef(!1), U = D.useCallback(z => { T(q => { var Z; return (Z = q.find(we => we.id === z.id)) != null && Z.delete || qe.dismiss(z.id), q.filter(({ id: we }) => we !== z.id) }) }, []); return D.useEffect(() => qe.subscribe(z => { if (z.dismiss) { T(q => q.map(Z => Z.id === z.id ? { ...Z, delete: !0 } : Z)); return } setTimeout(() => { qv.flushSync(() => { T(q => { let Z = q.findIndex(we => we.id === z.id); return Z !== -1 ? [...q.slice(0, Z), { ...q[Z], ...z }, ...q.slice(Z + 1)] : [z, ...q] }) }) }) }), []), D.useEffect(() => { if (d !== "system") { $(d); return } if (d === "system" && (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? $("dark") : $("light")), typeof window > "u") return; let z = window.matchMedia("(prefers-color-scheme: dark)"); try { z.addEventListener("change", ({ matches: q }) => { $(q ? "dark" : "light") }) } catch { z.addListener(({ matches: Z }) => { try { $(Z ? "dark" : "light") } catch (we) { console.error(we) } }) } }, [d]), D.useEffect(() => { k.length <= 1 && I(!1) }, [k]), D.useEffect(() => { let z = q => { var Z, we; s.every(Oe => q[Oe] || q.code === Oe) && (I(!0), (Z = V.current) == null || Z.focus()), q.code === "Escape" && (document.activeElement === V.current || (we = V.current) != null && we.contains(document.activeElement)) && I(!1) }; return document.addEventListener("keydown", z), () => document.removeEventListener("keydown", z) }, [s]), D.useEffect(() => { if (V.current) return () => { j.current && (j.current.focus({ preventScroll: !0 }), j.current = null, O.current = !1) } }, [V.current]), D.createElement("section", { ref: t, "aria-label": `${S} ${N}`, tabIndex: -1, "aria-live": "polite", "aria-relevant": "additions text", "aria-atomic": "false", suppressHydrationWarning: !0 }, E.map((z, q) => { var Z; let [we, Oe] = z.split("-"); return k.length ? D.createElement("ol", { key: z, dir: b === "auto" ? Vp() : b, tabIndex: -1, ref: V, className: a, "data-sonner-toaster": !0, "data-theme": Q, "data-y-position": we, "data-lifted": _ && k.length > 1 && !i, "data-x-position": Oe, style: { "--front-toast-height": `${((Z = A[0]) == null ? void 0 : Z.height) || 0}px`, "--width": `${uT}px`, "--gap": `${g}px`, ...p, ...gT(l, c) }, onBlur: te => { O.current && !te.currentTarget.contains(te.relatedTarget) && (O.current = !1, j.current && (j.current.focus({ preventScroll: !0 }), j.current = null)) }, onFocus: te => { te.target instanceof HTMLElement && te.target.dataset.dismissible === "false" || O.current || (O.current = !0, j.current = te.relatedTarget) }, onMouseEnter: () => I(!0), onMouseMove: () => I(!0), onMouseLeave: () => { G || I(!1) }, onDragEnd: () => I(!1), onPointerDown: te => { te.target instanceof HTMLElement && te.target.dataset.dismissible === "false" || L(!0) }, onPointerUp: () => L(!1) }, k.filter(te => !te.position && q === 0 || te.position === z).map((te, Yr) => { var Sn, hr; return D.createElement(mT, { key: te.id, icons: v, index: Yr, toast: te, defaultRichColors: f, duration: (Sn = y == null ? void 0 : y.duration) != null ? Sn : h, className: y == null ? void 0 : y.className, descriptionClassName: y == null ? void 0 : y.descriptionClassName, invert: n, visibleToasts: w, closeButton: (hr = y == null ? void 0 : y.closeButton) != null ? hr : o, interacting: G, position: z, style: y == null ? void 0 : y.style, unstyled: y == null ? void 0 : y.unstyled, classNames: y == null ? void 0 : y.classNames, cancelButtonStyle: y == null ? void 0 : y.cancelButtonStyle, actionButtonStyle: y == null ? void 0 : y.actionButtonStyle, removeToast: U, toasts: k.filter(Cn => Cn.position == te.position), heights: A.filter(Cn => Cn.position == te.position), setHeights: R, expandByDefault: i, gap: g, loadingIcon: m, expanded: _, pauseWhenPageIsHidden: C, swipeDirections: e.swipeDirections }) })) : null })) }); const vT = ({ ...e }) => { const { theme: t = "system" } = Wk(); return u.jsx(yT, { theme: t, className: "toaster group", toastOptions: { classNames: { toast: "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg", description: "group-[.toast]:text-muted-foreground", actionButton: "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground", cancelButton: "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground" } }, ...e }) }, xT = ["top", "right", "bottom", "left"], sr = Math.min, it = Math.max, Ha = Math.round, qo = Math.floor, Zt = e => ({ x: e, y: e }), wT = { left: "right", right: "left", bottom: "top", top: "bottom" }, bT = { start: "end", end: "start" }; function Fu(e, t, n) { return it(e, sr(t, n)) } function yn(e, t) { return typeof e == "function" ? e(t) : e } function vn(e) { return e.split("-")[0] } function qs(e) { return e.split("-")[1] } function vf(e) { return e === "x" ? "y" : "x" } function xf(e) { return e === "y" ? "height" : "width" } const ST = new Set(["top", "bottom"]); function Gt(e) { return ST.has(vn(e)) ? "y" : "x" } function wf(e) { return vf(Gt(e)) } function CT(e, t, n) { n === void 0 && (n = !1); const r = qs(e), s = wf(e), i = xf(s); let o = s === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top"; return t.reference[i] > t.floating[i] && (o = Ka(o)), [o, Ka(o)] } function kT(e) { const t = Ka(e); return [Vu(e), t, Vu(t)] } function Vu(e) { return e.replace(/start|end/g, t => bT[t]) } const _p = ["left", "right"], zp = ["right", "left"], TT = ["top", "bottom"], ET = ["bottom", "top"]; function NT(e, t, n) { switch (e) { case "top": case "bottom": return n ? t ? zp : _p : t ? _p : zp; case "left": case "right": return t ? TT : ET; default: return [] } } function PT(e, t, n, r) { const s = qs(e); let i = NT(vn(e), n === "start", r); return s && (i = i.map(o => o + "-" + s), t && (i = i.concat(i.map(Vu)))), i } function Ka(e) { return e.replace(/left|right|bottom|top/g, t => wT[t]) } function jT(e) { return { top: 0, right: 0, bottom: 0, left: 0, ...e } } function V0(e) { return typeof e != "number" ? jT(e) : { top: e, right: e, bottom: e, left: e } } function Ya(e) { const { x: t, y: n, width: r, height: s } = e; return { width: r, height: s, top: n, left: t, right: t + r, bottom: n + s, x: t, y: n } } function Bp(e, t, n) { let { reference: r, floating: s } = e; const i = Gt(t), o = wf(t), a = xf(o), l = vn(t), c = i === "y", d = r.x + r.width / 2 - s.width / 2, f = r.y + r.height / 2 - s.height / 2, h = r[a] / 2 - s[a] / 2; let p; switch (l) { case "top": p = { x: d, y: r.y - s.height }; break; case "bottom": p = { x: d, y: r.y + r.height }; break; case "right": p = { x: r.x + r.width, y: f }; break; case "left": p = { x: r.x - s.width, y: f }; break; default: p = { x: r.x, y: r.y } }switch (qs(t)) { case "start": p[o] -= h * (n && c ? -1 : 1); break; case "end": p[o] += h * (n && c ? -1 : 1); break }return p } const RT = async (e, t, n) => { const { placement: r = "bottom", strategy: s = "absolute", middleware: i = [], platform: o } = n, a = i.filter(Boolean), l = await (o.isRTL == null ? void 0 : o.isRTL(t)); let c = await o.getElementRects({ reference: e, floating: t, strategy: s }), { x: d, y: f } = Bp(c, r, l), h = r, p = {}, w = 0; for (let y = 0; y < a.length; y++) { const { name: b, fn: g } = a[y], { x: m, y: v, data: S, reset: C } = await g({ x: d, y: f, initialPlacement: r, placement: h, strategy: s, middlewareData: p, rects: c, platform: o, elements: { reference: e, floating: t } }); d = m ?? d, f = v ?? f, p = { ...p, [b]: { ...p[b], ...S } }, C && w <= 50 && (w++, typeof C == "object" && (C.placement && (h = C.placement), C.rects && (c = C.rects === !0 ? await o.getElementRects({ reference: e, floating: t, strategy: s }) : C.rects), { x: d, y: f } = Bp(c, h, l)), y = -1) } return { x: d, y: f, placement: h, strategy: s, middlewareData: p } }; async function Ji(e, t) { var n; t === void 0 && (t = {}); const { x: r, y: s, platform: i, rects: o, elements: a, strategy: l } = e, { boundary: c = "clippingAncestors", rootBoundary: d = "viewport", elementContext: f = "floating", altBoundary: h = !1, padding: p = 0 } = yn(t, e), w = V0(p), b = a[h ? f === "floating" ? "reference" : "floating" : f], g = Ya(await i.getClippingRect({ element: (n = await (i.isElement == null ? void 0 : i.isElement(b))) == null || n ? b : b.contextElement || await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(a.floating)), boundary: c, rootBoundary: d, strategy: l })), m = f === "floating" ? { x: r, y: s, width: o.floating.width, height: o.floating.height } : o.reference, v = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(a.floating)), S = await (i.isElement == null ? void 0 : i.isElement(v)) ? await (i.getScale == null ? void 0 : i.getScale(v)) || { x: 1, y: 1 } : { x: 1, y: 1 }, C = Ya(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({ elements: a, rect: m, offsetParent: v, strategy: l }) : m); return { top: (g.top - C.top + w.top) / S.y, bottom: (C.bottom - g.bottom + w.bottom) / S.y, left: (g.left - C.left + w.left) / S.x, right: (C.right - g.right + w.right) / S.x } } const AT = e => ({ name: "arrow", options: e, async fn(t) { const { x: n, y: r, placement: s, rects: i, platform: o, elements: a, middlewareData: l } = t, { element: c, padding: d = 0 } = yn(e, t) || {}; if (c == null) return {}; const f = V0(d), h = { x: n, y: r }, p = wf(s), w = xf(p), y = await o.getDimensions(c), b = p === "y", g = b ? "top" : "left", m = b ? "bottom" : "right", v = b ? "clientHeight" : "clientWidth", S = i.reference[w] + i.reference[p] - h[p] - i.floating[w], C = h[p] - i.reference[p], k = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(c)); let T = k ? k[v] : 0; (!T || !await (o.isElement == null ? void 0 : o.isElement(k))) && (T = a.floating[v] || i.floating[w]); const E = S / 2 - C / 2, A = T / 2 - y[w] / 2 - 1, R = sr(f[g], A), _ = sr(f[m], A), I = R, G = T - y[w] - _, L = T / 2 - y[w] / 2 + E, Q = Fu(I, L, G), $ = !l.arrow && qs(s) != null && L !== Q && i.reference[w] / 2 - (L < I ? R : _) - y[w] / 2 < 0, V = $ ? L < I ? L - I : L - G : 0; return { [p]: h[p] + V, data: { [p]: Q, centerOffset: L - Q - V, ...$ && { alignmentOffset: V } }, reset: $ } } }), MT = function (e) { return e === void 0 && (e = {}), { name: "flip", options: e, async fn(t) { var n, r; const { placement: s, middlewareData: i, rects: o, initialPlacement: a, platform: l, elements: c } = t, { mainAxis: d = !0, crossAxis: f = !0, fallbackPlacements: h, fallbackStrategy: p = "bestFit", fallbackAxisSideDirection: w = "none", flipAlignment: y = !0, ...b } = yn(e, t); if ((n = i.arrow) != null && n.alignmentOffset) return {}; const g = vn(s), m = Gt(a), v = vn(a) === a, S = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)), C = h || (v || !y ? [Ka(a)] : kT(a)), k = w !== "none"; !h && k && C.push(...PT(a, y, w, S)); const T = [a, ...C], E = await Ji(t, b), A = []; let R = ((r = i.flip) == null ? void 0 : r.overflows) || []; if (d && A.push(E[g]), f) { const L = CT(s, o, S); A.push(E[L[0]], E[L[1]]) } if (R = [...R, { placement: s, overflows: A }], !A.every(L => L <= 0)) { var _, I; const L = (((_ = i.flip) == null ? void 0 : _.index) || 0) + 1, Q = T[L]; if (Q && (!(f === "alignment" ? m !== Gt(Q) : !1) || R.every(N => N.overflows[0] > 0 && Gt(N.placement) === m))) return { data: { index: L, overflows: R }, reset: { placement: Q } }; let $ = (I = R.filter(V => V.overflows[0] <= 0).sort((V, N) => V.overflows[1] - N.overflows[1])[0]) == null ? void 0 : I.placement; if (!$) switch (p) { case "bestFit": { var G; const V = (G = R.filter(N => { if (k) { const j = Gt(N.placement); return j === m || j === "y" } return !0 }).map(N => [N.placement, N.overflows.filter(j => j > 0).reduce((j, O) => j + O, 0)]).sort((N, j) => N[1] - j[1])[0]) == null ? void 0 : G[0]; V && ($ = V); break } case "initialPlacement": $ = a; break }if (s !== $) return { reset: { placement: $ } } } return {} } } }; function $p(e, t) { return { top: e.top - t.height, right: e.right - t.width, bottom: e.bottom - t.height, left: e.left - t.width } } function Up(e) { return xT.some(t => e[t] >= 0) } const DT = function (e) { return e === void 0 && (e = {}), { name: "hide", options: e, async fn(t) { const { rects: n } = t, { strategy: r = "referenceHidden", ...s } = yn(e, t); switch (r) { case "referenceHidden": { const i = await Ji(t, { ...s, elementContext: "reference" }), o = $p(i, n.reference); return { data: { referenceHiddenOffsets: o, referenceHidden: Up(o) } } } case "escaped": { const i = await Ji(t, { ...s, altBoundary: !0 }), o = $p(i, n.floating); return { data: { escapedOffsets: o, escaped: Up(o) } } } default: return {} } } } }, _0 = new Set(["left", "top"]); async function LT(e, t) { const { placement: n, platform: r, elements: s } = e, i = await (r.isRTL == null ? void 0 : r.isRTL(s.floating)), o = vn(n), a = qs(n), l = Gt(n) === "y", c = _0.has(o) ? -1 : 1, d = i && l ? -1 : 1, f = yn(t, e); let { mainAxis: h, crossAxis: p, alignmentAxis: w } = typeof f == "number" ? { mainAxis: f, crossAxis: 0, alignmentAxis: null } : { mainAxis: f.mainAxis || 0, crossAxis: f.crossAxis || 0, alignmentAxis: f.alignmentAxis }; return a && typeof w == "number" && (p = a === "end" ? w * -1 : w), l ? { x: p * d, y: h * c } : { x: h * c, y: p * d } } const OT = function (e) { return e === void 0 && (e = 0), { name: "offset", options: e, async fn(t) { var n, r; const { x: s, y: i, placement: o, middlewareData: a } = t, l = await LT(t, e); return o === ((n = a.offset) == null ? void 0 : n.placement) && (r = a.arrow) != null && r.alignmentOffset ? {} : { x: s + l.x, y: i + l.y, data: { ...l, placement: o } } } } }, IT = function (e) { return e === void 0 && (e = {}), { name: "shift", options: e, async fn(t) { const { x: n, y: r, placement: s } = t, { mainAxis: i = !0, crossAxis: o = !1, limiter: a = { fn: b => { let { x: g, y: m } = b; return { x: g, y: m } } }, ...l } = yn(e, t), c = { x: n, y: r }, d = await Ji(t, l), f = Gt(vn(s)), h = vf(f); let p = c[h], w = c[f]; if (i) { const b = h === "y" ? "top" : "left", g = h === "y" ? "bottom" : "right", m = p + d[b], v = p - d[g]; p = Fu(m, p, v) } if (o) { const b = f === "y" ? "top" : "left", g = f === "y" ? "bottom" : "right", m = w + d[b], v = w - d[g]; w = Fu(m, w, v) } const y = a.fn({ ...t, [h]: p, [f]: w }); return { ...y, data: { x: y.x - n, y: y.y - r, enabled: { [h]: i, [f]: o } } } } } }, FT = function (e) { return e === void 0 && (e = {}), { options: e, fn(t) { const { x: n, y: r, placement: s, rects: i, middlewareData: o } = t, { offset: a = 0, mainAxis: l = !0, crossAxis: c = !0 } = yn(e, t), d = { x: n, y: r }, f = Gt(s), h = vf(f); let p = d[h], w = d[f]; const y = yn(a, t), b = typeof y == "number" ? { mainAxis: y, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...y }; if (l) { const v = h === "y" ? "height" : "width", S = i.reference[h] - i.floating[v] + b.mainAxis, C = i.reference[h] + i.reference[v] - b.mainAxis; p < S ? p = S : p > C && (p = C) } if (c) { var g, m; const v = h === "y" ? "width" : "height", S = _0.has(vn(s)), C = i.reference[f] - i.floating[v] + (S && ((g = o.offset) == null ? void 0 : g[f]) || 0) + (S ? 0 : b.crossAxis), k = i.reference[f] + i.reference[v] + (S ? 0 : ((m = o.offset) == null ? void 0 : m[f]) || 0) - (S ? b.crossAxis : 0); w < C ? w = C : w > k && (w = k) } return { [h]: p, [f]: w } } } }, VT = function (e) { return e === void 0 && (e = {}), { name: "size", options: e, async fn(t) { var n, r; const { placement: s, rects: i, platform: o, elements: a } = t, { apply: l = () => { }, ...c } = yn(e, t), d = await Ji(t, c), f = vn(s), h = qs(s), p = Gt(s) === "y", { width: w, height: y } = i.floating; let b, g; f === "top" || f === "bottom" ? (b = f, g = h === (await (o.isRTL == null ? void 0 : o.isRTL(a.floating)) ? "start" : "end") ? "left" : "right") : (g = f, b = h === "end" ? "top" : "bottom"); const m = y - d.top - d.bottom, v = w - d.left - d.right, S = sr(y - d[b], m), C = sr(w - d[g], v), k = !t.middlewareData.shift; let T = S, E = C; if ((n = t.middlewareData.shift) != null && n.enabled.x && (E = v), (r = t.middlewareData.shift) != null && r.enabled.y && (T = m), k && !h) { const R = it(d.left, 0), _ = it(d.right, 0), I = it(d.top, 0), G = it(d.bottom, 0); p ? E = w - 2 * (R !== 0 || _ !== 0 ? R + _ : it(d.left, d.right)) : T = y - 2 * (I !== 0 || G !== 0 ? I + G : it(d.top, d.bottom)) } await l({ ...t, availableWidth: E, availableHeight: T }); const A = await o.getDimensions(a.floating); return w !== A.width || y !== A.height ? { reset: { rects: !0 } } : {} } } }; function kl() { return typeof window < "u" } function Xs(e) { return z0(e) ? (e.nodeName || "").toLowerCase() : "#document" } function lt(e) { var t; return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window } function nn(e) { var t; return (t = (z0(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement } function z0(e) { return kl() ? e instanceof Node || e instanceof lt(e).Node : !1 } function zt(e) { return kl() ? e instanceof Element || e instanceof lt(e).Element : !1 } function tn(e) { return kl() ? e instanceof HTMLElement || e instanceof lt(e).HTMLElement : !1 } function Wp(e) { return !kl() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof lt(e).ShadowRoot } const _T = new Set(["inline", "contents"]); function wo(e) { const { overflow: t, overflowX: n, overflowY: r, display: s } = Bt(e); return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !_T.has(s) } const zT = new Set(["table", "td", "th"]); function BT(e) { return zT.has(Xs(e)) } const $T = [":popover-open", ":modal"]; function Tl(e) { return $T.some(t => { try { return e.matches(t) } catch { return !1 } }) } const UT = ["transform", "translate", "scale", "rotate", "perspective"], WT = ["transform", "translate", "scale", "rotate", "perspective", "filter"], HT = ["paint", "layout", "strict", "content"]; function bf(e) { const t = Sf(), n = zt(e) ? Bt(e) : e; return UT.some(r => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || WT.some(r => (n.willChange || "").includes(r)) || HT.some(r => (n.contain || "").includes(r)) } function KT(e) { let t = ir(e); for (; tn(t) && !$s(t);) { if (bf(t)) return t; if (Tl(t)) return null; t = ir(t) } return null } function Sf() { return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none") } const YT = new Set(["html", "body", "#document"]); function $s(e) { return YT.has(Xs(e)) } function Bt(e) { return lt(e).getComputedStyle(e) } function El(e) { return zt(e) ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } : { scrollLeft: e.scrollX, scrollTop: e.scrollY } } function ir(e) { if (Xs(e) === "html") return e; const t = e.assignedSlot || e.parentNode || Wp(e) && e.host || nn(e); return Wp(t) ? t.host : t } function B0(e) { const t = ir(e); return $s(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : tn(t) && wo(t) ? t : B0(t) } function eo(e, t, n) { var r; t === void 0 && (t = []), n === void 0 && (n = !0); const s = B0(e), i = s === ((r = e.ownerDocument) == null ? void 0 : r.body), o = lt(s); if (i) { const a = _u(o); return t.concat(o, o.visualViewport || [], wo(s) ? s : [], a && n ? eo(a) : []) } return t.concat(s, eo(s, [], n)) } function _u(e) { return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null } function $0(e) { const t = Bt(e); let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0; const s = tn(e), i = s ? e.offsetWidth : n, o = s ? e.offsetHeight : r, a = Ha(n) !== i || Ha(r) !== o; return a && (n = i, r = o), { width: n, height: r, $: a } } function Cf(e) { return zt(e) ? e : e.contextElement } function Ts(e) { const t = Cf(e); if (!tn(t)) return Zt(1); const n = t.getBoundingClientRect(), { width: r, height: s, $: i } = $0(t); let o = (i ? Ha(n.width) : n.width) / r, a = (i ? Ha(n.height) : n.height) / s; return (!o || !Number.isFinite(o)) && (o = 1), (!a || !Number.isFinite(a)) && (a = 1), { x: o, y: a } } const GT = Zt(0); function U0(e) { const t = lt(e); return !Sf() || !t.visualViewport ? GT : { x: t.visualViewport.offsetLeft, y: t.visualViewport.offsetTop } } function QT(e, t, n) { return t === void 0 && (t = !1), !n || t && n !== lt(e) ? !1 : t } function Br(e, t, n, r) { t === void 0 && (t = !1), n === void 0 && (n = !1); const s = e.getBoundingClientRect(), i = Cf(e); let o = Zt(1); t && (r ? zt(r) && (o = Ts(r)) : o = Ts(e)); const a = QT(i, n, r) ? U0(i) : Zt(0); let l = (s.left + a.x) / o.x, c = (s.top + a.y) / o.y, d = s.width / o.x, f = s.height / o.y; if (i) { const h = lt(i), p = r && zt(r) ? lt(r) : r; let w = h, y = _u(w); for (; y && r && p !== w;) { const b = Ts(y), g = y.getBoundingClientRect(), m = Bt(y), v = g.left + (y.clientLeft + parseFloat(m.paddingLeft)) * b.x, S = g.top + (y.clientTop + parseFloat(m.paddingTop)) * b.y; l *= b.x, c *= b.y, d *= b.x, f *= b.y, l += v, c += S, w = lt(y), y = _u(w) } } return Ya({ width: d, height: f, x: l, y: c }) } function kf(e, t) { const n = El(e).scrollLeft; return t ? t.left + n : Br(nn(e)).left + n } function W0(e, t, n) { n === void 0 && (n = !1); const r = e.getBoundingClientRect(), s = r.left + t.scrollLeft - (n ? 0 : kf(e, r)), i = r.top + t.scrollTop; return { x: s, y: i } } function qT(e) { let { elements: t, rect: n, offsetParent: r, strategy: s } = e; const i = s === "fixed", o = nn(r), a = t ? Tl(t.floating) : !1; if (r === o || a && i) return n; let l = { scrollLeft: 0, scrollTop: 0 }, c = Zt(1); const d = Zt(0), f = tn(r); if ((f || !f && !i) && ((Xs(r) !== "body" || wo(o)) && (l = El(r)), tn(r))) { const p = Br(r); c = Ts(r), d.x = p.x + r.clientLeft, d.y = p.y + r.clientTop } const h = o && !f && !i ? W0(o, l, !0) : Zt(0); return { width: n.width * c.x, height: n.height * c.y, x: n.x * c.x - l.scrollLeft * c.x + d.x + h.x, y: n.y * c.y - l.scrollTop * c.y + d.y + h.y } } function XT(e) { return Array.from(e.getClientRects()) } function ZT(e) { const t = nn(e), n = El(e), r = e.ownerDocument.body, s = it(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), i = it(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight); let o = -n.scrollLeft + kf(e); const a = -n.scrollTop; return Bt(r).direction === "rtl" && (o += it(t.clientWidth, r.clientWidth) - s), { width: s, height: i, x: o, y: a } } function JT(e, t) { const n = lt(e), r = nn(e), s = n.visualViewport; let i = r.clientWidth, o = r.clientHeight, a = 0, l = 0; if (s) { i = s.width, o = s.height; const c = Sf(); (!c || c && t === "fixed") && (a = s.offsetLeft, l = s.offsetTop) } return { width: i, height: o, x: a, y: l } } const eE = new Set(["absolute", "fixed"]); function tE(e, t) { const n = Br(e, !0, t === "fixed"), r = n.top + e.clientTop, s = n.left + e.clientLeft, i = tn(e) ? Ts(e) : Zt(1), o = e.clientWidth * i.x, a = e.clientHeight * i.y, l = s * i.x, c = r * i.y; return { width: o, height: a, x: l, y: c } } function Hp(e, t, n) { let r; if (t === "viewport") r = JT(e, n); else if (t === "document") r = ZT(nn(e)); else if (zt(t)) r = tE(t, n); else { const s = U0(e); r = { x: t.x - s.x, y: t.y - s.y, width: t.width, height: t.height } } return Ya(r) } function H0(e, t) { const n = ir(e); return n === t || !zt(n) || $s(n) ? !1 : Bt(n).position === "fixed" || H0(n, t) } function nE(e, t) { const n = t.get(e); if (n) return n; let r = eo(e, [], !1).filter(a => zt(a) && Xs(a) !== "body"), s = null; const i = Bt(e).position === "fixed"; let o = i ? ir(e) : e; for (; zt(o) && !$s(o);) { const a = Bt(o), l = bf(o); !l && a.position === "fixed" && (s = null), (i ? !l && !s : !l && a.position === "static" && !!s && eE.has(s.position) || wo(o) && !l && H0(e, o)) ? r = r.filter(d => d !== o) : s = a, o = ir(o) } return t.set(e, r), r } function rE(e) { let { element: t, boundary: n, rootBoundary: r, strategy: s } = e; const o = [...n === "clippingAncestors" ? Tl(t) ? [] : nE(t, this._c) : [].concat(n), r], a = o[0], l = o.reduce((c, d) => { const f = Hp(t, d, s); return c.top = it(f.top, c.top), c.right = sr(f.right, c.right), c.bottom = sr(f.bottom, c.bottom), c.left = it(f.left, c.left), c }, Hp(t, a, s)); return { width: l.right - l.left, height: l.bottom - l.top, x: l.left, y: l.top } } function sE(e) { const { width: t, height: n } = $0(e); return { width: t, height: n } } function iE(e, t, n) { const r = tn(t), s = nn(t), i = n === "fixed", o = Br(e, !0, i, t); let a = { scrollLeft: 0, scrollTop: 0 }; const l = Zt(0); function c() { l.x = kf(s) } if (r || !r && !i) if ((Xs(t) !== "body" || wo(s)) && (a = El(t)), r) { const p = Br(t, !0, i, t); l.x = p.x + t.clientLeft, l.y = p.y + t.clientTop } else s && c(); i && !r && s && c(); const d = s && !r && !i ? W0(s, a) : Zt(0), f = o.left + a.scrollLeft - l.x - d.x, h = o.top + a.scrollTop - l.y - d.y; return { x: f, y: h, width: o.width, height: o.height } } function vc(e) { return Bt(e).position === "static" } function Kp(e, t) { if (!tn(e) || Bt(e).position === "fixed") return null; if (t) return t(e); let n = e.offsetParent; return nn(e) === n && (n = n.ownerDocument.body), n } function K0(e, t) { const n = lt(e); if (Tl(e)) return n; if (!tn(e)) { let s = ir(e); for (; s && !$s(s);) { if (zt(s) && !vc(s)) return s; s = ir(s) } return n } let r = Kp(e, t); for (; r && BT(r) && vc(r);)r = Kp(r, t); return r && $s(r) && vc(r) && !bf(r) ? n : r || KT(e) || n } const oE = async function (e) { const t = this.getOffsetParent || K0, n = this.getDimensions, r = await n(e.floating); return { reference: iE(e.reference, await t(e.floating), e.strategy), floating: { x: 0, y: 0, width: r.width, height: r.height } } }; function aE(e) { return Bt(e).direction === "rtl" } const lE = { convertOffsetParentRelativeRectToViewportRelativeRect: qT, getDocumentElement: nn, getClippingRect: rE, getOffsetParent: K0, getElementRects: oE, getClientRects: XT, getDimensions: sE, getScale: Ts, isElement: zt, isRTL: aE }; function Y0(e, t) { return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height } function cE(e, t) { let n = null, r; const s = nn(e); function i() { var a; clearTimeout(r), (a = n) == null || a.disconnect(), n = null } function o(a, l) { a === void 0 && (a = !1), l === void 0 && (l = 1), i(); const c = e.getBoundingClientRect(), { left: d, top: f, width: h, height: p } = c; if (a || t(), !h || !p) return; const w = qo(f), y = qo(s.clientWidth - (d + h)), b = qo(s.clientHeight - (f + p)), g = qo(d), v = { rootMargin: -w + "px " + -y + "px " + -b + "px " + -g + "px", threshold: it(0, sr(1, l)) || 1 }; let S = !0; function C(k) { const T = k[0].intersectionRatio; if (T !== l) { if (!S) return o(); T ? o(!1, T) : r = setTimeout(() => { o(!1, 1e-7) }, 1e3) } T === 1 && !Y0(c, e.getBoundingClientRect()) && o(), S = !1 } try { n = new IntersectionObserver(C, { ...v, root: s.ownerDocument }) } catch { n = new IntersectionObserver(C, v) } n.observe(e) } return o(!0), i } function uE(e, t, n, r) { r === void 0 && (r = {}); const { ancestorScroll: s = !0, ancestorResize: i = !0, elementResize: o = typeof ResizeObserver == "function", layoutShift: a = typeof IntersectionObserver == "function", animationFrame: l = !1 } = r, c = Cf(e), d = s || i ? [...c ? eo(c) : [], ...eo(t)] : []; d.forEach(g => { s && g.addEventListener("scroll", n, { passive: !0 }), i && g.addEventListener("resize", n) }); const f = c && a ? cE(c, n) : null; let h = -1, p = null; o && (p = new ResizeObserver(g => { let [m] = g; m && m.target === c && p && (p.unobserve(t), cancelAnimationFrame(h), h = requestAnimationFrame(() => { var v; (v = p) == null || v.observe(t) })), n() }), c && !l && p.observe(c), p.observe(t)); let w, y = l ? Br(e) : null; l && b(); function b() { const g = Br(e); y && !Y0(y, g) && n(), y = g, w = requestAnimationFrame(b) } return n(), () => { var g; d.forEach(m => { s && m.removeEventListener("scroll", n), i && m.removeEventListener("resize", n) }), f == null || f(), (g = p) == null || g.disconnect(), p = null, l && cancelAnimationFrame(w) } } const dE = OT, fE = IT, hE = MT, pE = VT, mE = DT, Yp = AT, gE = FT, yE = (e, t, n) => { const r = new Map, s = { platform: lE, ...n }, i = { ...s.platform, _c: r }; return RT(e, t, { ...s, platform: i }) }; var vE = typeof document < "u", xE = function () { }, ga = vE ? x.useLayoutEffect : xE; function Ga(e, t) { if (e === t) return !0; if (typeof e != typeof t) return !1; if (typeof e == "function" && e.toString() === t.toString()) return !0; let n, r, s; if (e && t && typeof e == "object") { if (Array.isArray(e)) { if (n = e.length, n !== t.length) return !1; for (r = n; r-- !== 0;)if (!Ga(e[r], t[r])) return !1; return !0 } if (s = Object.keys(e), n = s.length, n !== Object.keys(t).length) return !1; for (r = n; r-- !== 0;)if (!{}.hasOwnProperty.call(t, s[r])) return !1; for (r = n; r-- !== 0;) { const i = s[r]; if (!(i === "_owner" && e.$$typeof) && !Ga(e[i], t[i])) return !1 } return !0 } return e !== e && t !== t } function G0(e) { return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1 } function Gp(e, t) { const n = G0(e); return Math.round(t * n) / n } function xc(e) { const t = x.useRef(e); return ga(() => { t.current = e }), t } function wE(e) { e === void 0 && (e = {}); const { placement: t = "bottom", strategy: n = "absolute", middleware: r = [], platform: s, elements: { reference: i, floating: o } = {}, transform: a = !0, whileElementsMounted: l, open: c } = e, [d, f] = x.useState({ x: 0, y: 0, strategy: n, placement: t, middlewareData: {}, isPositioned: !1 }), [h, p] = x.useState(r); Ga(h, r) || p(r); const [w, y] = x.useState(null), [b, g] = x.useState(null), m = x.useCallback(N => { N !== k.current && (k.current = N, y(N)) }, []), v = x.useCallback(N => { N !== T.current && (T.current = N, g(N)) }, []), S = i || w, C = o || b, k = x.useRef(null), T = x.useRef(null), E = x.useRef(d), A = l != null, R = xc(l), _ = xc(s), I = xc(c), G = x.useCallback(() => { if (!k.current || !T.current) return; const N = { placement: t, strategy: n, middleware: h }; _.current && (N.platform = _.current), yE(k.current, T.current, N).then(j => { const O = { ...j, isPositioned: I.current !== !1 }; L.current && !Ga(E.current, O) && (E.current = O, vo.flushSync(() => { f(O) })) }) }, [h, t, n, _, I]); ga(() => { c === !1 && E.current.isPositioned && (E.current.isPositioned = !1, f(N => ({ ...N, isPositioned: !1 }))) }, [c]); const L = x.useRef(!1); ga(() => (L.current = !0, () => { L.current = !1 }), []), ga(() => { if (S && (k.current = S), C && (T.current = C), S && C) { if (R.current) return R.current(S, C, G); G() } }, [S, C, G, R, A]); const Q = x.useMemo(() => ({ reference: k, floating: T, setReference: m, setFloating: v }), [m, v]), $ = x.useMemo(() => ({ reference: S, floating: C }), [S, C]), V = x.useMemo(() => { const N = { position: n, left: 0, top: 0 }; if (!$.floating) return N; const j = Gp($.floating, d.x), O = Gp($.floating, d.y); return a ? { ...N, transform: "translate(" + j + "px, " + O + "px)", ...G0($.floating) >= 1.5 && { willChange: "transform" } } : { position: n, left: j, top: O } }, [n, a, $.floating, d.x, d.y]); return x.useMemo(() => ({ ...d, update: G, refs: Q, elements: $, floatingStyles: V }), [d, G, Q, $, V]) } const bE = e => { function t(n) { return {}.hasOwnProperty.call(n, "current") } return { name: "arrow", options: e, fn(n) { const { element: r, padding: s } = typeof e == "function" ? e(n) : e; return r && t(r) ? r.current != null ? Yp({ element: r.current, padding: s }).fn(n) : {} : r ? Yp({ element: r, padding: s }).fn(n) : {} } } }, SE = (e, t) => ({ ...dE(e), options: [e, t] }), CE = (e, t) => ({ ...fE(e), options: [e, t] }), kE = (e, t) => ({ ...gE(e), options: [e, t] }), TE = (e, t) => ({ ...hE(e), options: [e, t] }), EE = (e, t) => ({ ...pE(e), options: [e, t] }), NE = (e, t) => ({ ...mE(e), options: [e, t] }), PE = (e, t) => ({ ...bE(e), options: [e, t] }); var jE = "Arrow", Q0 = x.forwardRef((e, t) => { const { children: n, width: r = 10, height: s = 5, ...i } = e; return u.jsx(rt.svg, { ...i, ref: t, width: r, height: s, viewBox: "0 0 30 10", preserveAspectRatio: "none", children: e.asChild ? n : u.jsx("polygon", { points: "0,0 30,0 15,10" }) }) }); Q0.displayName = jE; var RE = Q0; function AE(e) { const [t, n] = x.useState(void 0); return rr(() => { if (e) { n({ width: e.offsetWidth, height: e.offsetHeight }); const r = new ResizeObserver(s => { if (!Array.isArray(s) || !s.length) return; const i = s[0]; let o, a; if ("borderBoxSize" in i) { const l = i.borderBoxSize, c = Array.isArray(l) ? l[0] : l; o = c.inlineSize, a = c.blockSize } else o = e.offsetWidth, a = e.offsetHeight; n({ width: o, height: a }) }); return r.observe(e, { box: "border-box" }), () => r.unobserve(e) } else n(void 0) }, [e]), t } var q0 = "Popper", [X0, Z0] = bl(q0), [MM, J0] = X0(q0), ex = "PopperAnchor", tx = x.forwardRef((e, t) => { const { __scopePopper: n, virtualRef: r, ...s } = e, i = J0(ex, n), o = x.useRef(null), a = _t(t, o); return x.useEffect(() => { i.onAnchorChange((r == null ? void 0 : r.current) || o.current) }), r ? null : u.jsx(rt.div, { ...s, ref: a }) }); tx.displayName = ex; var Tf = "PopperContent", [ME, DE] = X0(Tf), nx = x.forwardRef((e, t) => { var te, Yr, Sn, hr, Cn, Gr; const { __scopePopper: n, side: r = "bottom", sideOffset: s = 0, align: i = "center", alignOffset: o = 0, arrowPadding: a = 0, avoidCollisions: l = !0, collisionBoundary: c = [], collisionPadding: d = 0, sticky: f = "partial", hideWhenDetached: h = !1, updatePositionStrategy: p = "optimized", onPlaced: w, ...y } = e, b = J0(Tf, n), [g, m] = x.useState(null), v = _t(t, kn => m(kn)), [S, C] = x.useState(null), k = AE(S), T = (k == null ? void 0 : k.width) ?? 0, E = (k == null ? void 0 : k.height) ?? 0, A = r + (i !== "center" ? "-" + i : ""), R = typeof d == "number" ? d : { top: 0, right: 0, bottom: 0, left: 0, ...d }, _ = Array.isArray(c) ? c : [c], I = _.length > 0, G = { padding: R, boundary: _.filter(OE), altBoundary: I }, { refs: L, floatingStyles: Q, placement: $, isPositioned: V, middlewareData: N } = wE({ strategy: "fixed", placement: A, whileElementsMounted: (...kn) => uE(...kn, { animationFrame: p === "always" }), elements: { reference: b.anchor }, middleware: [SE({ mainAxis: s + E, alignmentAxis: o }), l && CE({ mainAxis: !0, crossAxis: !1, limiter: f === "partial" ? kE() : void 0, ...G }), l && TE({ ...G }), EE({ ...G, apply: ({ elements: kn, rects: Eo, availableWidth: Il, availableHeight: No }) => { const { width: Fl, height: ri } = Eo.reference, Qr = kn.floating.style; Qr.setProperty("--radix-popper-available-width", `${Il}px`), Qr.setProperty("--radix-popper-available-height", `${No}px`), Qr.setProperty("--radix-popper-anchor-width", `${Fl}px`), Qr.setProperty("--radix-popper-anchor-height", `${ri}px`) } }), S && PE({ element: S, padding: a }), IE({ arrowWidth: T, arrowHeight: E }), h && NE({ strategy: "referenceHidden", ...G })] }), [j, O] = ix($), U = nr(w); rr(() => { V && (U == null || U()) }, [V, U]); const z = (te = N.arrow) == null ? void 0 : te.x, q = (Yr = N.arrow) == null ? void 0 : Yr.y, Z = ((Sn = N.arrow) == null ? void 0 : Sn.centerOffset) !== 0, [we, Oe] = x.useState(); return rr(() => { g && Oe(window.getComputedStyle(g).zIndex) }, [g]), u.jsx("div", { ref: L.setFloating, "data-radix-popper-content-wrapper": "", style: { ...Q, transform: V ? Q.transform : "translate(0, -200%)", minWidth: "max-content", zIndex: we, "--radix-popper-transform-origin": [(hr = N.transformOrigin) == null ? void 0 : hr.x, (Cn = N.transformOrigin) == null ? void 0 : Cn.y].join(" "), ...((Gr = N.hide) == null ? void 0 : Gr.referenceHidden) && { visibility: "hidden", pointerEvents: "none" } }, dir: e.dir, children: u.jsx(ME, { scope: n, placedSide: j, onArrowChange: C, arrowX: z, arrowY: q, shouldHideArrow: Z, children: u.jsx(rt.div, { "data-side": j, "data-align": O, ...y, ref: v, style: { ...y.style, animation: V ? void 0 : "none" } }) }) }) }); nx.displayName = Tf; var rx = "PopperArrow", LE = { top: "bottom", right: "left", bottom: "top", left: "right" }, sx = x.forwardRef(function (t, n) { const { __scopePopper: r, ...s } = t, i = DE(rx, r), o = LE[i.placedSide]; return u.jsx("span", { ref: i.onArrowChange, style: { position: "absolute", left: i.arrowX, top: i.arrowY, [o]: 0, transformOrigin: { top: "", right: "0 0", bottom: "center 0", left: "100% 0" }[i.placedSide], transform: { top: "translateY(100%)", right: "translateY(50%) rotate(90deg) translateX(-50%)", bottom: "rotate(180deg)", left: "translateY(50%) rotate(-90deg) translateX(50%)" }[i.placedSide], visibility: i.shouldHideArrow ? "hidden" : void 0 }, children: u.jsx(RE, { ...s, ref: n, style: { ...s.style, display: "block" } }) }) }); sx.displayName = rx; function OE(e) { return e !== null } var IE = e => ({ name: "transformOrigin", options: e, fn(t) { var b, g, m; const { placement: n, rects: r, middlewareData: s } = t, o = ((b = s.arrow) == null ? void 0 : b.centerOffset) !== 0, a = o ? 0 : e.arrowWidth, l = o ? 0 : e.arrowHeight, [c, d] = ix(n), f = { start: "0%", center: "50%", end: "100%" }[d], h = (((g = s.arrow) == null ? void 0 : g.x) ?? 0) + a / 2, p = (((m = s.arrow) == null ? void 0 : m.y) ?? 0) + l / 2; let w = "", y = ""; return c === "bottom" ? (w = o ? f : `${h}px`, y = `${-l}px`) : c === "top" ? (w = o ? f : `${h}px`, y = `${r.floating.height + l}px`) : c === "right" ? (w = `${-l}px`, y = o ? f : `${p}px`) : c === "left" && (w = `${r.floating.width + l}px`, y = o ? f : `${p}px`), { data: { x: w, y } } } }); function ix(e) { const [t, n = "center"] = e.split("-"); return [t, n] } var FE = tx, VE = nx, _E = sx, [Nl, DM] = bl("Tooltip", [Z0]), Ef = Z0(), ox = "TooltipProvider", zE = 700, Qp = "tooltip.open", [BE, ax] = Nl(ox), lx = e => { const { __scopeTooltip: t, delayDuration: n = zE, skipDelayDuration: r = 300, disableHoverableContent: s = !1, children: i } = e, o = x.useRef(!0), a = x.useRef(!1), l = x.useRef(0); return x.useEffect(() => { const c = l.current; return () => window.clearTimeout(c) }, []), u.jsx(BE, { scope: t, isOpenDelayedRef: o, delayDuration: n, onOpen: x.useCallback(() => { window.clearTimeout(l.current), o.current = !1 }, []), onClose: x.useCallback(() => { window.clearTimeout(l.current), l.current = window.setTimeout(() => o.current = !0, r) }, [r]), isPointerInTransitRef: a, onPointerInTransitChange: x.useCallback(c => { a.current = c }, []), disableHoverableContent: s, children: i }) }; lx.displayName = ox; var cx = "Tooltip", [LM, Pl] = Nl(cx), zu = "TooltipTrigger", $E = x.forwardRef((e, t) => { const { __scopeTooltip: n, ...r } = e, s = Pl(zu, n), i = ax(zu, n), o = Ef(n), a = x.useRef(null), l = _t(t, a, s.onTriggerChange), c = x.useRef(!1), d = x.useRef(!1), f = x.useCallback(() => c.current = !1, []); return x.useEffect(() => () => document.removeEventListener("pointerup", f), [f]), u.jsx(FE, { asChild: !0, ...o, children: u.jsx(rt.button, { "aria-describedby": s.open ? s.contentId : void 0, "data-state": s.stateAttribute, ...r, ref: l, onPointerMove: Ne(e.onPointerMove, h => { h.pointerType !== "touch" && !d.current && !i.isPointerInTransitRef.current && (s.onTriggerEnter(), d.current = !0) }), onPointerLeave: Ne(e.onPointerLeave, () => { s.onTriggerLeave(), d.current = !1 }), onPointerDown: Ne(e.onPointerDown, () => { s.open && s.onClose(), c.current = !0, document.addEventListener("pointerup", f, { once: !0 }) }), onFocus: Ne(e.onFocus, () => { c.current || s.onOpen() }), onBlur: Ne(e.onBlur, s.onClose), onClick: Ne(e.onClick, s.onClose) }) }) }); $E.displayName = zu; var UE = "TooltipPortal", [OM, WE] = Nl(UE, { forceMount: void 0 }), Us = "TooltipContent", ux = x.forwardRef((e, t) => { const n = WE(Us, e.__scopeTooltip), { forceMount: r = n.forceMount, side: s = "top", ...i } = e, o = Pl(Us, e.__scopeTooltip); return u.jsx(df, { present: r || o.open, children: o.disableHoverableContent ? u.jsx(dx, { side: s, ...i, ref: t }) : u.jsx(HE, { side: s, ...i, ref: t }) }) }), HE = x.forwardRef((e, t) => { const n = Pl(Us, e.__scopeTooltip), r = ax(Us, e.__scopeTooltip), s = x.useRef(null), i = _t(t, s), [o, a] = x.useState(null), { trigger: l, onClose: c } = n, d = s.current, { onPointerInTransitChange: f } = r, h = x.useCallback(() => { a(null), f(!1) }, [f]), p = x.useCallback((w, y) => { const b = w.currentTarget, g = { x: w.clientX, y: w.clientY }, m = qE(g, b.getBoundingClientRect()), v = XE(g, m), S = ZE(y.getBoundingClientRect()), C = eN([...v, ...S]); a(C), f(!0) }, [f]); return x.useEffect(() => () => h(), [h]), x.useEffect(() => { if (l && d) { const w = b => p(b, d), y = b => p(b, l); return l.addEventListener("pointerleave", w), d.addEventListener("pointerleave", y), () => { l.removeEventListener("pointerleave", w), d.removeEventListener("pointerleave", y) } } }, [l, d, p, h]), x.useEffect(() => { if (o) { const w = y => { const b = y.target, g = { x: y.clientX, y: y.clientY }, m = (l == null ? void 0 : l.contains(b)) || (d == null ? void 0 : d.contains(b)), v = !JE(g, o); m ? h() : v && (h(), c()) }; return document.addEventListener("pointermove", w), () => document.removeEventListener("pointermove", w) } }, [l, d, o, c, h]), u.jsx(dx, { ...e, ref: i }) }), [KE, YE] = Nl(cx, { isInside: !1 }), GE = eC("TooltipContent"), dx = x.forwardRef((e, t) => { const { __scopeTooltip: n, children: r, "aria-label": s, onEscapeKeyDown: i, onPointerDownOutside: o, ...a } = e, l = Pl(Us, n), c = Ef(n), { onClose: d } = l; return x.useEffect(() => (document.addEventListener(Qp, d), () => document.removeEventListener(Qp, d)), [d]), x.useEffect(() => { if (l.trigger) { const f = h => { const p = h.target; p != null && p.contains(l.trigger) && d() }; return window.addEventListener("scroll", f, { capture: !0 }), () => window.removeEventListener("scroll", f, { capture: !0 }) } }, [l.trigger, d]), u.jsx(uf, { asChild: !0, disableOutsidePointerEvents: !1, onEscapeKeyDown: i, onPointerDownOutside: o, onFocusOutside: f => f.preventDefault(), onDismiss: d, children: u.jsxs(VE, { "data-state": l.stateAttribute, ...c, ...a, ref: t, style: { ...a.style, "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)", "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)", "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)", "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)", "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)" }, children: [u.jsx(GE, { children: r }), u.jsx(KE, { scope: n, isInside: !0, children: u.jsx(TC, { id: l.contentId, role: "tooltip", children: s || r }) })] }) }) }); ux.displayName = Us; var fx = "TooltipArrow", QE = x.forwardRef((e, t) => { const { __scopeTooltip: n, ...r } = e, s = Ef(n); return YE(fx, n).isInside ? null : u.jsx(_E, { ...s, ...r, ref: t }) }); QE.displayName = fx; function qE(e, t) { const n = Math.abs(t.top - e.y), r = Math.abs(t.bottom - e.y), s = Math.abs(t.right - e.x), i = Math.abs(t.left - e.x); switch (Math.min(n, r, s, i)) { case i: return "left"; case s: return "right"; case n: return "top"; case r: return "bottom"; default: throw new Error("unreachable") } } function XE(e, t, n = 5) { const r = []; switch (t) { case "top": r.push({ x: e.x - n, y: e.y + n }, { x: e.x + n, y: e.y + n }); break; case "bottom": r.push({ x: e.x - n, y: e.y - n }, { x: e.x + n, y: e.y - n }); break; case "left": r.push({ x: e.x + n, y: e.y - n }, { x: e.x + n, y: e.y + n }); break; case "right": r.push({ x: e.x - n, y: e.y - n }, { x: e.x - n, y: e.y + n }); break }return r } function ZE(e) { const { top: t, right: n, bottom: r, left: s } = e; return [{ x: s, y: t }, { x: n, y: t }, { x: n, y: r }, { x: s, y: r }] } function JE(e, t) { const { x: n, y: r } = e; let s = !1; for (let i = 0, o = t.length - 1; i < t.length; o = i++) { const a = t[i], l = t[o], c = a.x, d = a.y, f = l.x, h = l.y; d > r != h > r && n < (f - c) * (r - d) / (h - d) + c && (s = !s) } return s } function eN(e) { const t = e.slice(); return t.sort((n, r) => n.x < r.x ? -1 : n.x > r.x ? 1 : n.y < r.y ? -1 : n.y > r.y ? 1 : 0), tN(t) } function tN(e) { if (e.length <= 1) return e.slice(); const t = []; for (let r = 0; r < e.length; r++) { const s = e[r]; for (; t.length >= 2;) { const i = t[t.length - 1], o = t[t.length - 2]; if ((i.x - o.x) * (s.y - o.y) >= (i.y - o.y) * (s.x - o.x)) t.pop(); else break } t.push(s) } t.pop(); const n = []; for (let r = e.length - 1; r >= 0; r--) { const s = e[r]; for (; n.length >= 2;) { const i = n[n.length - 1], o = n[n.length - 2]; if ((i.x - o.x) * (s.y - o.y) >= (i.y - o.y) * (s.x - o.x)) n.pop(); else break } n.push(s) } return n.pop(), t.length === 1 && n.length === 1 && t[0].x === n[0].x && t[0].y === n[0].y ? t : t.concat(n) } var nN = lx, hx = ux; const rN = nN, sN = x.forwardRef(({ className: e, sideOffset: t = 4, ...n }, r) => u.jsx(hx, { ref: r, sideOffset: t, className: Wr("z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2", e), ...n })); sN.displayName = hx.displayName; var jl = class { constructor() { this.listeners = new Set, this.subscribe = this.subscribe.bind(this) } subscribe(e) { return this.listeners.add(e), this.onSubscribe(), () => { this.listeners.delete(e), this.onUnsubscribe() } } hasListeners() { return this.listeners.size > 0 } onSubscribe() { } onUnsubscribe() { } }, Rl = typeof window > "u" || "Deno" in globalThis; function At() { } function iN(e, t) { return typeof e == "function" ? e(t) : e } function oN(e) { return typeof e == "number" && e >= 0 && e !== 1 / 0 } function aN(e, t) { return Math.max(e + (t || 0) - Date.now(), 0) } function Bu(e, t) { return typeof e == "function" ? e(t) : e } function lN(e, t) { return typeof e == "function" ? e(t) : e } function qp(e, t) { const { type: n = "all", exact: r, fetchStatus: s, predicate: i, queryKey: o, stale: a } = e; if (o) { if (r) { if (t.queryHash !== Nf(o, t.options)) return !1 } else if (!no(t.queryKey, o)) return !1 } if (n !== "all") { const l = t.isActive(); if (n === "active" && !l || n === "inactive" && l) return !1 } return !(typeof a == "boolean" && t.isStale() !== a || s && s !== t.state.fetchStatus || i && !i(t)) } function Xp(e, t) { const { exact: n, status: r, predicate: s, mutationKey: i } = e; if (i) { if (!t.options.mutationKey) return !1; if (n) { if (to(t.options.mutationKey) !== to(i)) return !1 } else if (!no(t.options.mutationKey, i)) return !1 } return !(r && t.state.status !== r || s && !s(t)) } function Nf(e, t) { return ((t == null ? void 0 : t.queryKeyHashFn) || to)(e) } function to(e) { return JSON.stringify(e, (t, n) => $u(n) ? Object.keys(n).sort().reduce((r, s) => (r[s] = n[s], r), {}) : n) } function no(e, t) { return e === t ? !0 : typeof e != typeof t ? !1 : e && t && typeof e == "object" && typeof t == "object" ? Object.keys(t).every(n => no(e[n], t[n])) : !1 } function px(e, t) { if (e === t) return e; const n = Zp(e) && Zp(t); if (n || $u(e) && $u(t)) { const r = n ? e : Object.keys(e), s = r.length, i = n ? t : Object.keys(t), o = i.length, a = n ? [] : {}, l = new Set(r); let c = 0; for (let d = 0; d < o; d++) { const f = n ? d : i[d]; (!n && l.has(f) || n) && e[f] === void 0 && t[f] === void 0 ? (a[f] = void 0, c++) : (a[f] = px(e[f], t[f]), a[f] === e[f] && e[f] !== void 0 && c++) } return s === o && c === s ? e : a } return t } function Zp(e) { return Array.isArray(e) && e.length === Object.keys(e).length } function $u(e) { if (!Jp(e)) return !1; const t = e.constructor; if (t === void 0) return !0; const n = t.prototype; return !(!Jp(n) || !n.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(e) !== Object.prototype) } function Jp(e) { return Object.prototype.toString.call(e) === "[object Object]" } function cN(e) { return new Promise(t => { setTimeout(t, e) }) } function uN(e, t, n) { return typeof n.structuralSharing == "function" ? n.structuralSharing(e, t) : n.structuralSharing !== !1 ? px(e, t) : t } function dN(e, t, n = 0) { const r = [...e, t]; return n && r.length > n ? r.slice(1) : r } function fN(e, t, n = 0) { const r = [t, ...e]; return n && r.length > n ? r.slice(0, -1) : r } var Pf = Symbol(); function mx(e, t) { return !e.queryFn && (t != null && t.initialPromise) ? () => t.initialPromise : !e.queryFn || e.queryFn === Pf ? () => Promise.reject(new Error(`Missing queryFn: '${e.queryHash}'`)) : e.queryFn } var Tr, Fn, Ns, Pg, hN = (Pg = class extends jl { constructor() { super(); ee(this, Tr); ee(this, Fn); ee(this, Ns); H(this, Ns, t => { if (!Rl && window.addEventListener) { const n = () => t(); return window.addEventListener("visibilitychange", n, !1), () => { window.removeEventListener("visibilitychange", n) } } }) } onSubscribe() { P(this, Fn) || this.setEventListener(P(this, Ns)) } onUnsubscribe() { var t; this.hasListeners() || ((t = P(this, Fn)) == null || t.call(this), H(this, Fn, void 0)) } setEventListener(t) { var n; H(this, Ns, t), (n = P(this, Fn)) == null || n.call(this), H(this, Fn, t(r => { typeof r == "boolean" ? this.setFocused(r) : this.onFocus() })) } setFocused(t) { P(this, Tr) !== t && (H(this, Tr, t), this.onFocus()) } onFocus() { const t = this.isFocused(); this.listeners.forEach(n => { n(t) }) } isFocused() { var t; return typeof P(this, Tr) == "boolean" ? P(this, Tr) : ((t = globalThis.document) == null ? void 0 : t.visibilityState) !== "hidden" } }, Tr = new WeakMap, Fn = new WeakMap, Ns = new WeakMap, Pg), gx = new hN, Ps, Vn, js, jg, pN = (jg = class extends jl { constructor() { super(); ee(this, Ps, !0); ee(this, Vn); ee(this, js); H(this, js, t => { if (!Rl && window.addEventListener) { const n = () => t(!0), r = () => t(!1); return window.addEventListener("online", n, !1), window.addEventListener("offline", r, !1), () => { window.removeEventListener("online", n), window.removeEventListener("offline", r) } } }) } onSubscribe() { P(this, Vn) || this.setEventListener(P(this, js)) } onUnsubscribe() { var t; this.hasListeners() || ((t = P(this, Vn)) == null || t.call(this), H(this, Vn, void 0)) } setEventListener(t) { var n; H(this, js, t), (n = P(this, Vn)) == null || n.call(this), H(this, Vn, t(this.setOnline.bind(this))) } setOnline(t) { P(this, Ps) !== t && (H(this, Ps, t), this.listeners.forEach(r => { r(t) })) } isOnline() { return P(this, Ps) } }, Ps = new WeakMap, Vn = new WeakMap, js = new WeakMap, jg), Qa = new pN; function mN() { let e, t; const n = new Promise((s, i) => { e = s, t = i }); n.status = "pending", n.catch(() => { }); function r(s) { Object.assign(n, s), delete n.resolve, delete n.reject } return n.resolve = s => { r({ status: "fulfilled", value: s }), e(s) }, n.reject = s => { r({ status: "rejected", reason: s }), t(s) }, n } function gN(e) { return Math.min(1e3 * 2 ** e, 3e4) } function yx(e) { return (e ?? "online") === "online" ? Qa.isOnline() : !0 } var vx = class extends Error { constructor(e) { super("CancelledError"), this.revert = e == null ? void 0 : e.revert, this.silent = e == null ? void 0 : e.silent } }; function wc(e) { return e instanceof vx } function xx(e) { let t = !1, n = 0, r = !1, s; const i = mN(), o = y => { var b; r || (h(new vx(y)), (b = e.abort) == null || b.call(e)) }, a = () => { t = !0 }, l = () => { t = !1 }, c = () => gx.isFocused() && (e.networkMode === "always" || Qa.isOnline()) && e.canRun(), d = () => yx(e.networkMode) && e.canRun(), f = y => { var b; r || (r = !0, (b = e.onSuccess) == null || b.call(e, y), s == null || s(), i.resolve(y)) }, h = y => { var b; r || (r = !0, (b = e.onError) == null || b.call(e, y), s == null || s(), i.reject(y)) }, p = () => new Promise(y => { var b; s = g => { (r || c()) && y(g) }, (b = e.onPause) == null || b.call(e) }).then(() => { var y; s = void 0, r || (y = e.onContinue) == null || y.call(e) }), w = () => { if (r) return; let y; const b = n === 0 ? e.initialPromise : void 0; try { y = b ?? e.fn() } catch (g) { y = Promise.reject(g) } Promise.resolve(y).then(f).catch(g => { var k; if (r) return; const m = e.retry ?? (Rl ? 0 : 3), v = e.retryDelay ?? gN, S = typeof v == "function" ? v(n, g) : v, C = m === !0 || typeof m == "number" && n < m || typeof m == "function" && m(n, g); if (t || !C) { h(g); return } n++, (k = e.onFail) == null || k.call(e, n, g), cN(S).then(() => c() ? void 0 : p()).then(() => { t ? h(g) : w() }) }) }; return { promise: i, cancel: o, continue: () => (s == null || s(), i), cancelRetry: a, continueRetry: l, canStart: d, start: () => (d() ? w() : p().then(w), i) } } var yN = e => setTimeout(e, 0); function vN() { let e = [], t = 0, n = a => { a() }, r = a => { a() }, s = yN; const i = a => { t ? e.push(a) : s(() => { n(a) }) }, o = () => { const a = e; e = [], a.length && s(() => { r(() => { a.forEach(l => { n(l) }) }) }) }; return { batch: a => { let l; t++; try { l = a() } finally { t--, t || o() } return l }, batchCalls: a => (...l) => { i(() => { a(...l) }) }, schedule: i, setNotifyFunction: a => { n = a }, setBatchNotifyFunction: a => { r = a }, setScheduler: a => { s = a } } } var He = vN(), Er, Rg, wx = (Rg = class { constructor() { ee(this, Er) } destroy() { this.clearGcTimeout() } scheduleGc() { this.clearGcTimeout(), oN(this.gcTime) && H(this, Er, setTimeout(() => { this.optionalRemove() }, this.gcTime)) } updateGcTime(e) { this.gcTime = Math.max(this.gcTime || 0, e ?? (Rl ? 1 / 0 : 5 * 60 * 1e3)) } clearGcTimeout() { P(this, Er) && (clearTimeout(P(this, Er)), H(this, Er, void 0)) } }, Er = new WeakMap, Rg), Rs, Nr, pt, Pr, _e, uo, jr, Mt, sn, Ag, xN = (Ag = class extends wx { constructor(t) { super(); ee(this, Mt); ee(this, Rs); ee(this, Nr); ee(this, pt); ee(this, Pr); ee(this, _e); ee(this, uo); ee(this, jr); H(this, jr, !1), H(this, uo, t.defaultOptions), this.setOptions(t.options), this.observers = [], H(this, Pr, t.client), H(this, pt, P(this, Pr).getQueryCache()), this.queryKey = t.queryKey, this.queryHash = t.queryHash, H(this, Rs, bN(this.options)), this.state = t.state ?? P(this, Rs), this.scheduleGc() } get meta() { return this.options.meta } get promise() { var t; return (t = P(this, _e)) == null ? void 0 : t.promise } setOptions(t) { this.options = { ...P(this, uo), ...t }, this.updateGcTime(this.options.gcTime) } optionalRemove() { !this.observers.length && this.state.fetchStatus === "idle" && P(this, pt).remove(this) } setData(t, n) { const r = uN(this.state.data, t, this.options); return Ie(this, Mt, sn).call(this, { data: r, type: "success", dataUpdatedAt: n == null ? void 0 : n.updatedAt, manual: n == null ? void 0 : n.manual }), r } setState(t, n) { Ie(this, Mt, sn).call(this, { type: "setState", state: t, setStateOptions: n }) } cancel(t) { var r, s; const n = (r = P(this, _e)) == null ? void 0 : r.promise; return (s = P(this, _e)) == null || s.cancel(t), n ? n.then(At).catch(At) : Promise.resolve() } destroy() { super.destroy(), this.cancel({ silent: !0 }) } reset() { this.destroy(), this.setState(P(this, Rs)) } isActive() { return this.observers.some(t => lN(t.options.enabled, this) !== !1) } isDisabled() { return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === Pf || this.state.dataUpdateCount + this.state.errorUpdateCount === 0 } isStatic() { return this.getObserversCount() > 0 ? this.observers.some(t => Bu(t.options.staleTime, this) === "static") : !1 } isStale() { return this.getObserversCount() > 0 ? this.observers.some(t => t.getCurrentResult().isStale) : this.state.data === void 0 || this.state.isInvalidated } isStaleByTime(t = 0) { return this.state.data === void 0 ? !0 : t === "static" ? !1 : this.state.isInvalidated ? !0 : !aN(this.state.dataUpdatedAt, t) } onFocus() { var n; const t = this.observers.find(r => r.shouldFetchOnWindowFocus()); t == null || t.refetch({ cancelRefetch: !1 }), (n = P(this, _e)) == null || n.continue() } onOnline() { var n; const t = this.observers.find(r => r.shouldFetchOnReconnect()); t == null || t.refetch({ cancelRefetch: !1 }), (n = P(this, _e)) == null || n.continue() } addObserver(t) { this.observers.includes(t) || (this.observers.push(t), this.clearGcTimeout(), P(this, pt).notify({ type: "observerAdded", query: this, observer: t })) } removeObserver(t) { this.observers.includes(t) && (this.observers = this.observers.filter(n => n !== t), this.observers.length || (P(this, _e) && (P(this, jr) ? P(this, _e).cancel({ revert: !0 }) : P(this, _e).cancelRetry()), this.scheduleGc()), P(this, pt).notify({ type: "observerRemoved", query: this, observer: t })) } getObserversCount() { return this.observers.length } invalidate() { this.state.isInvalidated || Ie(this, Mt, sn).call(this, { type: "invalidate" }) } fetch(t, n) { var c, d, f; if (this.state.fetchStatus !== "idle") { if (this.state.data !== void 0 && (n != null && n.cancelRefetch)) this.cancel({ silent: !0 }); else if (P(this, _e)) return P(this, _e).continueRetry(), P(this, _e).promise } if (t && this.setOptions(t), !this.options.queryFn) { const h = this.observers.find(p => p.options.queryFn); h && this.setOptions(h.options) } const r = new AbortController, s = h => { Object.defineProperty(h, "signal", { enumerable: !0, get: () => (H(this, jr, !0), r.signal) }) }, i = () => { const h = mx(this.options, n), w = (() => { const y = { client: P(this, Pr), queryKey: this.queryKey, meta: this.meta }; return s(y), y })(); return H(this, jr, !1), this.options.persister ? this.options.persister(h, w, this) : h(w) }, a = (() => { const h = { fetchOptions: n, options: this.options, queryKey: this.queryKey, client: P(this, Pr), state: this.state, fetchFn: i }; return s(h), h })(); (c = this.options.behavior) == null || c.onFetch(a, this), H(this, Nr, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((d = a.fetchOptions) == null ? void 0 : d.meta)) && Ie(this, Mt, sn).call(this, { type: "fetch", meta: (f = a.fetchOptions) == null ? void 0 : f.meta }); const l = h => { var p, w, y, b; wc(h) && h.silent || Ie(this, Mt, sn).call(this, { type: "error", error: h }), wc(h) || ((w = (p = P(this, pt).config).onError) == null || w.call(p, h, this), (b = (y = P(this, pt).config).onSettled) == null || b.call(y, this.state.data, h, this)), this.scheduleGc() }; return H(this, _e, xx({ initialPromise: n == null ? void 0 : n.initialPromise, fn: a.fetchFn, abort: r.abort.bind(r), onSuccess: h => { var p, w, y, b; if (h === void 0) { l(new Error(`${this.queryHash} data is undefined`)); return } try { this.setData(h) } catch (g) { l(g); return } (w = (p = P(this, pt).config).onSuccess) == null || w.call(p, h, this), (b = (y = P(this, pt).config).onSettled) == null || b.call(y, h, this.state.error, this), this.scheduleGc() }, onError: l, onFail: (h, p) => { Ie(this, Mt, sn).call(this, { type: "failed", failureCount: h, error: p }) }, onPause: () => { Ie(this, Mt, sn).call(this, { type: "pause" }) }, onContinue: () => { Ie(this, Mt, sn).call(this, { type: "continue" }) }, retry: a.options.retry, retryDelay: a.options.retryDelay, networkMode: a.options.networkMode, canRun: () => !0 })), P(this, _e).start() } }, Rs = new WeakMap, Nr = new WeakMap, pt = new WeakMap, Pr = new WeakMap, _e = new WeakMap, uo = new WeakMap, jr = new WeakMap, Mt = new WeakSet, sn = function (t) { const n = r => { switch (t.type) { case "failed": return { ...r, fetchFailureCount: t.failureCount, fetchFailureReason: t.error }; case "pause": return { ...r, fetchStatus: "paused" }; case "continue": return { ...r, fetchStatus: "fetching" }; case "fetch": return { ...r, ...wN(r.data, this.options), fetchMeta: t.meta ?? null }; case "success": return H(this, Nr, void 0), { ...r, data: t.data, dataUpdateCount: r.dataUpdateCount + 1, dataUpdatedAt: t.dataUpdatedAt ?? Date.now(), error: null, isInvalidated: !1, status: "success", ...!t.manual && { fetchStatus: "idle", fetchFailureCount: 0, fetchFailureReason: null } }; case "error": const s = t.error; return wc(s) && s.revert && P(this, Nr) ? { ...P(this, Nr), fetchStatus: "idle" } : { ...r, error: s, errorUpdateCount: r.errorUpdateCount + 1, errorUpdatedAt: Date.now(), fetchFailureCount: r.fetchFailureCount + 1, fetchFailureReason: s, fetchStatus: "idle", status: "error" }; case "invalidate": return { ...r, isInvalidated: !0 }; case "setState": return { ...r, ...t.state } } }; this.state = n(this.state), He.batch(() => { this.observers.forEach(r => { r.onQueryUpdate() }), P(this, pt).notify({ query: this, type: "updated", action: t }) }) }, Ag); function wN(e, t) { return { fetchFailureCount: 0, fetchFailureReason: null, fetchStatus: yx(t.networkMode) ? "fetching" : "paused", ...e === void 0 && { error: null, status: "pending" } } } function bN(e) { const t = typeof e.initialData == "function" ? e.initialData() : e.initialData, n = t !== void 0, r = n ? typeof e.initialDataUpdatedAt == "function" ? e.initialDataUpdatedAt() : e.initialDataUpdatedAt : 0; return { data: t, dataUpdateCount: 0, dataUpdatedAt: n ? r ?? Date.now() : 0, error: null, errorUpdateCount: 0, errorUpdatedAt: 0, fetchFailureCount: 0, fetchFailureReason: null, fetchMeta: null, isInvalidated: !1, status: n ? "success" : "pending", fetchStatus: "idle" } } var Wt, Mg, SN = (Mg = class extends jl { constructor(t = {}) { super(); ee(this, Wt); this.config = t, H(this, Wt, new Map) } build(t, n, r) { const s = n.queryKey, i = n.queryHash ?? Nf(s, n); let o = this.get(i); return o || (o = new xN({ client: t, queryKey: s, queryHash: i, options: t.defaultQueryOptions(n), state: r, defaultOptions: t.getQueryDefaults(s) }), this.add(o)), o } add(t) { P(this, Wt).has(t.queryHash) || (P(this, Wt).set(t.queryHash, t), this.notify({ type: "added", query: t })) } remove(t) { const n = P(this, Wt).get(t.queryHash); n && (t.destroy(), n === t && P(this, Wt).delete(t.queryHash), this.notify({ type: "removed", query: t })) } clear() { He.batch(() => { this.getAll().forEach(t => { this.remove(t) }) }) } get(t) { return P(this, Wt).get(t) } getAll() { return [...P(this, Wt).values()] } find(t) { const n = { exact: !0, ...t }; return this.getAll().find(r => qp(n, r)) } findAll(t = {}) { const n = this.getAll(); return Object.keys(t).length > 0 ? n.filter(r => qp(t, r)) : n } notify(t) { He.batch(() => { this.listeners.forEach(n => { n(t) }) }) } onFocus() { He.batch(() => { this.getAll().forEach(t => { t.onFocus() }) }) } onOnline() { He.batch(() => { this.getAll().forEach(t => { t.onOnline() }) }) } }, Wt = new WeakMap, Mg), Ht, Ue, Rr, Kt, An, Dg, CN = (Dg = class extends wx { constructor(t) { super(); ee(this, Kt); ee(this, Ht); ee(this, Ue); ee(this, Rr); this.mutationId = t.mutationId, H(this, Ue, t.mutationCache), H(this, Ht, []), this.state = t.state || kN(), this.setOptions(t.options), this.scheduleGc() } setOptions(t) { this.options = t, this.updateGcTime(this.options.gcTime) } get meta() { return this.options.meta } addObserver(t) { P(this, Ht).includes(t) || (P(this, Ht).push(t), this.clearGcTimeout(), P(this, Ue).notify({ type: "observerAdded", mutation: this, observer: t })) } removeObserver(t) { H(this, Ht, P(this, Ht).filter(n => n !== t)), this.scheduleGc(), P(this, Ue).notify({ type: "observerRemoved", mutation: this, observer: t }) } optionalRemove() { P(this, Ht).length || (this.state.status === "pending" ? this.scheduleGc() : P(this, Ue).remove(this)) } continue() { var t; return ((t = P(this, Rr)) == null ? void 0 : t.continue()) ?? this.execute(this.state.variables) } async execute(t) { var i, o, a, l, c, d, f, h, p, w, y, b, g, m, v, S, C, k, T, E; const n = () => { Ie(this, Kt, An).call(this, { type: "continue" }) }; H(this, Rr, xx({ fn: () => this.options.mutationFn ? this.options.mutationFn(t) : Promise.reject(new Error("No mutationFn found")), onFail: (A, R) => { Ie(this, Kt, An).call(this, { type: "failed", failureCount: A, error: R }) }, onPause: () => { Ie(this, Kt, An).call(this, { type: "pause" }) }, onContinue: n, retry: this.options.retry ?? 0, retryDelay: this.options.retryDelay, networkMode: this.options.networkMode, canRun: () => P(this, Ue).canRun(this) })); const r = this.state.status === "pending", s = !P(this, Rr).canStart(); try { if (r) n(); else { Ie(this, Kt, An).call(this, { type: "pending", variables: t, isPaused: s }), await ((o = (i = P(this, Ue).config).onMutate) == null ? void 0 : o.call(i, t, this)); const R = await ((l = (a = this.options).onMutate) == null ? void 0 : l.call(a, t)); R !== this.state.context && Ie(this, Kt, An).call(this, { type: "pending", context: R, variables: t, isPaused: s }) } const A = await P(this, Rr).start(); return await ((d = (c = P(this, Ue).config).onSuccess) == null ? void 0 : d.call(c, A, t, this.state.context, this)), await ((h = (f = this.options).onSuccess) == null ? void 0 : h.call(f, A, t, this.state.context)), await ((w = (p = P(this, Ue).config).onSettled) == null ? void 0 : w.call(p, A, null, this.state.variables, this.state.context, this)), await ((b = (y = this.options).onSettled) == null ? void 0 : b.call(y, A, null, t, this.state.context)), Ie(this, Kt, An).call(this, { type: "success", data: A }), A } catch (A) { try { throw await ((m = (g = P(this, Ue).config).onError) == null ? void 0 : m.call(g, A, t, this.state.context, this)), await ((S = (v = this.options).onError) == null ? void 0 : S.call(v, A, t, this.state.context)), await ((k = (C = P(this, Ue).config).onSettled) == null ? void 0 : k.call(C, void 0, A, this.state.variables, this.state.context, this)), await ((E = (T = this.options).onSettled) == null ? void 0 : E.call(T, void 0, A, t, this.state.context)), A } finally { Ie(this, Kt, An).call(this, { type: "error", error: A }) } } finally { P(this, Ue).runNext(this) } } }, Ht = new WeakMap, Ue = new WeakMap, Rr = new WeakMap, Kt = new WeakSet, An = function (t) { const n = r => { switch (t.type) { case "failed": return { ...r, failureCount: t.failureCount, failureReason: t.error }; case "pause": return { ...r, isPaused: !0 }; case "continue": return { ...r, isPaused: !1 }; case "pending": return { ...r, context: t.context, data: void 0, failureCount: 0, failureReason: null, error: null, isPaused: t.isPaused, status: "pending", variables: t.variables, submittedAt: Date.now() }; case "success": return { ...r, data: t.data, failureCount: 0, failureReason: null, error: null, status: "success", isPaused: !1 }; case "error": return { ...r, data: void 0, error: t.error, failureCount: r.failureCount + 1, failureReason: t.error, isPaused: !1, status: "error" } } }; this.state = n(this.state), He.batch(() => { P(this, Ht).forEach(r => { r.onMutationUpdate(t) }), P(this, Ue).notify({ mutation: this, type: "updated", action: t }) }) }, Dg); function kN() { return { context: void 0, data: void 0, error: null, failureCount: 0, failureReason: null, isPaused: !1, status: "idle", variables: void 0, submittedAt: 0 } } var cn, Dt, fo, Lg, TN = (Lg = class extends jl { constructor(t = {}) { super(); ee(this, cn); ee(this, Dt); ee(this, fo); this.config = t, H(this, cn, new Set), H(this, Dt, new Map), H(this, fo, 0) } build(t, n, r) { const s = new CN({ mutationCache: this, mutationId: ++jo(this, fo)._, options: t.defaultMutationOptions(n), state: r }); return this.add(s), s } add(t) { P(this, cn).add(t); const n = Xo(t); if (typeof n == "string") { const r = P(this, Dt).get(n); r ? r.push(t) : P(this, Dt).set(n, [t]) } this.notify({ type: "added", mutation: t }) } remove(t) { if (P(this, cn).delete(t)) { const n = Xo(t); if (typeof n == "string") { const r = P(this, Dt).get(n); if (r) if (r.length > 1) { const s = r.indexOf(t); s !== -1 && r.splice(s, 1) } else r[0] === t && P(this, Dt).delete(n) } } this.notify({ type: "removed", mutation: t }) } canRun(t) { const n = Xo(t); if (typeof n == "string") { const r = P(this, Dt).get(n), s = r == null ? void 0 : r.find(i => i.state.status === "pending"); return !s || s === t } else return !0 } runNext(t) { var r; const n = Xo(t); if (typeof n == "string") { const s = (r = P(this, Dt).get(n)) == null ? void 0 : r.find(i => i !== t && i.state.isPaused); return (s == null ? void 0 : s.continue()) ?? Promise.resolve() } else return Promise.resolve() } clear() { He.batch(() => { P(this, cn).forEach(t => { this.notify({ type: "removed", mutation: t }) }), P(this, cn).clear(), P(this, Dt).clear() }) } getAll() { return Array.from(P(this, cn)) } find(t) { const n = { exact: !0, ...t }; return this.getAll().find(r => Xp(n, r)) } findAll(t = {}) { return this.getAll().filter(n => Xp(t, n)) } notify(t) { He.batch(() => { this.listeners.forEach(n => { n(t) }) }) } resumePausedMutations() { const t = this.getAll().filter(n => n.state.isPaused); return He.batch(() => Promise.all(t.map(n => n.continue().catch(At)))) } }, cn = new WeakMap, Dt = new WeakMap, fo = new WeakMap, Lg); function Xo(e) { var t; return (t = e.options.scope) == null ? void 0 : t.id } function em(e) { return { onFetch: (t, n) => { var d, f, h, p, w; const r = t.options, s = (h = (f = (d = t.fetchOptions) == null ? void 0 : d.meta) == null ? void 0 : f.fetchMore) == null ? void 0 : h.direction, i = ((p = t.state.data) == null ? void 0 : p.pages) || [], o = ((w = t.state.data) == null ? void 0 : w.pageParams) || []; let a = { pages: [], pageParams: [] }, l = 0; const c = async () => { let y = !1; const b = v => { Object.defineProperty(v, "signal", { enumerable: !0, get: () => (t.signal.aborted ? y = !0 : t.signal.addEventListener("abort", () => { y = !0 }), t.signal) }) }, g = mx(t.options, t.fetchOptions), m = async (v, S, C) => { if (y) return Promise.reject(); if (S == null && v.pages.length) return Promise.resolve(v); const T = (() => { const _ = { client: t.client, queryKey: t.queryKey, pageParam: S, direction: C ? "backward" : "forward", meta: t.options.meta }; return b(_), _ })(), E = await g(T), { maxPages: A } = t.options, R = C ? fN : dN; return { pages: R(v.pages, E, A), pageParams: R(v.pageParams, S, A) } }; if (s && i.length) { const v = s === "backward", S = v ? EN : tm, C = { pages: i, pageParams: o }, k = S(r, C); a = await m(C, k, v) } else { const v = e ?? i.length; do { const S = l === 0 ? o[0] ?? r.initialPageParam : tm(r, a); if (l > 0 && S == null) break; a = await m(a, S), l++ } while (l < v) } return a }; t.options.persister ? t.fetchFn = () => { var y, b; return (b = (y = t.options).persister) == null ? void 0 : b.call(y, c, { client: t.client, queryKey: t.queryKey, meta: t.options.meta, signal: t.signal }, n) } : t.fetchFn = c } } } function tm(e, { pages: t, pageParams: n }) { const r = t.length - 1; return t.length > 0 ? e.getNextPageParam(t[r], t, n[r], n) : void 0 } function EN(e, { pages: t, pageParams: n }) { var r; return t.length > 0 ? (r = e.getPreviousPageParam) == null ? void 0 : r.call(e, t[0], t, n[0], n) : void 0 } var ge, _n, zn, As, Ms, Bn, Ds, Ls, Og, NN = (Og = class { constructor(e = {}) { ee(this, ge); ee(this, _n); ee(this, zn); ee(this, As); ee(this, Ms); ee(this, Bn); ee(this, Ds); ee(this, Ls); H(this, ge, e.queryCache || new SN), H(this, _n, e.mutationCache || new TN), H(this, zn, e.defaultOptions || {}), H(this, As, new Map), H(this, Ms, new Map), H(this, Bn, 0) } mount() { jo(this, Bn)._++, P(this, Bn) === 1 && (H(this, Ds, gx.subscribe(async e => { e && (await this.resumePausedMutations(), P(this, ge).onFocus()) })), H(this, Ls, Qa.subscribe(async e => { e && (await this.resumePausedMutations(), P(this, ge).onOnline()) }))) } unmount() { var e, t; jo(this, Bn)._--, P(this, Bn) === 0 && ((e = P(this, Ds)) == null || e.call(this), H(this, Ds, void 0), (t = P(this, Ls)) == null || t.call(this), H(this, Ls, void 0)) } isFetching(e) { return P(this, ge).findAll({ ...e, fetchStatus: "fetching" }).length } isMutating(e) { return P(this, _n).findAll({ ...e, status: "pending" }).length } getQueryData(e) { var n; const t = this.defaultQueryOptions({ queryKey: e }); return (n = P(this, ge).get(t.queryHash)) == null ? void 0 : n.state.data } ensureQueryData(e) { const t = this.defaultQueryOptions(e), n = P(this, ge).build(this, t), r = n.state.data; return r === void 0 ? this.fetchQuery(e) : (e.revalidateIfStale && n.isStaleByTime(Bu(t.staleTime, n)) && this.prefetchQuery(t), Promise.resolve(r)) } getQueriesData(e) { return P(this, ge).findAll(e).map(({ queryKey: t, state: n }) => { const r = n.data; return [t, r] }) } setQueryData(e, t, n) { const r = this.defaultQueryOptions({ queryKey: e }), s = P(this, ge).get(r.queryHash), i = s == null ? void 0 : s.state.data, o = iN(t, i); if (o !== void 0) return P(this, ge).build(this, r).setData(o, { ...n, manual: !0 }) } setQueriesData(e, t, n) { return He.batch(() => P(this, ge).findAll(e).map(({ queryKey: r }) => [r, this.setQueryData(r, t, n)])) } getQueryState(e) { var n; const t = this.defaultQueryOptions({ queryKey: e }); return (n = P(this, ge).get(t.queryHash)) == null ? void 0 : n.state } removeQueries(e) { const t = P(this, ge); He.batch(() => { t.findAll(e).forEach(n => { t.remove(n) }) }) } resetQueries(e, t) { const n = P(this, ge); return He.batch(() => (n.findAll(e).forEach(r => { r.reset() }), this.refetchQueries({ type: "active", ...e }, t))) } cancelQueries(e, t = {}) { const n = { revert: !0, ...t }, r = He.batch(() => P(this, ge).findAll(e).map(s => s.cancel(n))); return Promise.all(r).then(At).catch(At) } invalidateQueries(e, t = {}) { return He.batch(() => (P(this, ge).findAll(e).forEach(n => { n.invalidate() }), (e == null ? void 0 : e.refetchType) === "none" ? Promise.resolve() : this.refetchQueries({ ...e, type: (e == null ? void 0 : e.refetchType) ?? (e == null ? void 0 : e.type) ?? "active" }, t))) } refetchQueries(e, t = {}) { const n = { ...t, cancelRefetch: t.cancelRefetch ?? !0 }, r = He.batch(() => P(this, ge).findAll(e).filter(s => !s.isDisabled() && !s.isStatic()).map(s => { let i = s.fetch(void 0, n); return n.throwOnError || (i = i.catch(At)), s.state.fetchStatus === "paused" ? Promise.resolve() : i })); return Promise.all(r).then(At) } fetchQuery(e) { const t = this.defaultQueryOptions(e); t.retry === void 0 && (t.retry = !1); const n = P(this, ge).build(this, t); return n.isStaleByTime(Bu(t.staleTime, n)) ? n.fetch(t) : Promise.resolve(n.state.data) } prefetchQuery(e) { return this.fetchQuery(e).then(At).catch(At) } fetchInfiniteQuery(e) { return e.behavior = em(e.pages), this.fetchQuery(e) } prefetchInfiniteQuery(e) { return this.fetchInfiniteQuery(e).then(At).catch(At) } ensureInfiniteQueryData(e) { return e.behavior = em(e.pages), this.ensureQueryData(e) } resumePausedMutations() { return Qa.isOnline() ? P(this, _n).resumePausedMutations() : Promise.resolve() } getQueryCache() { return P(this, ge) } getMutationCache() { return P(this, _n) } getDefaultOptions() { return P(this, zn) } setDefaultOptions(e) { H(this, zn, e) } setQueryDefaults(e, t) { P(this, As).set(to(e), { queryKey: e, defaultOptions: t }) } getQueryDefaults(e) { const t = [...P(this, As).values()], n = {}; return t.forEach(r => { no(e, r.queryKey) && Object.assign(n, r.defaultOptions) }), n } setMutationDefaults(e, t) { P(this, Ms).set(to(e), { mutationKey: e, defaultOptions: t }) } getMutationDefaults(e) { const t = [...P(this, Ms).values()], n = {}; return t.forEach(r => { no(e, r.mutationKey) && Object.assign(n, r.defaultOptions) }), n } defaultQueryOptions(e) { if (e._defaulted) return e; const t = { ...P(this, zn).queries, ...this.getQueryDefaults(e.queryKey), ...e, _defaulted: !0 }; return t.queryHash || (t.queryHash = Nf(t.queryKey, t)), t.refetchOnReconnect === void 0 && (t.refetchOnReconnect = t.networkMode !== "always"), t.throwOnError === void 0 && (t.throwOnError = !!t.suspense), !t.networkMode && t.persister && (t.networkMode = "offlineFirst"), t.queryFn === Pf && (t.enabled = !1), t } defaultMutationOptions(e) { return e != null && e._defaulted ? e : { ...P(this, zn).mutations, ...(e == null ? void 0 : e.mutationKey) && this.getMutationDefaults(e.mutationKey), ...e, _defaulted: !0 } } clear() { P(this, ge).clear(), P(this, _n).clear() } }, ge = new WeakMap, _n = new WeakMap, zn = new WeakMap, As = new WeakMap, Ms = new WeakMap, Bn = new WeakMap, Ds = new WeakMap, Ls = new WeakMap, Og), PN = x.createContext(void 0), jN = ({ client: e, children: t }) => (x.useEffect(() => (e.mount(), () => { e.unmount() }), [e]), u.jsx(PN.Provider, { value: e, children: t }));/**
 * @remix-run/router v1.23.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function ro() { return ro = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, ro.apply(this, arguments) } var Wn; (function (e) { e.Pop = "POP", e.Push = "PUSH", e.Replace = "REPLACE" })(Wn || (Wn = {})); const nm = "popstate"; function RN(e) { e === void 0 && (e = {}); function t(r, s) { let { pathname: i, search: o, hash: a } = r.location; return Uu("", { pathname: i, search: o, hash: a }, s.state && s.state.usr || null, s.state && s.state.key || "default") } function n(r, s) { return typeof s == "string" ? s : qa(s) } return MN(t, n, null, e) } function Ce(e, t) { if (e === !1 || e === null || typeof e > "u") throw new Error(t) } function bx(e, t) { if (!e) { typeof console < "u" && console.warn(t); try { throw new Error(t) } catch { } } } function AN() { return Math.random().toString(36).substr(2, 8) } function rm(e, t) { return { usr: e.state, key: e.key, idx: t } } function Uu(e, t, n, r) { return n === void 0 && (n = null), ro({ pathname: typeof e == "string" ? e : e.pathname, search: "", hash: "" }, typeof t == "string" ? Zs(t) : t, { state: n, key: t && t.key || r || AN() }) } function qa(e) { let { pathname: t = "/", search: n = "", hash: r = "" } = e; return n && n !== "?" && (t += n.charAt(0) === "?" ? n : "?" + n), r && r !== "#" && (t += r.charAt(0) === "#" ? r : "#" + r), t } function Zs(e) { let t = {}; if (e) { let n = e.indexOf("#"); n >= 0 && (t.hash = e.substr(n), e = e.substr(0, n)); let r = e.indexOf("?"); r >= 0 && (t.search = e.substr(r), e = e.substr(0, r)), e && (t.pathname = e) } return t } function MN(e, t, n, r) { r === void 0 && (r = {}); let { window: s = document.defaultView, v5Compat: i = !1 } = r, o = s.history, a = Wn.Pop, l = null, c = d(); c == null && (c = 0, o.replaceState(ro({}, o.state, { idx: c }), "")); function d() { return (o.state || { idx: null }).idx } function f() { a = Wn.Pop; let b = d(), g = b == null ? null : b - c; c = b, l && l({ action: a, location: y.location, delta: g }) } function h(b, g) { a = Wn.Push; let m = Uu(y.location, b, g); c = d() + 1; let v = rm(m, c), S = y.createHref(m); try { o.pushState(v, "", S) } catch (C) { if (C instanceof DOMException && C.name === "DataCloneError") throw C; s.location.assign(S) } i && l && l({ action: a, location: y.location, delta: 1 }) } function p(b, g) { a = Wn.Replace; let m = Uu(y.location, b, g); c = d(); let v = rm(m, c), S = y.createHref(m); o.replaceState(v, "", S), i && l && l({ action: a, location: y.location, delta: 0 }) } function w(b) { let g = s.location.origin !== "null" ? s.location.origin : s.location.href, m = typeof b == "string" ? b : qa(b); return m = m.replace(/ $/, "%20"), Ce(g, "No window.location.(origin|href) available to create URL for href: " + m), new URL(m, g) } let y = { get action() { return a }, get location() { return e(s, o) }, listen(b) { if (l) throw new Error("A history only accepts one active listener"); return s.addEventListener(nm, f), l = b, () => { s.removeEventListener(nm, f), l = null } }, createHref(b) { return t(s, b) }, createURL: w, encodeLocation(b) { let g = w(b); return { pathname: g.pathname, search: g.search, hash: g.hash } }, push: h, replace: p, go(b) { return o.go(b) } }; return y } var sm; (function (e) { e.data = "data", e.deferred = "deferred", e.redirect = "redirect", e.error = "error" })(sm || (sm = {})); function DN(e, t, n) { return n === void 0 && (n = "/"), LN(e, t, n, !1) } function LN(e, t, n, r) { let s = typeof t == "string" ? Zs(t) : t, i = jf(s.pathname || "/", n); if (i == null) return null; let o = Sx(e); ON(o); let a = null; for (let l = 0; a == null && l < o.length; ++l) { let c = KN(i); a = WN(o[l], c, r) } return a } function Sx(e, t, n, r) { t === void 0 && (t = []), n === void 0 && (n = []), r === void 0 && (r = ""); let s = (i, o, a) => { let l = { relativePath: a === void 0 ? i.path || "" : a, caseSensitive: i.caseSensitive === !0, childrenIndex: o, route: i }; l.relativePath.startsWith("/") && (Ce(l.relativePath.startsWith(r), 'Absolute route path "' + l.relativePath + '" nested under path ' + ('"' + r + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), l.relativePath = l.relativePath.slice(r.length)); let c = Jn([r, l.relativePath]), d = n.concat(l); i.children && i.children.length > 0 && (Ce(i.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + c + '".')), Sx(i.children, t, d, c)), !(i.path == null && !i.index) && t.push({ path: c, score: $N(c, i.index), routesMeta: d }) }; return e.forEach((i, o) => { var a; if (i.path === "" || !((a = i.path) != null && a.includes("?"))) s(i, o); else for (let l of Cx(i.path)) s(i, o, l) }), t } function Cx(e) { let t = e.split("/"); if (t.length === 0) return []; let [n, ...r] = t, s = n.endsWith("?"), i = n.replace(/\?$/, ""); if (r.length === 0) return s ? [i, ""] : [i]; let o = Cx(r.join("/")), a = []; return a.push(...o.map(l => l === "" ? i : [i, l].join("/"))), s && a.push(...o), a.map(l => e.startsWith("/") && l === "" ? "/" : l) } function ON(e) { e.sort((t, n) => t.score !== n.score ? n.score - t.score : UN(t.routesMeta.map(r => r.childrenIndex), n.routesMeta.map(r => r.childrenIndex))) } const IN = /^:[\w-]+$/, FN = 3, VN = 2, _N = 1, zN = 10, BN = -2, im = e => e === "*"; function $N(e, t) { let n = e.split("/"), r = n.length; return n.some(im) && (r += BN), t && (r += VN), n.filter(s => !im(s)).reduce((s, i) => s + (IN.test(i) ? FN : i === "" ? _N : zN), r) } function UN(e, t) { return e.length === t.length && e.slice(0, -1).every((r, s) => r === t[s]) ? e[e.length - 1] - t[t.length - 1] : 0 } function WN(e, t, n) { let { routesMeta: r } = e, s = {}, i = "/", o = []; for (let a = 0; a < r.length; ++a) { let l = r[a], c = a === r.length - 1, d = i === "/" ? t : t.slice(i.length) || "/", f = om({ path: l.relativePath, caseSensitive: l.caseSensitive, end: c }, d), h = l.route; if (!f && c && n && !r[r.length - 1].route.index && (f = om({ path: l.relativePath, caseSensitive: l.caseSensitive, end: !1 }, d)), !f) return null; Object.assign(s, f.params), o.push({ params: s, pathname: Jn([i, f.pathname]), pathnameBase: qN(Jn([i, f.pathnameBase])), route: h }), f.pathnameBase !== "/" && (i = Jn([i, f.pathnameBase])) } return o } function om(e, t) { typeof e == "string" && (e = { path: e, caseSensitive: !1, end: !0 }); let [n, r] = HN(e.path, e.caseSensitive, e.end), s = t.match(n); if (!s) return null; let i = s[0], o = i.replace(/(.)\/+$/, "$1"), a = s.slice(1); return { params: r.reduce((c, d, f) => { let { paramName: h, isOptional: p } = d; if (h === "*") { let y = a[f] || ""; o = i.slice(0, i.length - y.length).replace(/(.)\/+$/, "$1") } const w = a[f]; return p && !w ? c[h] = void 0 : c[h] = (w || "").replace(/%2F/g, "/"), c }, {}), pathname: i, pathnameBase: o, pattern: e } } function HN(e, t, n) { t === void 0 && (t = !1), n === void 0 && (n = !0), bx(e === "*" || !e.endsWith("*") || e.endsWith("/*"), 'Route path "' + e + '" will be treated as if it were ' + ('"' + e.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + e.replace(/\*$/, "/*") + '".')); let r = [], s = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (o, a, l) => (r.push({ paramName: a, isOptional: l != null }), l ? "/?([^\\/]+)?" : "/([^\\/]+)")); return e.endsWith("*") ? (r.push({ paramName: "*" }), s += e === "*" || e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? s += "\\/*$" : e !== "" && e !== "/" && (s += "(?:(?=\\/|$))"), [new RegExp(s, t ? void 0 : "i"), r] } function KN(e) { try { return e.split("/").map(t => decodeURIComponent(t).replace(/\//g, "%2F")).join("/") } catch (t) { return bx(!1, 'The URL path "' + e + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + t + ").")), e } } function jf(e, t) { if (t === "/") return e; if (!e.toLowerCase().startsWith(t.toLowerCase())) return null; let n = t.endsWith("/") ? t.length - 1 : t.length, r = e.charAt(n); return r && r !== "/" ? null : e.slice(n) || "/" } function YN(e, t) { t === void 0 && (t = "/"); let { pathname: n, search: r = "", hash: s = "" } = typeof e == "string" ? Zs(e) : e; return { pathname: n ? n.startsWith("/") ? n : GN(n, t) : t, search: XN(r), hash: ZN(s) } } function GN(e, t) { let n = t.replace(/\/+$/, "").split("/"); return e.split("/").forEach(s => { s === ".." ? n.length > 1 && n.pop() : s !== "." && n.push(s) }), n.length > 1 ? n.join("/") : "/" } function bc(e, t, n, r) { return "Cannot include a '" + e + "' character in a manually specified " + ("`to." + t + "` field [" + JSON.stringify(r) + "].  Please separate it out to the ") + ("`to." + n + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.' } function QN(e) { return e.filter((t, n) => n === 0 || t.route.path && t.route.path.length > 0) } function kx(e, t) { let n = QN(e); return t ? n.map((r, s) => s === n.length - 1 ? r.pathname : r.pathnameBase) : n.map(r => r.pathnameBase) } function Tx(e, t, n, r) { r === void 0 && (r = !1); let s; typeof e == "string" ? s = Zs(e) : (s = ro({}, e), Ce(!s.pathname || !s.pathname.includes("?"), bc("?", "pathname", "search", s)), Ce(!s.pathname || !s.pathname.includes("#"), bc("#", "pathname", "hash", s)), Ce(!s.search || !s.search.includes("#"), bc("#", "search", "hash", s))); let i = e === "" || s.pathname === "", o = i ? "/" : s.pathname, a; if (o == null) a = n; else { let f = t.length - 1; if (!r && o.startsWith("..")) { let h = o.split("/"); for (; h[0] === "..";)h.shift(), f -= 1; s.pathname = h.join("/") } a = f >= 0 ? t[f] : "/" } let l = YN(s, a), c = o && o !== "/" && o.endsWith("/"), d = (i || o === ".") && n.endsWith("/"); return !l.pathname.endsWith("/") && (c || d) && (l.pathname += "/"), l } const Jn = e => e.join("/").replace(/\/\/+/g, "/"), qN = e => e.replace(/\/+$/, "").replace(/^\/*/, "/"), XN = e => !e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e, ZN = e => !e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e; function JN(e) { return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.internal == "boolean" && "data" in e } const Ex = ["post", "put", "patch", "delete"]; new Set(Ex); const eP = ["get", ...Ex]; new Set(eP);/**
 * React Router v6.30.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function so() { return so = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, so.apply(this, arguments) } const Rf = x.createContext(null), tP = x.createContext(null), Hr = x.createContext(null), Al = x.createContext(null), Kr = x.createContext({ outlet: null, matches: [], isDataRoute: !1 }), Nx = x.createContext(null); function nP(e, t) { let { relative: n } = t === void 0 ? {} : t; bo() || Ce(!1); let { basename: r, navigator: s } = x.useContext(Hr), { hash: i, pathname: o, search: a } = jx(e, { relative: n }), l = o; return r !== "/" && (l = o === "/" ? r : Jn([r, o])), s.createHref({ pathname: l, search: a, hash: i }) } function bo() { return x.useContext(Al) != null } function Js() { return bo() || Ce(!1), x.useContext(Al).location } function Px(e) { x.useContext(Hr).static || x.useLayoutEffect(e) } function rP() { let { isDataRoute: e } = x.useContext(Kr); return e ? gP() : sP() } function sP() { bo() || Ce(!1); let e = x.useContext(Rf), { basename: t, future: n, navigator: r } = x.useContext(Hr), { matches: s } = x.useContext(Kr), { pathname: i } = Js(), o = JSON.stringify(kx(s, n.v7_relativeSplatPath)), a = x.useRef(!1); return Px(() => { a.current = !0 }), x.useCallback(function (c, d) { if (d === void 0 && (d = {}), !a.current) return; if (typeof c == "number") { r.go(c); return } let f = Tx(c, JSON.parse(o), i, d.relative === "path"); e == null && t !== "/" && (f.pathname = f.pathname === "/" ? t : Jn([t, f.pathname])), (d.replace ? r.replace : r.push)(f, d.state, d) }, [t, r, o, i, e]) } function jx(e, t) { let { relative: n } = t === void 0 ? {} : t, { future: r } = x.useContext(Hr), { matches: s } = x.useContext(Kr), { pathname: i } = Js(), o = JSON.stringify(kx(s, r.v7_relativeSplatPath)); return x.useMemo(() => Tx(e, JSON.parse(o), i, n === "path"), [e, o, i, n]) } function iP(e, t) { return oP(e, t) } function oP(e, t, n, r) { bo() || Ce(!1); let { navigator: s } = x.useContext(Hr), { matches: i } = x.useContext(Kr), o = i[i.length - 1], a = o ? o.params : {}; o && o.pathname; let l = o ? o.pathnameBase : "/"; o && o.route; let c = Js(), d; if (t) { var f; let b = typeof t == "string" ? Zs(t) : t; l === "/" || (f = b.pathname) != null && f.startsWith(l) || Ce(!1), d = b } else d = c; let h = d.pathname || "/", p = h; if (l !== "/") { let b = l.replace(/^\//, "").split("/"); p = "/" + h.replace(/^\//, "").split("/").slice(b.length).join("/") } let w = DN(e, { pathname: p }), y = dP(w && w.map(b => Object.assign({}, b, { params: Object.assign({}, a, b.params), pathname: Jn([l, s.encodeLocation ? s.encodeLocation(b.pathname).pathname : b.pathname]), pathnameBase: b.pathnameBase === "/" ? l : Jn([l, s.encodeLocation ? s.encodeLocation(b.pathnameBase).pathname : b.pathnameBase]) })), i, n, r); return t && y ? x.createElement(Al.Provider, { value: { location: so({ pathname: "/", search: "", hash: "", state: null, key: "default" }, d), navigationType: Wn.Pop } }, y) : y } function aP() { let e = mP(), t = JN(e) ? e.status + " " + e.statusText : e instanceof Error ? e.message : JSON.stringify(e), n = e instanceof Error ? e.stack : null, s = { padding: "0.5rem", backgroundColor: "rgba(200,200,200, 0.5)" }; return x.createElement(x.Fragment, null, x.createElement("h2", null, "Unexpected Application Error!"), x.createElement("h3", { style: { fontStyle: "italic" } }, t), n ? x.createElement("pre", { style: s }, n) : null, null) } const lP = x.createElement(aP, null); class cP extends x.Component { constructor(t) { super(t), this.state = { location: t.location, revalidation: t.revalidation, error: t.error } } static getDerivedStateFromError(t) { return { error: t } } static getDerivedStateFromProps(t, n) { return n.location !== t.location || n.revalidation !== "idle" && t.revalidation === "idle" ? { error: t.error, location: t.location, revalidation: t.revalidation } : { error: t.error !== void 0 ? t.error : n.error, location: n.location, revalidation: t.revalidation || n.revalidation } } componentDidCatch(t, n) { console.error("React Router caught the following error during render", t, n) } render() { return this.state.error !== void 0 ? x.createElement(Kr.Provider, { value: this.props.routeContext }, x.createElement(Nx.Provider, { value: this.state.error, children: this.props.component })) : this.props.children } } function uP(e) { let { routeContext: t, match: n, children: r } = e, s = x.useContext(Rf); return s && s.static && s.staticContext && (n.route.errorElement || n.route.ErrorBoundary) && (s.staticContext._deepestRenderedBoundaryId = n.route.id), x.createElement(Kr.Provider, { value: t }, r) } function dP(e, t, n, r) { var s; if (t === void 0 && (t = []), n === void 0 && (n = null), r === void 0 && (r = null), e == null) { var i; if (!n) return null; if (n.errors) e = n.matches; else if ((i = r) != null && i.v7_partialHydration && t.length === 0 && !n.initialized && n.matches.length > 0) e = n.matches; else return null } let o = e, a = (s = n) == null ? void 0 : s.errors; if (a != null) { let d = o.findIndex(f => f.route.id && (a == null ? void 0 : a[f.route.id]) !== void 0); d >= 0 || Ce(!1), o = o.slice(0, Math.min(o.length, d + 1)) } let l = !1, c = -1; if (n && r && r.v7_partialHydration) for (let d = 0; d < o.length; d++) { let f = o[d]; if ((f.route.HydrateFallback || f.route.hydrateFallbackElement) && (c = d), f.route.id) { let { loaderData: h, errors: p } = n, w = f.route.loader && h[f.route.id] === void 0 && (!p || p[f.route.id] === void 0); if (f.route.lazy || w) { l = !0, c >= 0 ? o = o.slice(0, c + 1) : o = [o[0]]; break } } } return o.reduceRight((d, f, h) => { let p, w = !1, y = null, b = null; n && (p = a && f.route.id ? a[f.route.id] : void 0, y = f.route.errorElement || lP, l && (c < 0 && h === 0 ? (w = !0, b = null) : c === h && (w = !0, b = f.route.hydrateFallbackElement || null))); let g = t.concat(o.slice(0, h + 1)), m = () => { let v; return p ? v = y : w ? v = b : f.route.Component ? v = x.createElement(f.route.Component, null) : f.route.element ? v = f.route.element : v = d, x.createElement(uP, { match: f, routeContext: { outlet: d, matches: g, isDataRoute: n != null }, children: v }) }; return n && (f.route.ErrorBoundary || f.route.errorElement || h === 0) ? x.createElement(cP, { location: n.location, revalidation: n.revalidation, component: y, error: p, children: m(), routeContext: { outlet: null, matches: g, isDataRoute: !0 } }) : m() }, null) } var Rx = function (e) { return e.UseBlocker = "useBlocker", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e }(Rx || {}), Xa = function (e) { return e.UseBlocker = "useBlocker", e.UseLoaderData = "useLoaderData", e.UseActionData = "useActionData", e.UseRouteError = "useRouteError", e.UseNavigation = "useNavigation", e.UseRouteLoaderData = "useRouteLoaderData", e.UseMatches = "useMatches", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e.UseRouteId = "useRouteId", e }(Xa || {}); function fP(e) { let t = x.useContext(Rf); return t || Ce(!1), t } function hP(e) { let t = x.useContext(tP); return t || Ce(!1), t } function pP(e) { let t = x.useContext(Kr); return t || Ce(!1), t } function Ax(e) { let t = pP(), n = t.matches[t.matches.length - 1]; return n.route.id || Ce(!1), n.route.id } function mP() { var e; let t = x.useContext(Nx), n = hP(Xa.UseRouteError), r = Ax(Xa.UseRouteError); return t !== void 0 ? t : (e = n.errors) == null ? void 0 : e[r] } function gP() { let { router: e } = fP(Rx.UseNavigateStable), t = Ax(Xa.UseNavigateStable), n = x.useRef(!1); return Px(() => { n.current = !0 }), x.useCallback(function (s, i) { i === void 0 && (i = {}), n.current && (typeof s == "number" ? e.navigate(s) : e.navigate(s, so({ fromRouteId: t }, i))) }, [e, t]) } function yP(e, t) { e == null || e.v7_startTransition, e == null || e.v7_relativeSplatPath } function on(e) { Ce(!1) } function vP(e) { let { basename: t = "/", children: n = null, location: r, navigationType: s = Wn.Pop, navigator: i, static: o = !1, future: a } = e; bo() && Ce(!1); let l = t.replace(/^\/*/, "/"), c = x.useMemo(() => ({ basename: l, navigator: i, static: o, future: so({ v7_relativeSplatPath: !1 }, a) }), [l, a, i, o]); typeof r == "string" && (r = Zs(r)); let { pathname: d = "/", search: f = "", hash: h = "", state: p = null, key: w = "default" } = r, y = x.useMemo(() => { let b = jf(d, l); return b == null ? null : { location: { pathname: b, search: f, hash: h, state: p, key: w }, navigationType: s } }, [l, d, f, h, p, w, s]); return y == null ? null : x.createElement(Hr.Provider, { value: c }, x.createElement(Al.Provider, { children: n, value: y })) } function xP(e) { let { children: t, location: n } = e; return iP(Wu(t), n) } new Promise(() => { }); function Wu(e, t) { t === void 0 && (t = []); let n = []; return x.Children.forEach(e, (r, s) => { if (!x.isValidElement(r)) return; let i = [...t, s]; if (r.type === x.Fragment) { n.push.apply(n, Wu(r.props.children, i)); return } r.type !== on && Ce(!1), !r.props.index || !r.props.children || Ce(!1); let o = { id: r.props.id || i.join("-"), caseSensitive: r.props.caseSensitive, element: r.props.element, Component: r.props.Component, index: r.props.index, path: r.props.path, loader: r.props.loader, action: r.props.action, errorElement: r.props.errorElement, ErrorBoundary: r.props.ErrorBoundary, hasErrorBoundary: r.props.ErrorBoundary != null || r.props.errorElement != null, shouldRevalidate: r.props.shouldRevalidate, handle: r.props.handle, lazy: r.props.lazy }; r.props.children && (o.children = Wu(r.props.children, i)), n.push(o) }), n }/**
 * React Router DOM v6.30.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Hu() { return Hu = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, Hu.apply(this, arguments) } function wP(e, t) { if (e == null) return {}; var n = {}, r = Object.keys(e), s, i; for (i = 0; i < r.length; i++)s = r[i], !(t.indexOf(s) >= 0) && (n[s] = e[s]); return n } function bP(e) { return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) } function SP(e, t) { return e.button === 0 && (!t || t === "_self") && !bP(e) } const CP = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"], kP = "6"; try { window.__reactRouterVersion = kP } catch { } const TP = "startTransition", am = Yg[TP]; function EP(e) { let { basename: t, children: n, future: r, window: s } = e, i = x.useRef(); i.current == null && (i.current = RN({ window: s, v5Compat: !0 })); let o = i.current, [a, l] = x.useState({ action: o.action, location: o.location }), { v7_startTransition: c } = r || {}, d = x.useCallback(f => { c && am ? am(() => l(f)) : l(f) }, [l, c]); return x.useLayoutEffect(() => o.listen(d), [o, d]), x.useEffect(() => yP(r), [r]), x.createElement(vP, { basename: t, children: n, location: a.location, navigationType: a.action, navigator: o, future: r }) } const NP = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", PP = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, fe = x.forwardRef(function (t, n) { let { onClick: r, relative: s, reloadDocument: i, replace: o, state: a, target: l, to: c, preventScrollReset: d, viewTransition: f } = t, h = wP(t, CP), { basename: p } = x.useContext(Hr), w, y = !1; if (typeof c == "string" && PP.test(c) && (w = c, NP)) try { let v = new URL(window.location.href), S = c.startsWith("//") ? new URL(v.protocol + c) : new URL(c), C = jf(S.pathname, p); S.origin === v.origin && C != null ? c = C + S.search + S.hash : y = !0 } catch { } let b = nP(c, { relative: s }), g = jP(c, { replace: o, state: a, target: l, preventScrollReset: d, relative: s, viewTransition: f }); function m(v) { r && r(v), v.defaultPrevented || g(v) } return x.createElement("a", Hu({}, h, { href: w || b, onClick: y || i ? r : m, ref: n, target: l })) }); var lm; (function (e) { e.UseScrollRestoration = "useScrollRestoration", e.UseSubmit = "useSubmit", e.UseSubmitFetcher = "useSubmitFetcher", e.UseFetcher = "useFetcher", e.useViewTransitionState = "useViewTransitionState" })(lm || (lm = {})); var cm; (function (e) { e.UseFetcher = "useFetcher", e.UseFetchers = "useFetchers", e.UseScrollRestoration = "useScrollRestoration" })(cm || (cm = {})); function jP(e, t) { let { target: n, replace: r, state: s, preventScrollReset: i, relative: o, viewTransition: a } = t === void 0 ? {} : t, l = rP(), c = Js(), d = jx(e, { relative: o }); return x.useCallback(f => { if (SP(f, n)) { f.preventDefault(); let h = r !== void 0 ? r : qa(c) === qa(d); l(e, { replace: h, state: s, preventScrollReset: i, relative: o, viewTransition: a }) } }, [c, l, d, r, s, n, e, i, o, a]) } const Af = x.createContext({}); function Mf(e) { const t = x.useRef(null); return t.current === null && (t.current = e()), t.current } const Df = typeof window < "u", Mx = Df ? x.useLayoutEffect : x.useEffect, Ml = x.createContext(null); function Lf(e, t) { e.indexOf(t) === -1 && e.push(t) } function Of(e, t) { const n = e.indexOf(t); n > -1 && e.splice(n, 1) } const xn = (e, t, n) => n > t ? t : n < e ? e : n; let Za = () => { }; const wn = {}, Dx = e => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e); function Lx(e) { return typeof e == "object" && e !== null } const Ox = e => /^0[^.\s]+$/u.test(e); function If(e) { let t; return () => (t === void 0 && (t = e()), t) } const wt = e => e, RP = (e, t) => n => t(e(n)), So = (...e) => e.reduce(RP), io = (e, t, n) => { const r = t - e; return r === 0 ? 1 : (n - e) / r }; class Ff { constructor() { this.subscriptions = [] } add(t) { return Lf(this.subscriptions, t), () => Of(this.subscriptions, t) } notify(t, n, r) { const s = this.subscriptions.length; if (s) if (s === 1) this.subscriptions[0](t, n, r); else for (let i = 0; i < s; i++) { const o = this.subscriptions[i]; o && o(t, n, r) } } getSize() { return this.subscriptions.length } clear() { this.subscriptions.length = 0 } } const Jt = e => e * 1e3, vt = e => e / 1e3; function Ix(e, t) { return t ? e * (1e3 / t) : 0 } const Fx = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e, AP = 1e-7, MP = 12; function DP(e, t, n, r, s) { let i, o, a = 0; do o = t + (n - t) / 2, i = Fx(o, r, s) - e, i > 0 ? n = o : t = o; while (Math.abs(i) > AP && ++a < MP); return o } function Co(e, t, n, r) { if (e === t && n === r) return wt; const s = i => DP(i, 0, 1, e, n); return i => i === 0 || i === 1 ? i : Fx(s(i), t, r) } const Vx = e => t => t <= .5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2, _x = e => t => 1 - e(1 - t), zx = Co(.33, 1.53, .69, .99), Vf = _x(zx), Bx = Vx(Vf), $x = e => (e *= 2) < 1 ? .5 * Vf(e) : .5 * (2 - Math.pow(2, -10 * (e - 1))), _f = e => 1 - Math.sin(Math.acos(e)), Ux = _x(_f), Wx = Vx(_f), LP = Co(.42, 0, 1, 1), OP = Co(0, 0, .58, 1), Hx = Co(.42, 0, .58, 1), IP = e => Array.isArray(e) && typeof e[0] != "number", Kx = e => Array.isArray(e) && typeof e[0] == "number", um = { linear: wt, easeIn: LP, easeInOut: Hx, easeOut: OP, circIn: _f, circInOut: Wx, circOut: Ux, backIn: Vf, backInOut: Bx, backOut: zx, anticipate: $x }, FP = e => typeof e == "string", dm = e => { if (Kx(e)) { Za(e.length === 4); const [t, n, r, s] = e; return Co(t, n, r, s) } else if (FP(e)) return Za(um[e] !== void 0), um[e]; return e }, Zo = ["setup", "read", "resolveKeyframes", "preUpdate", "update", "preRender", "render", "postRender"], fm = { value: null, addProjectionMetrics: null }; function VP(e, t) { let n = new Set, r = new Set, s = !1, i = !1; const o = new WeakSet; let a = { delta: 0, timestamp: 0, isProcessing: !1 }, l = 0; function c(f) { o.has(f) && (d.schedule(f), e()), l++, f(a) } const d = { schedule: (f, h = !1, p = !1) => { const y = p && s ? n : r; return h && o.add(f), y.has(f) || y.add(f), f }, cancel: f => { r.delete(f), o.delete(f) }, process: f => { if (a = f, s) { i = !0; return } s = !0, [n, r] = [r, n], n.forEach(c), t && fm.value && fm.value.frameloop[t].push(l), l = 0, n.clear(), s = !1, i && (i = !1, d.process(f)) } }; return d } const _P = 40; function Yx(e, t) { let n = !1, r = !0; const s = { delta: 0, timestamp: 0, isProcessing: !1 }, i = () => n = !0, o = Zo.reduce((v, S) => (v[S] = VP(i, t ? S : void 0), v), {}), { setup: a, read: l, resolveKeyframes: c, preUpdate: d, update: f, preRender: h, render: p, postRender: w } = o, y = () => { const v = wn.useManualTiming ? s.timestamp : performance.now(); n = !1, wn.useManualTiming || (s.delta = r ? 1e3 / 60 : Math.max(Math.min(v - s.timestamp, _P), 1)), s.timestamp = v, s.isProcessing = !0, a.process(s), l.process(s), c.process(s), d.process(s), f.process(s), h.process(s), p.process(s), w.process(s), s.isProcessing = !1, n && t && (r = !1, e(y)) }, b = () => { n = !0, r = !0, s.isProcessing || e(y) }; return { schedule: Zo.reduce((v, S) => { const C = o[S]; return v[S] = (k, T = !1, E = !1) => (n || b(), C.schedule(k, T, E)), v }, {}), cancel: v => { for (let S = 0; S < Zo.length; S++)o[Zo[S]].cancel(v) }, state: s, steps: o } } const { schedule: ue, cancel: or, state: Me, steps: Sc } = Yx(typeof requestAnimationFrame < "u" ? requestAnimationFrame : wt, !0); let ya; function zP() { ya = void 0 } const Je = { now: () => (ya === void 0 && Je.set(Me.isProcessing || wn.useManualTiming ? Me.timestamp : performance.now()), ya), set: e => { ya = e, queueMicrotask(zP) } }, Gx = e => t => typeof t == "string" && t.startsWith(e), Qx = Gx("--"), BP = Gx("var(--"), zf = e => BP(e) ? $P.test(e.split("/*")[0].trim()) : !1, $P = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, ei = { test: e => typeof e == "number", parse: parseFloat, transform: e => e }, oo = { ...ei, transform: e => xn(0, 1, e) }, Jo = { ...ei, default: 1 }, Ai = e => Math.round(e * 1e5) / 1e5, Bf = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu; function UP(e) { return e == null } const WP = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, $f = (e, t) => n => !!(typeof n == "string" && WP.test(n) && n.startsWith(e) || t && !UP(n) && Object.prototype.hasOwnProperty.call(n, t)), qx = (e, t, n) => r => { if (typeof r != "string") return r; const [s, i, o, a] = r.match(Bf); return { [e]: parseFloat(s), [t]: parseFloat(i), [n]: parseFloat(o), alpha: a !== void 0 ? parseFloat(a) : 1 } }, HP = e => xn(0, 255, e), Cc = { ...ei, transform: e => Math.round(HP(e)) }, Cr = { test: $f("rgb", "red"), parse: qx("red", "green", "blue"), transform: ({ red: e, green: t, blue: n, alpha: r = 1 }) => "rgba(" + Cc.transform(e) + ", " + Cc.transform(t) + ", " + Cc.transform(n) + ", " + Ai(oo.transform(r)) + ")" }; function KP(e) { let t = "", n = "", r = "", s = ""; return e.length > 5 ? (t = e.substring(1, 3), n = e.substring(3, 5), r = e.substring(5, 7), s = e.substring(7, 9)) : (t = e.substring(1, 2), n = e.substring(2, 3), r = e.substring(3, 4), s = e.substring(4, 5), t += t, n += n, r += r, s += s), { red: parseInt(t, 16), green: parseInt(n, 16), blue: parseInt(r, 16), alpha: s ? parseInt(s, 16) / 255 : 1 } } const Ku = { test: $f("#"), parse: KP, transform: Cr.transform }, ko = e => ({ test: t => typeof t == "string" && t.endsWith(e) && t.split(" ").length === 1, parse: parseFloat, transform: t => `${t}${e}` }), Mn = ko("deg"), en = ko("%"), B = ko("px"), YP = ko("vh"), GP = ko("vw"), hm = { ...en, parse: e => en.parse(e) / 100, transform: e => en.transform(e * 100) }, fs = { test: $f("hsl", "hue"), parse: qx("hue", "saturation", "lightness"), transform: ({ hue: e, saturation: t, lightness: n, alpha: r = 1 }) => "hsla(" + Math.round(e) + ", " + en.transform(Ai(t)) + ", " + en.transform(Ai(n)) + ", " + Ai(oo.transform(r)) + ")" }, be = { test: e => Cr.test(e) || Ku.test(e) || fs.test(e), parse: e => Cr.test(e) ? Cr.parse(e) : fs.test(e) ? fs.parse(e) : Ku.parse(e), transform: e => typeof e == "string" ? e : e.hasOwnProperty("red") ? Cr.transform(e) : fs.transform(e), getAnimatableNone: e => { const t = be.parse(e); return t.alpha = 0, be.transform(t) } }, QP = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu; function qP(e) { var t, n; return isNaN(e) && typeof e == "string" && (((t = e.match(Bf)) == null ? void 0 : t.length) || 0) + (((n = e.match(QP)) == null ? void 0 : n.length) || 0) > 0 } const Xx = "number", Zx = "color", XP = "var", ZP = "var(", pm = "${}", JP = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu; function ao(e) { const t = e.toString(), n = [], r = { color: [], number: [], var: [] }, s = []; let i = 0; const a = t.replace(JP, l => (be.test(l) ? (r.color.push(i), s.push(Zx), n.push(be.parse(l))) : l.startsWith(ZP) ? (r.var.push(i), s.push(XP), n.push(l)) : (r.number.push(i), s.push(Xx), n.push(parseFloat(l))), ++i, pm)).split(pm); return { values: n, split: a, indexes: r, types: s } } function Jx(e) { return ao(e).values } function ew(e) { const { split: t, types: n } = ao(e), r = t.length; return s => { let i = ""; for (let o = 0; o < r; o++)if (i += t[o], s[o] !== void 0) { const a = n[o]; a === Xx ? i += Ai(s[o]) : a === Zx ? i += be.transform(s[o]) : i += s[o] } return i } } const e2 = e => typeof e == "number" ? 0 : be.test(e) ? be.getAnimatableNone(e) : e; function t2(e) { const t = Jx(e); return ew(e)(t.map(e2)) } const ar = { test: qP, parse: Jx, createTransformer: ew, getAnimatableNone: t2 }; function kc(e, t, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e } function n2({ hue: e, saturation: t, lightness: n, alpha: r }) { e /= 360, t /= 100, n /= 100; let s = 0, i = 0, o = 0; if (!t) s = i = o = n; else { const a = n < .5 ? n * (1 + t) : n + t - n * t, l = 2 * n - a; s = kc(l, a, e + 1 / 3), i = kc(l, a, e), o = kc(l, a, e - 1 / 3) } return { red: Math.round(s * 255), green: Math.round(i * 255), blue: Math.round(o * 255), alpha: r } } function Ja(e, t) { return n => n > 0 ? t : e } const he = (e, t, n) => e + (t - e) * n, Tc = (e, t, n) => { const r = e * e, s = n * (t * t - r) + r; return s < 0 ? 0 : Math.sqrt(s) }, r2 = [Ku, Cr, fs], s2 = e => r2.find(t => t.test(e)); function mm(e) { const t = s2(e); if (!t) return !1; let n = t.parse(e); return t === fs && (n = n2(n)), n } const gm = (e, t) => { const n = mm(e), r = mm(t); if (!n || !r) return Ja(e, t); const s = { ...n }; return i => (s.red = Tc(n.red, r.red, i), s.green = Tc(n.green, r.green, i), s.blue = Tc(n.blue, r.blue, i), s.alpha = he(n.alpha, r.alpha, i), Cr.transform(s)) }, Yu = new Set(["none", "hidden"]); function i2(e, t) { return Yu.has(e) ? n => n <= 0 ? e : t : n => n >= 1 ? t : e } function o2(e, t) { return n => he(e, t, n) } function Uf(e) { return typeof e == "number" ? o2 : typeof e == "string" ? zf(e) ? Ja : be.test(e) ? gm : c2 : Array.isArray(e) ? tw : typeof e == "object" ? be.test(e) ? gm : a2 : Ja } function tw(e, t) { const n = [...e], r = n.length, s = e.map((i, o) => Uf(i)(i, t[o])); return i => { for (let o = 0; o < r; o++)n[o] = s[o](i); return n } } function a2(e, t) { const n = { ...e, ...t }, r = {}; for (const s in n) e[s] !== void 0 && t[s] !== void 0 && (r[s] = Uf(e[s])(e[s], t[s])); return s => { for (const i in r) n[i] = r[i](s); return n } } function l2(e, t) { const n = [], r = { color: 0, var: 0, number: 0 }; for (let s = 0; s < t.values.length; s++) { const i = t.types[s], o = e.indexes[i][r[i]], a = e.values[o] ?? 0; n[s] = a, r[i]++ } return n } const c2 = (e, t) => { const n = ar.createTransformer(t), r = ao(e), s = ao(t); return r.indexes.var.length === s.indexes.var.length && r.indexes.color.length === s.indexes.color.length && r.indexes.number.length >= s.indexes.number.length ? Yu.has(e) && !s.values.length || Yu.has(t) && !r.values.length ? i2(e, t) : So(tw(l2(r, s), s.values), n) : Ja(e, t) }; function nw(e, t, n) { return typeof e == "number" && typeof t == "number" && typeof n == "number" ? he(e, t, n) : Uf(e)(e, t) } const u2 = e => { const t = ({ timestamp: n }) => e(n); return { start: (n = !0) => ue.update(t, n), stop: () => or(t), now: () => Me.isProcessing ? Me.timestamp : Je.now() } }, rw = (e, t, n = 10) => { let r = ""; const s = Math.max(Math.round(t / n), 2); for (let i = 0; i < s; i++)r += Math.round(e(i / (s - 1)) * 1e4) / 1e4 + ", "; return `linear(${r.substring(0, r.length - 2)})` }, el = 2e4; function Wf(e) { let t = 0; const n = 50; let r = e.next(t); for (; !r.done && t < el;)t += n, r = e.next(t); return t >= el ? 1 / 0 : t } function d2(e, t = 100, n) { const r = n({ ...e, keyframes: [0, t] }), s = Math.min(Wf(r), el); return { type: "keyframes", ease: i => r.next(s * i).value / t, duration: vt(s) } } const f2 = 5; function sw(e, t, n) { const r = Math.max(t - f2, 0); return Ix(n - e(r), t - r) } const ye = { stiffness: 100, damping: 10, mass: 1, velocity: 0, duration: 800, bounce: .3, visualDuration: .3, restSpeed: { granular: .01, default: 2 }, restDelta: { granular: .005, default: .5 }, minDuration: .01, maxDuration: 10, minDamping: .05, maxDamping: 1 }, Ec = .001; function h2({ duration: e = ye.duration, bounce: t = ye.bounce, velocity: n = ye.velocity, mass: r = ye.mass }) { let s, i, o = 1 - t; o = xn(ye.minDamping, ye.maxDamping, o), e = xn(ye.minDuration, ye.maxDuration, vt(e)), o < 1 ? (s = c => { const d = c * o, f = d * e, h = d - n, p = Gu(c, o), w = Math.exp(-f); return Ec - h / p * w }, i = c => { const f = c * o * e, h = f * n + n, p = Math.pow(o, 2) * Math.pow(c, 2) * e, w = Math.exp(-f), y = Gu(Math.pow(c, 2), o); return (-s(c) + Ec > 0 ? -1 : 1) * ((h - p) * w) / y }) : (s = c => { const d = Math.exp(-c * e), f = (c - n) * e + 1; return -Ec + d * f }, i = c => { const d = Math.exp(-c * e), f = (n - c) * (e * e); return d * f }); const a = 5 / e, l = m2(s, i, a); if (e = Jt(e), isNaN(l)) return { stiffness: ye.stiffness, damping: ye.damping, duration: e }; { const c = Math.pow(l, 2) * r; return { stiffness: c, damping: o * 2 * Math.sqrt(r * c), duration: e } } } const p2 = 12; function m2(e, t, n) { let r = n; for (let s = 1; s < p2; s++)r = r - e(r) / t(r); return r } function Gu(e, t) { return e * Math.sqrt(1 - t * t) } const g2 = ["duration", "bounce"], y2 = ["stiffness", "damping", "mass"]; function ym(e, t) { return t.some(n => e[n] !== void 0) } function v2(e) { let t = { velocity: ye.velocity, stiffness: ye.stiffness, damping: ye.damping, mass: ye.mass, isResolvedFromDuration: !1, ...e }; if (!ym(e, y2) && ym(e, g2)) if (e.visualDuration) { const n = e.visualDuration, r = 2 * Math.PI / (n * 1.2), s = r * r, i = 2 * xn(.05, 1, 1 - (e.bounce || 0)) * Math.sqrt(s); t = { ...t, mass: ye.mass, stiffness: s, damping: i } } else { const n = h2(e); t = { ...t, ...n, mass: ye.mass }, t.isResolvedFromDuration = !0 } return t } function tl(e = ye.visualDuration, t = ye.bounce) { const n = typeof e != "object" ? { visualDuration: e, keyframes: [0, 1], bounce: t } : e; let { restSpeed: r, restDelta: s } = n; const i = n.keyframes[0], o = n.keyframes[n.keyframes.length - 1], a = { done: !1, value: i }, { stiffness: l, damping: c, mass: d, duration: f, velocity: h, isResolvedFromDuration: p } = v2({ ...n, velocity: -vt(n.velocity || 0) }), w = h || 0, y = c / (2 * Math.sqrt(l * d)), b = o - i, g = vt(Math.sqrt(l / d)), m = Math.abs(b) < 5; r || (r = m ? ye.restSpeed.granular : ye.restSpeed.default), s || (s = m ? ye.restDelta.granular : ye.restDelta.default); let v; if (y < 1) { const C = Gu(g, y); v = k => { const T = Math.exp(-y * g * k); return o - T * ((w + y * g * b) / C * Math.sin(C * k) + b * Math.cos(C * k)) } } else if (y === 1) v = C => o - Math.exp(-g * C) * (b + (w + g * b) * C); else { const C = g * Math.sqrt(y * y - 1); v = k => { const T = Math.exp(-y * g * k), E = Math.min(C * k, 300); return o - T * ((w + y * g * b) * Math.sinh(E) + C * b * Math.cosh(E)) / C } } const S = { calculatedDuration: p && f || null, next: C => { const k = v(C); if (p) a.done = C >= f; else { let T = C === 0 ? w : 0; y < 1 && (T = C === 0 ? Jt(w) : sw(v, C, k)); const E = Math.abs(T) <= r, A = Math.abs(o - k) <= s; a.done = E && A } return a.value = a.done ? o : k, a }, toString: () => { const C = Math.min(Wf(S), el), k = rw(T => S.next(C * T).value, C, 30); return C + "ms " + k }, toTransition: () => { } }; return S } tl.applyToOptions = e => { const t = d2(e, 100, tl); return e.ease = t.ease, e.duration = Jt(t.duration), e.type = "keyframes", e }; function Qu({ keyframes: e, velocity: t = 0, power: n = .8, timeConstant: r = 325, bounceDamping: s = 10, bounceStiffness: i = 500, modifyTarget: o, min: a, max: l, restDelta: c = .5, restSpeed: d }) { const f = e[0], h = { done: !1, value: f }, p = E => a !== void 0 && E < a || l !== void 0 && E > l, w = E => a === void 0 ? l : l === void 0 || Math.abs(a - E) < Math.abs(l - E) ? a : l; let y = n * t; const b = f + y, g = o === void 0 ? b : o(b); g !== b && (y = g - f); const m = E => -y * Math.exp(-E / r), v = E => g + m(E), S = E => { const A = m(E), R = v(E); h.done = Math.abs(A) <= c, h.value = h.done ? g : R }; let C, k; const T = E => { p(h.value) && (C = E, k = tl({ keyframes: [h.value, w(h.value)], velocity: sw(v, E, h.value), damping: s, stiffness: i, restDelta: c, restSpeed: d })) }; return T(0), { calculatedDuration: null, next: E => { let A = !1; return !k && C === void 0 && (A = !0, S(E), T(E)), C !== void 0 && E >= C ? k.next(E - C) : (!A && S(E), h) } } } function x2(e, t, n) { const r = [], s = n || wn.mix || nw, i = e.length - 1; for (let o = 0; o < i; o++) { let a = s(e[o], e[o + 1]); if (t) { const l = Array.isArray(t) ? t[o] || wt : t; a = So(l, a) } r.push(a) } return r } function w2(e, t, { clamp: n = !0, ease: r, mixer: s } = {}) { const i = e.length; if (Za(i === t.length), i === 1) return () => t[0]; if (i === 2 && t[0] === t[1]) return () => t[1]; const o = e[0] === e[1]; e[0] > e[i - 1] && (e = [...e].reverse(), t = [...t].reverse()); const a = x2(t, r, s), l = a.length, c = d => { if (o && d < e[0]) return t[0]; let f = 0; if (l > 1) for (; f < e.length - 2 && !(d < e[f + 1]); f++); const h = io(e[f], e[f + 1], d); return a[f](h) }; return n ? d => c(xn(e[0], e[i - 1], d)) : c } function b2(e, t) { const n = e[e.length - 1]; for (let r = 1; r <= t; r++) { const s = io(0, t, r); e.push(he(n, 1, s)) } } function S2(e) { const t = [0]; return b2(t, e.length - 1), t } function C2(e, t) { return e.map(n => n * t) } function k2(e, t) { return e.map(() => t || Hx).splice(0, e.length - 1) } function Mi({ duration: e = 300, keyframes: t, times: n, ease: r = "easeInOut" }) { const s = IP(r) ? r.map(dm) : dm(r), i = { done: !1, value: t[0] }, o = C2(n && n.length === t.length ? n : S2(t), e), a = w2(o, t, { ease: Array.isArray(s) ? s : k2(t, s) }); return { calculatedDuration: e, next: l => (i.value = a(l), i.done = l >= e, i) } } const T2 = e => e !== null; function Hf(e, { repeat: t, repeatType: n = "loop" }, r, s = 1) { const i = e.filter(T2), a = s < 0 || t && n !== "loop" && t % 2 === 1 ? 0 : i.length - 1; return !a || r === void 0 ? i[a] : r } const E2 = { decay: Qu, inertia: Qu, tween: Mi, keyframes: Mi, spring: tl }; function iw(e) { typeof e.type == "string" && (e.type = E2[e.type]) } class Kf { constructor() { this.updateFinished() } get finished() { return this._finished } updateFinished() { this._finished = new Promise(t => { this.resolve = t }) } notifyFinished() { this.resolve() } then(t, n) { return this.finished.then(t, n) } } const N2 = e => e / 100; class Yf extends Kf { constructor(t) { super(), this.state = "idle", this.startTime = null, this.isStopped = !1, this.currentTime = 0, this.holdTime = null, this.playbackSpeed = 1, this.stop = () => { var r, s; const { motionValue: n } = this.options; n && n.updatedAt !== Je.now() && this.tick(Je.now()), this.isStopped = !0, this.state !== "idle" && (this.teardown(), (s = (r = this.options).onStop) == null || s.call(r)) }, this.options = t, this.initAnimation(), this.play(), t.autoplay === !1 && this.pause() } initAnimation() { const { options: t } = this; iw(t); const { type: n = Mi, repeat: r = 0, repeatDelay: s = 0, repeatType: i, velocity: o = 0 } = t; let { keyframes: a } = t; const l = n || Mi; l !== Mi && typeof a[0] != "number" && (this.mixKeyframes = So(N2, nw(a[0], a[1])), a = [0, 100]); const c = l({ ...t, keyframes: a }); i === "mirror" && (this.mirroredGenerator = l({ ...t, keyframes: [...a].reverse(), velocity: -o })), c.calculatedDuration === null && (c.calculatedDuration = Wf(c)); const { calculatedDuration: d } = c; this.calculatedDuration = d, this.resolvedDuration = d + s, this.totalDuration = this.resolvedDuration * (r + 1) - s, this.generator = c } updateTime(t) { const n = Math.round(t - this.startTime) * this.playbackSpeed; this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = n } tick(t, n = !1) { const { generator: r, totalDuration: s, mixKeyframes: i, mirroredGenerator: o, resolvedDuration: a, calculatedDuration: l } = this; if (this.startTime === null) return r.next(0); const { delay: c = 0, keyframes: d, repeat: f, repeatType: h, repeatDelay: p, type: w, onUpdate: y, finalKeyframe: b } = this.options; this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - s / this.speed, this.startTime)), n ? this.currentTime = t : this.updateTime(t); const g = this.currentTime - c * (this.playbackSpeed >= 0 ? 1 : -1), m = this.playbackSpeed >= 0 ? g < 0 : g > s; this.currentTime = Math.max(g, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = s); let v = this.currentTime, S = r; if (f) { const E = Math.min(this.currentTime, s) / a; let A = Math.floor(E), R = E % 1; !R && E >= 1 && (R = 1), R === 1 && A--, A = Math.min(A, f + 1), !!(A % 2) && (h === "reverse" ? (R = 1 - R, p && (R -= p / a)) : h === "mirror" && (S = o)), v = xn(0, 1, R) * a } const C = m ? { done: !1, value: d[0] } : S.next(v); i && (C.value = i(C.value)); let { done: k } = C; !m && l !== null && (k = this.playbackSpeed >= 0 ? this.currentTime >= s : this.currentTime <= 0); const T = this.holdTime === null && (this.state === "finished" || this.state === "running" && k); return T && w !== Qu && (C.value = Hf(d, this.options, b, this.speed)), y && y(C.value), T && this.finish(), C } then(t, n) { return this.finished.then(t, n) } get duration() { return vt(this.calculatedDuration) } get iterationDuration() { const { delay: t = 0 } = this.options || {}; return this.duration + vt(t) } get time() { return vt(this.currentTime) } set time(t) { var n; t = Jt(t), this.currentTime = t, this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.playbackSpeed), (n = this.driver) == null || n.start(!1) } get speed() { return this.playbackSpeed } set speed(t) { this.updateTime(Je.now()); const n = this.playbackSpeed !== t; this.playbackSpeed = t, n && (this.time = vt(this.currentTime)) } play() { var s, i; if (this.isStopped) return; const { driver: t = u2, startTime: n } = this.options; this.driver || (this.driver = t(o => this.tick(o))), (i = (s = this.options).onPlay) == null || i.call(s); const r = this.driver.now(); this.state === "finished" ? (this.updateFinished(), this.startTime = r) : this.holdTime !== null ? this.startTime = r - this.holdTime : this.startTime || (this.startTime = n ?? r), this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration), this.holdTime = null, this.state = "running", this.driver.start() } pause() { this.state = "paused", this.updateTime(Je.now()), this.holdTime = this.currentTime } complete() { this.state !== "running" && this.play(), this.state = "finished", this.holdTime = null } finish() { var t, n; this.notifyFinished(), this.teardown(), this.state = "finished", (n = (t = this.options).onComplete) == null || n.call(t) } cancel() { var t, n; this.holdTime = null, this.startTime = 0, this.tick(0), this.teardown(), (n = (t = this.options).onCancel) == null || n.call(t) } teardown() { this.state = "idle", this.stopDriver(), this.startTime = this.holdTime = null } stopDriver() { this.driver && (this.driver.stop(), this.driver = void 0) } sample(t) { return this.startTime = 0, this.tick(t, !0) } attachTimeline(t) { var n; return this.options.allowFlatten && (this.options.type = "keyframes", this.options.ease = "linear", this.initAnimation()), (n = this.driver) == null || n.stop(), t.observe(this) } } function P2(e) { for (let t = 1; t < e.length; t++)e[t] ?? (e[t] = e[t - 1]) } const kr = e => e * 180 / Math.PI, qu = e => { const t = kr(Math.atan2(e[1], e[0])); return Xu(t) }, j2 = { x: 4, y: 5, translateX: 4, translateY: 5, scaleX: 0, scaleY: 3, scale: e => (Math.abs(e[0]) + Math.abs(e[3])) / 2, rotate: qu, rotateZ: qu, skewX: e => kr(Math.atan(e[1])), skewY: e => kr(Math.atan(e[2])), skew: e => (Math.abs(e[1]) + Math.abs(e[2])) / 2 }, Xu = e => (e = e % 360, e < 0 && (e += 360), e), vm = qu, xm = e => Math.sqrt(e[0] * e[0] + e[1] * e[1]), wm = e => Math.sqrt(e[4] * e[4] + e[5] * e[5]), R2 = { x: 12, y: 13, z: 14, translateX: 12, translateY: 13, translateZ: 14, scaleX: xm, scaleY: wm, scale: e => (xm(e) + wm(e)) / 2, rotateX: e => Xu(kr(Math.atan2(e[6], e[5]))), rotateY: e => Xu(kr(Math.atan2(-e[2], e[0]))), rotateZ: vm, rotate: vm, skewX: e => kr(Math.atan(e[4])), skewY: e => kr(Math.atan(e[1])), skew: e => (Math.abs(e[1]) + Math.abs(e[4])) / 2 }; function Zu(e) { return e.includes("scale") ? 1 : 0 } function Ju(e, t) { if (!e || e === "none") return Zu(t); const n = e.match(/^matrix3d\(([-\d.e\s,]+)\)$/u); let r, s; if (n) r = R2, s = n; else { const a = e.match(/^matrix\(([-\d.e\s,]+)\)$/u); r = j2, s = a } if (!s) return Zu(t); const i = r[t], o = s[1].split(",").map(M2); return typeof i == "function" ? i(o) : o[i] } const A2 = (e, t) => { const { transform: n = "none" } = getComputedStyle(e); return Ju(n, t) }; function M2(e) { return parseFloat(e.trim()) } const ti = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], ni = new Set(ti), bm = e => e === ei || e === B, D2 = new Set(["x", "y", "z"]), L2 = ti.filter(e => !D2.has(e)); function O2(e) { const t = []; return L2.forEach(n => { const r = e.getValue(n); r !== void 0 && (t.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0)) }), t } const Dr = { width: ({ x: e }, { paddingLeft: t = "0", paddingRight: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n), height: ({ y: e }, { paddingTop: t = "0", paddingBottom: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n), top: (e, { top: t }) => parseFloat(t), left: (e, { left: t }) => parseFloat(t), bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min), right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min), x: (e, { transform: t }) => Ju(t, "x"), y: (e, { transform: t }) => Ju(t, "y") }; Dr.translateX = Dr.x; Dr.translateY = Dr.y; const Lr = new Set; let ed = !1, td = !1, nd = !1; function ow() { if (td) { const e = Array.from(Lr).filter(r => r.needsMeasurement), t = new Set(e.map(r => r.element)), n = new Map; t.forEach(r => { const s = O2(r); s.length && (n.set(r, s), r.render()) }), e.forEach(r => r.measureInitialState()), t.forEach(r => { r.render(); const s = n.get(r); s && s.forEach(([i, o]) => { var a; (a = r.getValue(i)) == null || a.set(o) }) }), e.forEach(r => r.measureEndState()), e.forEach(r => { r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY) }) } td = !1, ed = !1, Lr.forEach(e => e.complete(nd)), Lr.clear() } function aw() { Lr.forEach(e => { e.readKeyframes(), e.needsMeasurement && (td = !0) }) } function I2() { nd = !0, aw(), ow(), nd = !1 } class Gf { constructor(t, n, r, s, i, o = !1) { this.state = "pending", this.isAsync = !1, this.needsMeasurement = !1, this.unresolvedKeyframes = [...t], this.onComplete = n, this.name = r, this.motionValue = s, this.element = i, this.isAsync = o } scheduleResolve() { this.state = "scheduled", this.isAsync ? (Lr.add(this), ed || (ed = !0, ue.read(aw), ue.resolveKeyframes(ow))) : (this.readKeyframes(), this.complete()) } readKeyframes() { const { unresolvedKeyframes: t, name: n, element: r, motionValue: s } = this; if (t[0] === null) { const i = s == null ? void 0 : s.get(), o = t[t.length - 1]; if (i !== void 0) t[0] = i; else if (r && n) { const a = r.readValue(n, o); a != null && (t[0] = a) } t[0] === void 0 && (t[0] = o), s && i === void 0 && s.set(t[0]) } P2(t) } setFinalKeyframe() { } measureInitialState() { } renderEndStyles() { } measureEndState() { } complete(t = !1) { this.state = "complete", this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, t), Lr.delete(this) } cancel() { this.state === "scheduled" && (Lr.delete(this), this.state = "pending") } resume() { this.state === "pending" && this.scheduleResolve() } } const F2 = e => e.startsWith("--"); function V2(e, t, n) { F2(t) ? e.style.setProperty(t, n) : e.style[t] = n } const _2 = If(() => window.ScrollTimeline !== void 0), z2 = {}; function B2(e, t) { const n = If(e); return () => z2[t] ?? n() } const lw = B2(() => { try { document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" }) } catch { return !1 } return !0 }, "linearEasing"), wi = ([e, t, n, r]) => `cubic-bezier(${e}, ${t}, ${n}, ${r})`, Sm = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: wi([0, .65, .55, 1]), circOut: wi([.55, 0, 1, .45]), backIn: wi([.31, .01, .66, -.59]), backOut: wi([.33, 1.53, .69, .99]) }; function cw(e, t) { if (e) return typeof e == "function" ? lw() ? rw(e, t) : "ease-out" : Kx(e) ? wi(e) : Array.isArray(e) ? e.map(n => cw(n, t) || Sm.easeOut) : Sm[e] } function $2(e, t, n, { delay: r = 0, duration: s = 300, repeat: i = 0, repeatType: o = "loop", ease: a = "easeOut", times: l } = {}, c = void 0) { const d = { [t]: n }; l && (d.offset = l); const f = cw(a, s); Array.isArray(f) && (d.easing = f); const h = { delay: r, duration: s, easing: Array.isArray(f) ? "linear" : f, fill: "both", iterations: i + 1, direction: o === "reverse" ? "alternate" : "normal" }; return c && (h.pseudoElement = c), e.animate(d, h) } function uw(e) { return typeof e == "function" && "applyToOptions" in e } function U2({ type: e, ...t }) { return uw(e) && lw() ? e.applyToOptions(t) : (t.duration ?? (t.duration = 300), t.ease ?? (t.ease = "easeOut"), t) } class W2 extends Kf { constructor(t) { if (super(), this.finishedTime = null, this.isStopped = !1, !t) return; const { element: n, name: r, keyframes: s, pseudoElement: i, allowFlatten: o = !1, finalKeyframe: a, onComplete: l } = t; this.isPseudoElement = !!i, this.allowFlatten = o, this.options = t, Za(typeof t.type != "string"); const c = U2(t); this.animation = $2(n, r, s, c, i), c.autoplay === !1 && this.animation.pause(), this.animation.onfinish = () => { if (this.finishedTime = this.time, !i) { const d = Hf(s, this.options, a, this.speed); this.updateMotionValue ? this.updateMotionValue(d) : V2(n, r, d), this.animation.cancel() } l == null || l(), this.notifyFinished() } } play() { this.isStopped || (this.animation.play(), this.state === "finished" && this.updateFinished()) } pause() { this.animation.pause() } complete() { var t, n; (n = (t = this.animation).finish) == null || n.call(t) } cancel() { try { this.animation.cancel() } catch { } } stop() { if (this.isStopped) return; this.isStopped = !0; const { state: t } = this; t === "idle" || t === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(), this.isPseudoElement || this.cancel()) } commitStyles() { var t, n; this.isPseudoElement || (n = (t = this.animation).commitStyles) == null || n.call(t) } get duration() { var n, r; const t = ((r = (n = this.animation.effect) == null ? void 0 : n.getComputedTiming) == null ? void 0 : r.call(n).duration) || 0; return vt(Number(t)) } get iterationDuration() { const { delay: t = 0 } = this.options || {}; return this.duration + vt(t) } get time() { return vt(Number(this.animation.currentTime) || 0) } set time(t) { this.finishedTime = null, this.animation.currentTime = Jt(t) } get speed() { return this.animation.playbackRate } set speed(t) { t < 0 && (this.finishedTime = null), this.animation.playbackRate = t } get state() { return this.finishedTime !== null ? "finished" : this.animation.playState } get startTime() { return Number(this.animation.startTime) } set startTime(t) { this.animation.startTime = t } attachTimeline({ timeline: t, observe: n }) { var r; return this.allowFlatten && ((r = this.animation.effect) == null || r.updateTiming({ easing: "linear" })), this.animation.onfinish = null, t && _2() ? (this.animation.timeline = t, wt) : n(this) } } const dw = { anticipate: $x, backInOut: Bx, circInOut: Wx }; function H2(e) { return e in dw } function K2(e) { typeof e.ease == "string" && H2(e.ease) && (e.ease = dw[e.ease]) } const Cm = 10; class Y2 extends W2 { constructor(t) { K2(t), iw(t), super(t), t.startTime && (this.startTime = t.startTime), this.options = t } updateMotionValue(t) { const { motionValue: n, onUpdate: r, onComplete: s, element: i, ...o } = this.options; if (!n) return; if (t !== void 0) { n.set(t); return } const a = new Yf({ ...o, autoplay: !1 }), l = Jt(this.finishedTime ?? this.time); n.setWithVelocity(a.sample(l - Cm).value, a.sample(l).value, Cm), a.stop() } } const km = (e, t) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && (ar.test(e) || e === "0") && !e.startsWith("url(")); function G2(e) { const t = e[0]; if (e.length === 1) return !0; for (let n = 0; n < e.length; n++)if (e[n] !== t) return !0 } function Q2(e, t, n, r) { const s = e[0]; if (s === null) return !1; if (t === "display" || t === "visibility") return !0; const i = e[e.length - 1], o = km(s, t), a = km(i, t); return !o || !a ? !1 : G2(e) || (n === "spring" || uw(n)) && r } function rd(e) { e.duration = 0, e.type = "keyframes" } const q2 = new Set(["opacity", "clipPath", "filter", "transform"]), X2 = If(() => Object.hasOwnProperty.call(Element.prototype, "animate")); function Z2(e) { var d; const { motionValue: t, name: n, repeatDelay: r, repeatType: s, damping: i, type: o } = e; if (!(((d = t == null ? void 0 : t.owner) == null ? void 0 : d.current) instanceof HTMLElement)) return !1; const { onUpdate: l, transformTemplate: c } = t.owner.getProps(); return X2() && n && q2.has(n) && (n !== "transform" || !c) && !l && !r && s !== "mirror" && i !== 0 && o !== "inertia" } const J2 = 40; class ej extends Kf { constructor({ autoplay: t = !0, delay: n = 0, type: r = "keyframes", repeat: s = 0, repeatDelay: i = 0, repeatType: o = "loop", keyframes: a, name: l, motionValue: c, element: d, ...f }) { var w; super(), this.stop = () => { var y, b; this._animation && (this._animation.stop(), (y = this.stopTimeline) == null || y.call(this)), (b = this.keyframeResolver) == null || b.cancel() }, this.createdAt = Je.now(); const h = { autoplay: t, delay: n, type: r, repeat: s, repeatDelay: i, repeatType: o, name: l, motionValue: c, element: d, ...f }, p = (d == null ? void 0 : d.KeyframeResolver) || Gf; this.keyframeResolver = new p(a, (y, b, g) => this.onKeyframesResolved(y, b, h, !g), l, c, d), (w = this.keyframeResolver) == null || w.scheduleResolve() } onKeyframesResolved(t, n, r, s) { this.keyframeResolver = void 0; const { name: i, type: o, velocity: a, delay: l, isHandoff: c, onUpdate: d } = r; this.resolvedAt = Je.now(), Q2(t, i, o, a) || ((wn.instantAnimations || !l) && (d == null || d(Hf(t, r, n))), t[0] = t[t.length - 1], rd(r), r.repeat = 0); const h = { startTime: s ? this.resolvedAt ? this.resolvedAt - this.createdAt > J2 ? this.resolvedAt : this.createdAt : this.createdAt : void 0, finalKeyframe: n, ...r, keyframes: t }, p = !c && Z2(h) ? new Y2({ ...h, element: h.motionValue.owner.current }) : new Yf(h); p.finished.then(() => this.notifyFinished()).catch(wt), this.pendingTimeline && (this.stopTimeline = p.attachTimeline(this.pendingTimeline), this.pendingTimeline = void 0), this._animation = p } get finished() { return this._animation ? this.animation.finished : this._finished } then(t, n) { return this.finished.finally(t).then(() => { }) } get animation() { var t; return this._animation || ((t = this.keyframeResolver) == null || t.resume(), I2()), this._animation } get duration() { return this.animation.duration } get iterationDuration() { return this.animation.iterationDuration } get time() { return this.animation.time } set time(t) { this.animation.time = t } get speed() { return this.animation.speed } get state() { return this.animation.state } set speed(t) { this.animation.speed = t } get startTime() { return this.animation.startTime } attachTimeline(t) { return this._animation ? this.stopTimeline = this.animation.attachTimeline(t) : this.pendingTimeline = t, () => this.stop() } play() { this.animation.play() } pause() { this.animation.pause() } complete() { this.animation.complete() } cancel() { var t; this._animation && this.animation.cancel(), (t = this.keyframeResolver) == null || t.cancel() } } const tj = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u; function nj(e) { const t = tj.exec(e); if (!t) return [,]; const [, n, r, s] = t; return [`--${n ?? r}`, s] } function fw(e, t, n = 1) { const [r, s] = nj(e); if (!r) return; const i = window.getComputedStyle(t).getPropertyValue(r); if (i) { const o = i.trim(); return Dx(o) ? parseFloat(o) : o } return zf(s) ? fw(s, t, n + 1) : s } function Qf(e, t) { return (e == null ? void 0 : e[t]) ?? (e == null ? void 0 : e.default) ?? e } const hw = new Set(["width", "height", "top", "left", "right", "bottom", ...ti]), rj = { test: e => e === "auto", parse: e => e }, pw = e => t => t.test(e), mw = [ei, B, en, Mn, GP, YP, rj], Tm = e => mw.find(pw(e)); function sj(e) { return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || Ox(e) : !0 } const ij = new Set(["brightness", "contrast", "saturate", "opacity"]); function oj(e) { const [t, n] = e.slice(0, -1).split("("); if (t === "drop-shadow") return e; const [r] = n.match(Bf) || []; if (!r) return e; const s = n.replace(r, ""); let i = ij.has(t) ? 1 : 0; return r !== n && (i *= 100), t + "(" + i + s + ")" } const aj = /\b([a-z-]*)\(.*?\)/gu, sd = { ...ar, getAnimatableNone: e => { const t = e.match(aj); return t ? t.map(oj).join(" ") : e } }, Em = { ...ei, transform: Math.round }, lj = { rotate: Mn, rotateX: Mn, rotateY: Mn, rotateZ: Mn, scale: Jo, scaleX: Jo, scaleY: Jo, scaleZ: Jo, skew: Mn, skewX: Mn, skewY: Mn, distance: B, translateX: B, translateY: B, translateZ: B, x: B, y: B, z: B, perspective: B, transformPerspective: B, opacity: oo, originX: hm, originY: hm, originZ: B }, qf = { borderWidth: B, borderTopWidth: B, borderRightWidth: B, borderBottomWidth: B, borderLeftWidth: B, borderRadius: B, radius: B, borderTopLeftRadius: B, borderTopRightRadius: B, borderBottomRightRadius: B, borderBottomLeftRadius: B, width: B, maxWidth: B, height: B, maxHeight: B, top: B, right: B, bottom: B, left: B, padding: B, paddingTop: B, paddingRight: B, paddingBottom: B, paddingLeft: B, margin: B, marginTop: B, marginRight: B, marginBottom: B, marginLeft: B, backgroundPositionX: B, backgroundPositionY: B, ...lj, zIndex: Em, fillOpacity: oo, strokeOpacity: oo, numOctaves: Em }, cj = { ...qf, color: be, backgroundColor: be, outlineColor: be, fill: be, stroke: be, borderColor: be, borderTopColor: be, borderRightColor: be, borderBottomColor: be, borderLeftColor: be, filter: sd, WebkitFilter: sd }, gw = e => cj[e]; function yw(e, t) { let n = gw(e); return n !== sd && (n = ar), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0 } const uj = new Set(["auto", "none", "0"]); function dj(e, t, n) { let r = 0, s; for (; r < e.length && !s;) { const i = e[r]; typeof i == "string" && !uj.has(i) && ao(i).values.length && (s = e[r]), r++ } if (s && n) for (const i of t) e[i] = yw(n, s) } class fj extends Gf { constructor(t, n, r, s, i) { super(t, n, r, s, i, !0) } readKeyframes() { const { unresolvedKeyframes: t, element: n, name: r } = this; if (!n || !n.current) return; super.readKeyframes(); for (let l = 0; l < t.length; l++) { let c = t[l]; if (typeof c == "string" && (c = c.trim(), zf(c))) { const d = fw(c, n.current); d !== void 0 && (t[l] = d), l === t.length - 1 && (this.finalKeyframe = c) } } if (this.resolveNoneKeyframes(), !hw.has(r) || t.length !== 2) return; const [s, i] = t, o = Tm(s), a = Tm(i); if (o !== a) if (bm(o) && bm(a)) for (let l = 0; l < t.length; l++) { const c = t[l]; typeof c == "string" && (t[l] = parseFloat(c)) } else Dr[r] && (this.needsMeasurement = !0) } resolveNoneKeyframes() { const { unresolvedKeyframes: t, name: n } = this, r = []; for (let s = 0; s < t.length; s++)(t[s] === null || sj(t[s])) && r.push(s); r.length && dj(t, r, n) } measureInitialState() { const { element: t, unresolvedKeyframes: n, name: r } = this; if (!t || !t.current) return; r === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = Dr[r](t.measureViewportBox(), window.getComputedStyle(t.current)), n[0] = this.measuredOrigin; const s = n[n.length - 1]; s !== void 0 && t.getValue(r, s).jump(s, !1) } measureEndState() { var a; const { element: t, name: n, unresolvedKeyframes: r } = this; if (!t || !t.current) return; const s = t.getValue(n); s && s.jump(this.measuredOrigin, !1); const i = r.length - 1, o = r[i]; r[i] = Dr[n](t.measureViewportBox(), window.getComputedStyle(t.current)), o !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = o), (a = this.removedTransforms) != null && a.length && this.removedTransforms.forEach(([l, c]) => { t.getValue(l).set(c) }), this.resolveNoneKeyframes() } } function hj(e, t, n) { if (e instanceof EventTarget) return [e]; if (typeof e == "string") { const s = document.querySelectorAll(e); return s ? Array.from(s) : [] } return Array.from(e) } const vw = (e, t) => t && typeof e == "number" ? t.transform(e) : e; function xw(e) { return Lx(e) && "offsetHeight" in e } const Nm = 30, pj = e => !isNaN(parseFloat(e)); class mj { constructor(t, n = {}) { this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = r => { var i; const s = Je.now(); if (this.updatedAt !== s && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(r), this.current !== this.prev && ((i = this.events.change) == null || i.notify(this.current), this.dependents)) for (const o of this.dependents) o.dirty() }, this.hasAnimated = !1, this.setCurrent(t), this.owner = n.owner } setCurrent(t) { this.current = t, this.updatedAt = Je.now(), this.canTrackVelocity === null && t !== void 0 && (this.canTrackVelocity = pj(this.current)) } setPrevFrameValue(t = this.current) { this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt } onChange(t) { return this.on("change", t) } on(t, n) { this.events[t] || (this.events[t] = new Ff); const r = this.events[t].add(n); return t === "change" ? () => { r(), ue.read(() => { this.events.change.getSize() || this.stop() }) } : r } clearListeners() { for (const t in this.events) this.events[t].clear() } attach(t, n) { this.passiveEffect = t, this.stopPassiveEffect = n } set(t) { this.passiveEffect ? this.passiveEffect(t, this.updateAndNotify) : this.updateAndNotify(t) } setWithVelocity(t, n, r) { this.set(n), this.prev = void 0, this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt - r } jump(t, n = !0) { this.updateAndNotify(t), this.prev = t, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } dirty() { var t; (t = this.events.change) == null || t.notify(this.current) } addDependent(t) { this.dependents || (this.dependents = new Set), this.dependents.add(t) } removeDependent(t) { this.dependents && this.dependents.delete(t) } get() { return this.current } getPrevious() { return this.prev } getVelocity() { const t = Je.now(); if (!this.canTrackVelocity || this.prevFrameValue === void 0 || t - this.updatedAt > Nm) return 0; const n = Math.min(this.updatedAt - this.prevUpdatedAt, Nm); return Ix(parseFloat(this.current) - parseFloat(this.prevFrameValue), n) } start(t) { return this.stop(), new Promise(n => { this.hasAnimated = !0, this.animation = t(n), this.events.animationStart && this.events.animationStart.notify() }).then(() => { this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation() }) } stop() { this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation() } isAnimating() { return !!this.animation } clearAnimation() { delete this.animation } destroy() { var t, n; (t = this.dependents) == null || t.clear(), (n = this.events.destroy) == null || n.notify(), this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } } function Ws(e, t) { return new mj(e, t) } const { schedule: Xf, cancel: IM } = Yx(queueMicrotask, !1), jt = { x: !1, y: !1 }; function ww() { return jt.x || jt.y } function gj(e) { return e === "x" || e === "y" ? jt[e] ? null : (jt[e] = !0, () => { jt[e] = !1 }) : jt.x || jt.y ? null : (jt.x = jt.y = !0, () => { jt.x = jt.y = !1 }) } function bw(e, t) { const n = hj(e), r = new AbortController, s = { passive: !0, ...t, signal: r.signal }; return [n, s, () => r.abort()] } function Pm(e) { return !(e.pointerType === "touch" || ww()) } function yj(e, t, n = {}) { const [r, s, i] = bw(e, n), o = a => { if (!Pm(a)) return; const { target: l } = a, c = t(l, a); if (typeof c != "function" || !l) return; const d = f => { Pm(f) && (c(f), l.removeEventListener("pointerleave", d)) }; l.addEventListener("pointerleave", d, s) }; return r.forEach(a => { a.addEventListener("pointerenter", o, s) }), i } const Sw = (e, t) => t ? e === t ? !0 : Sw(e, t.parentElement) : !1, Zf = e => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1, vj = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]); function xj(e) { return vj.has(e.tagName) || e.tabIndex !== -1 } const va = new WeakSet; function jm(e) { return t => { t.key === "Enter" && e(t) } } function Nc(e, t) { e.dispatchEvent(new PointerEvent("pointer" + t, { isPrimary: !0, bubbles: !0 })) } const wj = (e, t) => { const n = e.currentTarget; if (!n) return; const r = jm(() => { if (va.has(n)) return; Nc(n, "down"); const s = jm(() => { Nc(n, "up") }), i = () => Nc(n, "cancel"); n.addEventListener("keyup", s, t), n.addEventListener("blur", i, t) }); n.addEventListener("keydown", r, t), n.addEventListener("blur", () => n.removeEventListener("keydown", r), t) }; function Rm(e) { return Zf(e) && !ww() } function bj(e, t, n = {}) { const [r, s, i] = bw(e, n), o = a => { const l = a.currentTarget; if (!Rm(a)) return; va.add(l); const c = t(l, a), d = (p, w) => { window.removeEventListener("pointerup", f), window.removeEventListener("pointercancel", h), va.has(l) && va.delete(l), Rm(p) && typeof c == "function" && c(p, { success: w }) }, f = p => { d(p, l === window || l === document || n.useGlobalTarget || Sw(l, p.target)) }, h = p => { d(p, !1) }; window.addEventListener("pointerup", f, s), window.addEventListener("pointercancel", h, s) }; return r.forEach(a => { (n.useGlobalTarget ? window : a).addEventListener("pointerdown", o, s), xw(a) && (a.addEventListener("focus", c => wj(c, s)), !xj(a) && !a.hasAttribute("tabindex") && (a.tabIndex = 0)) }), i } function Cw(e) { return Lx(e) && "ownerSVGElement" in e } function Sj(e) { return Cw(e) && e.tagName === "svg" } const Be = e => !!(e && e.getVelocity), Cj = [...mw, be, ar], kj = e => Cj.find(pw(e)), Jf = x.createContext({ transformPagePoint: e => e, isStatic: !1, reducedMotion: "never" }); function Am(e, t) { if (typeof e == "function") return e(t); e != null && (e.current = t) } function Tj(...e) { return t => { let n = !1; const r = e.map(s => { const i = Am(s, t); return !n && typeof i == "function" && (n = !0), i }); if (n) return () => { for (let s = 0; s < r.length; s++) { const i = r[s]; typeof i == "function" ? i() : Am(e[s], null) } } } } function Ej(...e) { return x.useCallback(Tj(...e), e) } class Nj extends x.Component { getSnapshotBeforeUpdate(t) { const n = this.props.childRef.current; if (n && t.isPresent && !this.props.isPresent) { const r = n.offsetParent, s = xw(r) && r.offsetWidth || 0, i = this.props.sizeRef.current; i.height = n.offsetHeight || 0, i.width = n.offsetWidth || 0, i.top = n.offsetTop, i.left = n.offsetLeft, i.right = s - i.width - i.left } return null } componentDidUpdate() { } render() { return this.props.children } } function Pj({ children: e, isPresent: t, anchorX: n, root: r }) {
  const s = x.useId(), i = x.useRef(null), o = x.useRef({ width: 0, height: 0, top: 0, left: 0, right: 0 }), { nonce: a } = x.useContext(Jf), l = Ej(i, e == null ? void 0 : e.ref); return x.useInsertionEffect(() => {
    const { width: c, height: d, top: f, left: h, right: p } = o.current; if (t || !i.current || !c || !d) return; const w = n === "left" ? `left: ${h}` : `right: ${p}`; i.current.dataset.motionPopId = s; const y = document.createElement("style"); a && (y.nonce = a); const b = r ?? document.head; return b.appendChild(y), y.sheet && y.sheet.insertRule(`
          [data-motion-pop-id="${s}"] {
            position: absolute !important;
            width: ${c}px !important;
            height: ${d}px !important;
            ${w}px !important;
            top: ${f}px !important;
          }
        `), () => { b.contains(y) && b.removeChild(y) }
  }, [t]), u.jsx(Nj, { isPresent: t, childRef: i, sizeRef: o, children: x.cloneElement(e, { ref: l }) })
} const jj = ({ children: e, initial: t, isPresent: n, onExitComplete: r, custom: s, presenceAffectsLayout: i, mode: o, anchorX: a, root: l }) => { const c = Mf(Rj), d = x.useId(); let f = !0, h = x.useMemo(() => (f = !1, { id: d, initial: t, isPresent: n, custom: s, onExitComplete: p => { c.set(p, !0); for (const w of c.values()) if (!w) return; r && r() }, register: p => (c.set(p, !1), () => c.delete(p)) }), [n, c, r]); return i && f && (h = { ...h }), x.useMemo(() => { c.forEach((p, w) => c.set(w, !1)) }, [n]), x.useEffect(() => { !n && !c.size && r && r() }, [n]), o === "popLayout" && (e = u.jsx(Pj, { isPresent: n, anchorX: a, root: l, children: e })), u.jsx(Ml.Provider, { value: h, children: e }) }; function Rj() { return new Map } function kw(e = !0) { const t = x.useContext(Ml); if (t === null) return [!0, null]; const { isPresent: n, onExitComplete: r, register: s } = t, i = x.useId(); x.useEffect(() => { if (e) return s(i) }, [e]); const o = x.useCallback(() => e && r && r(i), [i, r, e]); return !n && r ? [!1, o] : [!0] } const ea = e => e.key || ""; function Mm(e) { const t = []; return x.Children.forEach(e, n => { x.isValidElement(n) && t.push(n) }), t } const Dm = ({ children: e, custom: t, initial: n = !0, onExitComplete: r, presenceAffectsLayout: s = !0, mode: i = "sync", propagate: o = !1, anchorX: a = "left", root: l }) => { const [c, d] = kw(o), f = x.useMemo(() => Mm(e), [e]), h = o && !c ? [] : f.map(ea), p = x.useRef(!0), w = x.useRef(f), y = Mf(() => new Map), [b, g] = x.useState(f), [m, v] = x.useState(f); Mx(() => { p.current = !1, w.current = f; for (let k = 0; k < m.length; k++) { const T = ea(m[k]); h.includes(T) ? y.delete(T) : y.get(T) !== !0 && y.set(T, !1) } }, [m, h.length, h.join("-")]); const S = []; if (f !== b) { let k = [...f]; for (let T = 0; T < m.length; T++) { const E = m[T], A = ea(E); h.includes(A) || (k.splice(T, 0, E), S.push(E)) } return i === "wait" && S.length && (k = S), v(Mm(k)), g(f), null } const { forceRender: C } = x.useContext(Af); return u.jsx(u.Fragment, { children: m.map(k => { const T = ea(k), E = o && !c ? !1 : f === m || h.includes(T), A = () => { if (y.has(T)) y.set(T, !0); else return; let R = !0; y.forEach(_ => { _ || (R = !1) }), R && (C == null || C(), v(w.current), o && (d == null || d()), r && r()) }; return u.jsx(jj, { isPresent: E, initial: !p.current || n ? void 0 : !1, custom: t, presenceAffectsLayout: s, mode: i, root: l, onExitComplete: E ? void 0 : A, anchorX: a, children: k }, T) }) }) }, Tw = x.createContext({ strict: !1 }), Lm = { animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] }, Hs = {}; for (const e in Lm) Hs[e] = { isEnabled: t => Lm[e].some(n => !!t[n]) }; function Aj(e) { for (const t in e) Hs[t] = { ...Hs[t], ...e[t] } } const Mj = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]); function nl(e) { return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || Mj.has(e) } let Ew = e => !nl(e); function Dj(e) { typeof e == "function" && (Ew = t => t.startsWith("on") ? !nl(t) : e(t)) } try { Dj(require("@emotion/is-prop-valid").default) } catch { } function Lj(e, t, n) { const r = {}; for (const s in e) s === "values" && typeof e.values == "object" || (Ew(s) || n === !0 && nl(s) || !t && !nl(s) || e.draggable && s.startsWith("onDrag")) && (r[s] = e[s]); return r } const Dl = x.createContext({}); function Ll(e) { return e !== null && typeof e == "object" && typeof e.start == "function" } function lo(e) { return typeof e == "string" || Array.isArray(e) } const eh = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"], th = ["initial", ...eh]; function Ol(e) { return Ll(e.animate) || th.some(t => lo(e[t])) } function Nw(e) { return !!(Ol(e) || e.variants) } function Oj(e, t) { if (Ol(e)) { const { initial: n, animate: r } = e; return { initial: n === !1 || lo(n) ? n : void 0, animate: lo(r) ? r : void 0 } } return e.inherit !== !1 ? t : {} } function Ij(e) { const { initial: t, animate: n } = Oj(e, x.useContext(Dl)); return x.useMemo(() => ({ initial: t, animate: n }), [Om(t), Om(n)]) } function Om(e) { return Array.isArray(e) ? e.join(" ") : e } function Im(e, t) { return t.max === t.min ? 0 : e / (t.max - t.min) * 100 } const mi = { correct: (e, t) => { if (!t.target) return e; if (typeof e == "string") if (B.test(e)) e = parseFloat(e); else return e; const n = Im(e, t.target.x), r = Im(e, t.target.y); return `${n}% ${r}%` } }, Fj = { correct: (e, { treeScale: t, projectionDelta: n }) => { const r = e, s = ar.parse(e); if (s.length > 5) return r; const i = ar.createTransformer(e), o = typeof s[0] != "number" ? 1 : 0, a = n.x.scale * t.x, l = n.y.scale * t.y; s[0 + o] /= a, s[1 + o] /= l; const c = he(a, l, .5); return typeof s[2 + o] == "number" && (s[2 + o] /= c), typeof s[3 + o] == "number" && (s[3 + o] /= c), i(s) } }, id = { borderRadius: { ...mi, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: mi, borderTopRightRadius: mi, borderBottomLeftRadius: mi, borderBottomRightRadius: mi, boxShadow: Fj }; function Pw(e, { layout: t, layoutId: n }) { return ni.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!id[e] || e === "opacity") } const Vj = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, _j = ti.length; function zj(e, t, n) { let r = "", s = !0; for (let i = 0; i < _j; i++) { const o = ti[i], a = e[o]; if (a === void 0) continue; let l = !0; if (typeof a == "number" ? l = a === (o.startsWith("scale") ? 1 : 0) : l = parseFloat(a) === 0, !l || n) { const c = vw(a, qf[o]); if (!l) { s = !1; const d = Vj[o] || o; r += `${d}(${c}) ` } n && (t[o] = c) } } return r = r.trim(), n ? r = n(t, s ? "" : r) : s && (r = "none"), r } function nh(e, t, n) { const { style: r, vars: s, transformOrigin: i } = e; let o = !1, a = !1; for (const l in t) { const c = t[l]; if (ni.has(l)) { o = !0; continue } else if (Qx(l)) { s[l] = c; continue } else { const d = vw(c, qf[l]); l.startsWith("origin") ? (a = !0, i[l] = d) : r[l] = d } } if (t.transform || (o || n ? r.transform = zj(t, e.transform, n) : r.transform && (r.transform = "none")), a) { const { originX: l = "50%", originY: c = "50%", originZ: d = 0 } = i; r.transformOrigin = `${l} ${c} ${d}` } } const rh = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }); function jw(e, t, n) { for (const r in t) !Be(t[r]) && !Pw(r, n) && (e[r] = t[r]) } function Bj({ transformTemplate: e }, t) { return x.useMemo(() => { const n = rh(); return nh(n, t, e), Object.assign({}, n.vars, n.style) }, [t]) } function $j(e, t) { const n = e.style || {}, r = {}; return jw(r, n, e), Object.assign(r, Bj(e, t)), r } function Uj(e, t) { const n = {}, r = $j(e, t); return e.drag && e.dragListener !== !1 && (n.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`), e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (n.tabIndex = 0), n.style = r, n } const Wj = { offset: "stroke-dashoffset", array: "stroke-dasharray" }, Hj = { offset: "strokeDashoffset", array: "strokeDasharray" }; function Kj(e, t, n = 1, r = 0, s = !0) { e.pathLength = 1; const i = s ? Wj : Hj; e[i.offset] = B.transform(-r); const o = B.transform(t), a = B.transform(n); e[i.array] = `${o} ${a}` } function Rw(e, { attrX: t, attrY: n, attrScale: r, pathLength: s, pathSpacing: i = 1, pathOffset: o = 0, ...a }, l, c, d) { if (nh(e, a, c), l) { e.style.viewBox && (e.attrs.viewBox = e.style.viewBox); return } e.attrs = e.style, e.style = {}; const { attrs: f, style: h } = e; f.transform && (h.transform = f.transform, delete f.transform), (h.transform || f.transformOrigin) && (h.transformOrigin = f.transformOrigin ?? "50% 50%", delete f.transformOrigin), h.transform && (h.transformBox = (d == null ? void 0 : d.transformBox) ?? "fill-box", delete f.transformBox), t !== void 0 && (f.x = t), n !== void 0 && (f.y = n), r !== void 0 && (f.scale = r), s !== void 0 && Kj(f, s, i, o, !1) } const Aw = () => ({ ...rh(), attrs: {} }), Mw = e => typeof e == "string" && e.toLowerCase() === "svg"; function Yj(e, t, n, r) { const s = x.useMemo(() => { const i = Aw(); return Rw(i, t, Mw(r), e.transformTemplate, e.style), { ...i.attrs, style: { ...i.style } } }, [t]); if (e.style) { const i = {}; jw(i, e.style, e), s.style = { ...i, ...s.style } } return s } const Gj = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"]; function sh(e) { return typeof e != "string" || e.includes("-") ? !1 : !!(Gj.indexOf(e) > -1 || /[A-Z]/u.test(e)) } function Qj(e, t, n, { latestValues: r }, s, i = !1) { const a = (sh(e) ? Yj : Uj)(t, r, s, e), l = Lj(t, typeof e == "string", i), c = e !== x.Fragment ? { ...l, ...a, ref: n } : {}, { children: d } = t, f = x.useMemo(() => Be(d) ? d.get() : d, [d]); return x.createElement(e, { ...c, children: f }) } function Fm(e) { const t = [{}, {}]; return e == null || e.values.forEach((n, r) => { t[0][r] = n.get(), t[1][r] = n.getVelocity() }), t } function ih(e, t, n, r) { if (typeof t == "function") { const [s, i] = Fm(r); t = t(n !== void 0 ? n : e.custom, s, i) } if (typeof t == "string" && (t = e.variants && e.variants[t]), typeof t == "function") { const [s, i] = Fm(r); t = t(n !== void 0 ? n : e.custom, s, i) } return t } function xa(e) { return Be(e) ? e.get() : e } function qj({ scrapeMotionValuesFromProps: e, createRenderState: t }, n, r, s) { return { latestValues: Xj(n, r, s, e), renderState: t() } } function Xj(e, t, n, r) { const s = {}, i = r(e, {}); for (const h in i) s[h] = xa(i[h]); let { initial: o, animate: a } = e; const l = Ol(e), c = Nw(e); t && c && !l && e.inherit !== !1 && (o === void 0 && (o = t.initial), a === void 0 && (a = t.animate)); let d = n ? n.initial === !1 : !1; d = d || o === !1; const f = d ? a : o; if (f && typeof f != "boolean" && !Ll(f)) { const h = Array.isArray(f) ? f : [f]; for (let p = 0; p < h.length; p++) { const w = ih(e, h[p]); if (w) { const { transitionEnd: y, transition: b, ...g } = w; for (const m in g) { let v = g[m]; if (Array.isArray(v)) { const S = d ? v.length - 1 : 0; v = v[S] } v !== null && (s[m] = v) } for (const m in y) s[m] = y[m] } } } return s } const Dw = e => (t, n) => { const r = x.useContext(Dl), s = x.useContext(Ml), i = () => qj(e, t, r, s); return n ? i() : Mf(i) }; function oh(e, t, n) { var i; const { style: r } = e, s = {}; for (const o in r) (Be(r[o]) || t.style && Be(t.style[o]) || Pw(o, e) || ((i = n == null ? void 0 : n.getValue(o)) == null ? void 0 : i.liveStyle) !== void 0) && (s[o] = r[o]); return s } const Zj = Dw({ scrapeMotionValuesFromProps: oh, createRenderState: rh }); function Lw(e, t, n) { const r = oh(e, t, n); for (const s in e) if (Be(e[s]) || Be(t[s])) { const i = ti.indexOf(s) !== -1 ? "attr" + s.charAt(0).toUpperCase() + s.substring(1) : s; r[i] = e[s] } return r } const Jj = Dw({ scrapeMotionValuesFromProps: Lw, createRenderState: Aw }), eR = Symbol.for("motionComponentSymbol"); function hs(e) { return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current") } function tR(e, t, n) { return x.useCallback(r => { r && e.onMount && e.onMount(r), t && (r ? t.mount(r) : t.unmount()), n && (typeof n == "function" ? n(r) : hs(n) && (n.current = r)) }, [t]) } const ah = e => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), nR = "framerAppearId", Ow = "data-" + ah(nR), Iw = x.createContext({}); function rR(e, t, n, r, s) { var y, b; const { visualElement: i } = x.useContext(Dl), o = x.useContext(Tw), a = x.useContext(Ml), l = x.useContext(Jf).reducedMotion, c = x.useRef(null); r = r || o.renderer, !c.current && r && (c.current = r(e, { visualState: t, parent: i, props: n, presenceContext: a, blockInitialAnimation: a ? a.initial === !1 : !1, reducedMotionConfig: l })); const d = c.current, f = x.useContext(Iw); d && !d.projection && s && (d.type === "html" || d.type === "svg") && sR(c.current, n, s, f); const h = x.useRef(!1); x.useInsertionEffect(() => { d && h.current && d.update(n, a) }); const p = n[Ow], w = x.useRef(!!p && !((y = window.MotionHandoffIsComplete) != null && y.call(window, p)) && ((b = window.MotionHasOptimisedAnimation) == null ? void 0 : b.call(window, p))); return Mx(() => { d && (h.current = !0, window.MotionIsMounted = !0, d.updateFeatures(), d.scheduleRenderMicrotask(), w.current && d.animationState && d.animationState.animateChanges()) }), x.useEffect(() => { d && (!w.current && d.animationState && d.animationState.animateChanges(), w.current && (queueMicrotask(() => { var g; (g = window.MotionHandoffMarkAsComplete) == null || g.call(window, p) }), w.current = !1), d.enteringChildren = void 0) }), d } function sR(e, t, n, r) { const { layoutId: s, layout: i, drag: o, dragConstraints: a, layoutScroll: l, layoutRoot: c, layoutCrossfade: d } = t; e.projection = new n(e.latestValues, t["data-framer-portal-id"] ? void 0 : Fw(e.parent)), e.projection.setOptions({ layoutId: s, layout: i, alwaysMeasureLayout: !!o || a && hs(a), visualElement: e, animationType: typeof i == "string" ? i : "both", initialPromotionConfig: r, crossfade: d, layoutScroll: l, layoutRoot: c }) } function Fw(e) { if (e) return e.options.allowProjection !== !1 ? e.projection : Fw(e.parent) } function Pc(e, { forwardMotionProps: t = !1 } = {}, n, r) { n && Aj(n); const s = sh(e) ? Jj : Zj; function i(a, l) { let c; const d = { ...x.useContext(Jf), ...a, layoutId: iR(a) }, { isStatic: f } = d, h = Ij(a), p = s(a, f); if (!f && Df) { oR(); const w = aR(d); c = w.MeasureLayout, h.visualElement = rR(e, p, d, r, w.ProjectionNode) } return u.jsxs(Dl.Provider, { value: h, children: [c && h.visualElement ? u.jsx(c, { visualElement: h.visualElement, ...d }) : null, Qj(e, a, tR(p, h.visualElement, l), p, f, t)] }) } i.displayName = `motion.${typeof e == "string" ? e : `create(${e.displayName ?? e.name ?? ""})`}`; const o = x.forwardRef(i); return o[eR] = e, o } function iR({ layoutId: e }) { const t = x.useContext(Af).id; return t && e !== void 0 ? t + "-" + e : e } function oR(e, t) { x.useContext(Tw).strict } function aR(e) { const { drag: t, layout: n } = Hs; if (!t && !n) return {}; const r = { ...t, ...n }; return { MeasureLayout: t != null && t.isEnabled(e) || n != null && n.isEnabled(e) ? r.MeasureLayout : void 0, ProjectionNode: r.ProjectionNode } } function lR(e, t) { if (typeof Proxy > "u") return Pc; const n = new Map, r = (i, o) => Pc(i, o, e, t), s = (i, o) => r(i, o); return new Proxy(s, { get: (i, o) => o === "create" ? r : (n.has(o) || n.set(o, Pc(o, void 0, e, t)), n.get(o)) }) } function Vw({ top: e, left: t, right: n, bottom: r }) { return { x: { min: t, max: n }, y: { min: e, max: r } } } function cR({ x: e, y: t }) { return { top: t.min, right: e.max, bottom: t.max, left: e.min } } function uR(e, t) { if (!t) return e; const n = t({ x: e.left, y: e.top }), r = t({ x: e.right, y: e.bottom }); return { top: n.y, left: n.x, bottom: r.y, right: r.x } } function jc(e) { return e === void 0 || e === 1 } function od({ scale: e, scaleX: t, scaleY: n }) { return !jc(e) || !jc(t) || !jc(n) } function xr(e) { return od(e) || _w(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY } function _w(e) { return Vm(e.x) || Vm(e.y) } function Vm(e) { return e && e !== "0%" } function rl(e, t, n) { const r = e - n, s = t * r; return n + s } function _m(e, t, n, r, s) { return s !== void 0 && (e = rl(e, s, r)), rl(e, n, r) + t } function ad(e, t = 0, n = 1, r, s) { e.min = _m(e.min, t, n, r, s), e.max = _m(e.max, t, n, r, s) } function zw(e, { x: t, y: n }) { ad(e.x, t.translate, t.scale, t.originPoint), ad(e.y, n.translate, n.scale, n.originPoint) } const zm = .999999999999, Bm = 1.0000000000001; function dR(e, t, n, r = !1) { const s = n.length; if (!s) return; t.x = t.y = 1; let i, o; for (let a = 0; a < s; a++) { i = n[a], o = i.projectionDelta; const { visualElement: l } = i.options; l && l.props.style && l.props.style.display === "contents" || (r && i.options.layoutScroll && i.scroll && i !== i.root && ms(e, { x: -i.scroll.offset.x, y: -i.scroll.offset.y }), o && (t.x *= o.x.scale, t.y *= o.y.scale, zw(e, o)), r && xr(i.latestValues) && ms(e, i.latestValues)) } t.x < Bm && t.x > zm && (t.x = 1), t.y < Bm && t.y > zm && (t.y = 1) } function ps(e, t) { e.min = e.min + t, e.max = e.max + t } function $m(e, t, n, r, s = .5) { const i = he(e.min, e.max, s); ad(e, t, n, i, r) } function ms(e, t) { $m(e.x, t.x, t.scaleX, t.scale, t.originX), $m(e.y, t.y, t.scaleY, t.scale, t.originY) } function Bw(e, t) { return Vw(uR(e.getBoundingClientRect(), t)) } function fR(e, t, n) { const r = Bw(e, n), { scroll: s } = t; return s && (ps(r.x, s.offset.x), ps(r.y, s.offset.y)), r } const Um = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }), gs = () => ({ x: Um(), y: Um() }), Wm = () => ({ min: 0, max: 0 }), Te = () => ({ x: Wm(), y: Wm() }), ld = { current: null }, $w = { current: !1 }; function hR() { if ($w.current = !0, !!Df) if (window.matchMedia) { const e = window.matchMedia("(prefers-reduced-motion)"), t = () => ld.current = e.matches; e.addEventListener("change", t), t() } else ld.current = !1 } const pR = new WeakMap; function mR(e, t, n) { for (const r in t) { const s = t[r], i = n[r]; if (Be(s)) e.addValue(r, s); else if (Be(i)) e.addValue(r, Ws(s, { owner: e })); else if (i !== s) if (e.hasValue(r)) { const o = e.getValue(r); o.liveStyle === !0 ? o.jump(s) : o.hasAnimated || o.set(s) } else { const o = e.getStaticValue(r); e.addValue(r, Ws(o !== void 0 ? o : s, { owner: e })) } } for (const r in n) t[r] === void 0 && e.removeValue(r); return t } const Hm = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"]; class gR { scrapeMotionValuesFromProps(t, n, r) { return {} } constructor({ parent: t, props: n, presenceContext: r, reducedMotionConfig: s, blockInitialAnimation: i, visualState: o }, a = {}) { this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = Gf, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => { this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection)) }, this.renderScheduledAt = 0, this.scheduleRender = () => { const h = Je.now(); this.renderScheduledAt < h && (this.renderScheduledAt = h, ue.render(this.render, !1, !0)) }; const { latestValues: l, renderState: c } = o; this.latestValues = l, this.baseTarget = { ...l }, this.initialValues = n.initial ? { ...l } : {}, this.renderState = c, this.parent = t, this.props = n, this.presenceContext = r, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = s, this.options = a, this.blockInitialAnimation = !!i, this.isControllingVariants = Ol(n), this.isVariantNode = Nw(n), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(t && t.current); const { willChange: d, ...f } = this.scrapeMotionValuesFromProps(n, {}, this); for (const h in f) { const p = f[h]; l[h] !== void 0 && Be(p) && p.set(l[h]) } } mount(t) { var n; this.current = t, pR.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((r, s) => this.bindToMotionValue(s, r)), $w.current || hR(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : ld.current, (n = this.parent) == null || n.addChild(this), this.update(this.props, this.presenceContext) } unmount() { var t; this.projection && this.projection.unmount(), or(this.notifyUpdate), or(this.render), this.valueSubscriptions.forEach(n => n()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), (t = this.parent) == null || t.removeChild(this); for (const n in this.events) this.events[n].clear(); for (const n in this.features) { const r = this.features[n]; r && (r.unmount(), r.isMounted = !1) } this.current = null } addChild(t) { this.children.add(t), this.enteringChildren ?? (this.enteringChildren = new Set), this.enteringChildren.add(t) } removeChild(t) { this.children.delete(t), this.enteringChildren && this.enteringChildren.delete(t) } bindToMotionValue(t, n) { this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)(); const r = ni.has(t); r && this.onBindTransform && this.onBindTransform(); const s = n.on("change", o => { this.latestValues[t] = o, this.props.onUpdate && ue.preRender(this.notifyUpdate), r && this.projection && (this.projection.isTransformDirty = !0), this.scheduleRender() }); let i; window.MotionCheckAppearSync && (i = window.MotionCheckAppearSync(this, t, n)), this.valueSubscriptions.set(t, () => { s(), i && i(), n.owner && n.stop() }) } sortNodePosition(t) { return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current) } updateFeatures() { let t = "animation"; for (t in Hs) { const n = Hs[t]; if (!n) continue; const { isEnabled: r, Feature: s } = n; if (!this.features[t] && s && r(this.props) && (this.features[t] = new s(this)), this.features[t]) { const i = this.features[t]; i.isMounted ? i.update() : (i.mount(), i.isMounted = !0) } } } triggerBuild() { this.build(this.renderState, this.latestValues, this.props) } measureViewportBox() { return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Te() } getStaticValue(t) { return this.latestValues[t] } setStaticValue(t, n) { this.latestValues[t] = n } update(t, n) { (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = n; for (let r = 0; r < Hm.length; r++) { const s = Hm[r]; this.propEventSubscriptions[s] && (this.propEventSubscriptions[s](), delete this.propEventSubscriptions[s]); const i = "on" + s, o = t[i]; o && (this.propEventSubscriptions[s] = this.on(s, o)) } this.prevMotionValues = mR(this, this.scrapeMotionValuesFromProps(t, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue() } getProps() { return this.props } getVariant(t) { return this.props.variants ? this.props.variants[t] : void 0 } getDefaultTransition() { return this.props.transition } getTransformPagePoint() { return this.props.transformPagePoint } getClosestVariantNode() { return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0 } addVariantChild(t) { const n = this.getClosestVariantNode(); if (n) return n.variantChildren && n.variantChildren.add(t), () => n.variantChildren.delete(t) } addValue(t, n) { const r = this.values.get(t); n !== r && (r && this.removeValue(t), this.bindToMotionValue(t, n), this.values.set(t, n), this.latestValues[t] = n.get()) } removeValue(t) { this.values.delete(t); const n = this.valueSubscriptions.get(t); n && (n(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState) } hasValue(t) { return this.values.has(t) } getValue(t, n) { if (this.props.values && this.props.values[t]) return this.props.values[t]; let r = this.values.get(t); return r === void 0 && n !== void 0 && (r = Ws(n === null ? void 0 : n, { owner: this }), this.addValue(t, r)), r } readValue(t, n) { let r = this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : this.getBaseTargetFromProps(this.props, t) ?? this.readValueFromInstance(this.current, t, this.options); return r != null && (typeof r == "string" && (Dx(r) || Ox(r)) ? r = parseFloat(r) : !kj(r) && ar.test(n) && (r = yw(t, n)), this.setBaseTarget(t, Be(r) ? r.get() : r)), Be(r) ? r.get() : r } setBaseTarget(t, n) { this.baseTarget[t] = n } getBaseTarget(t) { var i; const { initial: n } = this.props; let r; if (typeof n == "string" || typeof n == "object") { const o = ih(this.props, n, (i = this.presenceContext) == null ? void 0 : i.custom); o && (r = o[t]) } if (n && r !== void 0) return r; const s = this.getBaseTargetFromProps(this.props, t); return s !== void 0 && !Be(s) ? s : this.initialValues[t] !== void 0 && r === void 0 ? void 0 : this.baseTarget[t] } on(t, n) { return this.events[t] || (this.events[t] = new Ff), this.events[t].add(n) } notify(t, ...n) { this.events[t] && this.events[t].notify(...n) } scheduleRenderMicrotask() { Xf.render(this.render) } } class Uw extends gR { constructor() { super(...arguments), this.KeyframeResolver = fj } sortInstanceNodePosition(t, n) { return t.compareDocumentPosition(n) & 2 ? 1 : -1 } getBaseTargetFromProps(t, n) { return t.style ? t.style[n] : void 0 } removeValueFromRenderState(t, { vars: n, style: r }) { delete n[t], delete r[t] } handleChildMotionValue() { this.childSubscription && (this.childSubscription(), delete this.childSubscription); const { children: t } = this.props; Be(t) && (this.childSubscription = t.on("change", n => { this.current && (this.current.textContent = `${n}`) })) } } function Ww(e, { style: t, vars: n }, r, s) { const i = e.style; let o; for (o in t) i[o] = t[o]; s == null || s.applyProjectionStyles(i, r); for (o in n) i.setProperty(o, n[o]) } function yR(e) { return window.getComputedStyle(e) } class vR extends Uw { constructor() { super(...arguments), this.type = "html", this.renderInstance = Ww } readValueFromInstance(t, n) { var r; if (ni.has(n)) return (r = this.projection) != null && r.isProjecting ? Zu(n) : A2(t, n); { const s = yR(t), i = (Qx(n) ? s.getPropertyValue(n) : s[n]) || 0; return typeof i == "string" ? i.trim() : i } } measureInstanceViewportBox(t, { transformPagePoint: n }) { return Bw(t, n) } build(t, n, r) { nh(t, n, r.transformTemplate) } scrapeMotionValuesFromProps(t, n, r) { return oh(t, n, r) } } const Hw = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]); function xR(e, t, n, r) { Ww(e, t, void 0, r); for (const s in t.attrs) e.setAttribute(Hw.has(s) ? s : ah(s), t.attrs[s]) } class wR extends Uw { constructor() { super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = Te } getBaseTargetFromProps(t, n) { return t[n] } readValueFromInstance(t, n) { if (ni.has(n)) { const r = gw(n); return r && r.default || 0 } return n = Hw.has(n) ? n : ah(n), t.getAttribute(n) } scrapeMotionValuesFromProps(t, n, r) { return Lw(t, n, r) } build(t, n, r) { Rw(t, n, this.isSVGTag, r.transformTemplate, r.style) } renderInstance(t, n, r, s) { xR(t, n, r, s) } mount(t) { this.isSVGTag = Mw(t.tagName), super.mount(t) } } const bR = (e, t) => sh(e) ? new wR(t) : new vR(t, { allowProjection: e !== x.Fragment }); function Es(e, t, n) { const r = e.getProps(); return ih(r, t, n !== void 0 ? n : r.custom, e) } const cd = e => Array.isArray(e); function SR(e, t, n) { e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, Ws(n)) } function CR(e) { return cd(e) ? e[e.length - 1] || 0 : e } function kR(e, t) { const n = Es(e, t); let { transitionEnd: r = {}, transition: s = {}, ...i } = n || {}; i = { ...i, ...r }; for (const o in i) { const a = CR(i[o]); SR(e, o, a) } } function TR(e) { return !!(Be(e) && e.add) } function ud(e, t) { const n = e.getValue("willChange"); if (TR(n)) return n.add(t); if (!n && wn.WillChange) { const r = new wn.WillChange("auto"); e.addValue("willChange", r), r.add(t) } } function Kw(e) { return e.props[Ow] } const ER = e => e !== null; function NR(e, { repeat: t, repeatType: n = "loop" }, r) { const s = e.filter(ER), i = t && n !== "loop" && t % 2 === 1 ? 0 : s.length - 1; return !i || r === void 0 ? s[i] : r } const PR = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }, jR = e => ({ type: "spring", stiffness: 550, damping: e === 0 ? 2 * Math.sqrt(550) : 30, restSpeed: 10 }), RR = { type: "keyframes", duration: .8 }, AR = { type: "keyframes", ease: [.25, .1, .35, 1], duration: .3 }, MR = (e, { keyframes: t }) => t.length > 2 ? RR : ni.has(e) ? e.startsWith("scale") ? jR(t[1]) : PR : AR; function DR({ when: e, delay: t, delayChildren: n, staggerChildren: r, staggerDirection: s, repeat: i, repeatType: o, repeatDelay: a, from: l, elapsed: c, ...d }) { return !!Object.keys(d).length } const lh = (e, t, n, r = {}, s, i) => o => { const a = Qf(r, e) || {}, l = a.delay || r.delay || 0; let { elapsed: c = 0 } = r; c = c - Jt(l); const d = { keyframes: Array.isArray(n) ? n : [null, n], ease: "easeOut", velocity: t.getVelocity(), ...a, delay: -c, onUpdate: h => { t.set(h), a.onUpdate && a.onUpdate(h) }, onComplete: () => { o(), a.onComplete && a.onComplete() }, name: e, motionValue: t, element: i ? void 0 : s }; DR(a) || Object.assign(d, MR(e, d)), d.duration && (d.duration = Jt(d.duration)), d.repeatDelay && (d.repeatDelay = Jt(d.repeatDelay)), d.from !== void 0 && (d.keyframes[0] = d.from); let f = !1; if ((d.type === !1 || d.duration === 0 && !d.repeatDelay) && (rd(d), d.delay === 0 && (f = !0)), (wn.instantAnimations || wn.skipAnimations) && (f = !0, rd(d), d.delay = 0), d.allowFlatten = !a.type && !a.ease, f && !i && t.get() !== void 0) { const h = NR(d.keyframes, a); if (h !== void 0) { ue.update(() => { d.onUpdate(h), d.onComplete() }); return } } return a.isSync ? new Yf(d) : new ej(d) }; function LR({ protectedKeys: e, needsAnimating: t }, n) { const r = e.hasOwnProperty(n) && t[n] !== !0; return t[n] = !1, r } function Yw(e, t, { delay: n = 0, transitionOverride: r, type: s } = {}) { let { transition: i = e.getDefaultTransition(), transitionEnd: o, ...a } = t; r && (i = r); const l = [], c = s && e.animationState && e.animationState.getState()[s]; for (const d in a) { const f = e.getValue(d, e.latestValues[d] ?? null), h = a[d]; if (h === void 0 || c && LR(c, d)) continue; const p = { delay: n, ...Qf(i || {}, d) }, w = f.get(); if (w !== void 0 && !f.isAnimating && !Array.isArray(h) && h === w && !p.velocity) continue; let y = !1; if (window.MotionHandoffAnimation) { const g = Kw(e); if (g) { const m = window.MotionHandoffAnimation(g, d, ue); m !== null && (p.startTime = m, y = !0) } } ud(e, d), f.start(lh(d, f, h, e.shouldReduceMotion && hw.has(d) ? { type: !1 } : p, e, y)); const b = f.animation; b && l.push(b) } return o && Promise.all(l).then(() => { ue.update(() => { o && kR(e, o) }) }), l } function Gw(e, t, n, r = 0, s = 1) { const i = Array.from(e).sort((c, d) => c.sortNodePosition(d)).indexOf(t), o = e.size, a = (o - 1) * r; return typeof n == "function" ? n(i, o) : s === 1 ? i * r : a - i * r } function dd(e, t, n = {}) { var l; const r = Es(e, t, n.type === "exit" ? (l = e.presenceContext) == null ? void 0 : l.custom : void 0); let { transition: s = e.getDefaultTransition() || {} } = r || {}; n.transitionOverride && (s = n.transitionOverride); const i = r ? () => Promise.all(Yw(e, r, n)) : () => Promise.resolve(), o = e.variantChildren && e.variantChildren.size ? (c = 0) => { const { delayChildren: d = 0, staggerChildren: f, staggerDirection: h } = s; return OR(e, t, c, d, f, h, n) } : () => Promise.resolve(), { when: a } = s; if (a) { const [c, d] = a === "beforeChildren" ? [i, o] : [o, i]; return c().then(() => d()) } else return Promise.all([i(), o(n.delay)]) } function OR(e, t, n = 0, r = 0, s = 0, i = 1, o) { const a = []; for (const l of e.variantChildren) l.notify("AnimationStart", t), a.push(dd(l, t, { ...o, delay: n + (typeof r == "function" ? 0 : r) + Gw(e.variantChildren, l, r, s, i) }).then(() => l.notify("AnimationComplete", t))); return Promise.all(a) } function IR(e, t, n = {}) { e.notify("AnimationStart", t); let r; if (Array.isArray(t)) { const s = t.map(i => dd(e, i, n)); r = Promise.all(s) } else if (typeof t == "string") r = dd(e, t, n); else { const s = typeof t == "function" ? Es(e, t, n.custom) : t; r = Promise.all(Yw(e, s, n)) } return r.then(() => { e.notify("AnimationComplete", t) }) } function Qw(e, t) { if (!Array.isArray(t)) return !1; const n = t.length; if (n !== e.length) return !1; for (let r = 0; r < n; r++)if (t[r] !== e[r]) return !1; return !0 } const FR = th.length; function qw(e) { if (!e) return; if (!e.isControllingVariants) { const n = e.parent ? qw(e.parent) || {} : {}; return e.props.initial !== void 0 && (n.initial = e.props.initial), n } const t = {}; for (let n = 0; n < FR; n++) { const r = th[n], s = e.props[r]; (lo(s) || s === !1) && (t[r] = s) } return t } const VR = [...eh].reverse(), _R = eh.length; function zR(e) { return t => Promise.all(t.map(({ animation: n, options: r }) => IR(e, n, r))) } function BR(e) { let t = zR(e), n = Km(), r = !0; const s = l => (c, d) => { var h; const f = Es(e, d, l === "exit" ? (h = e.presenceContext) == null ? void 0 : h.custom : void 0); if (f) { const { transition: p, transitionEnd: w, ...y } = f; c = { ...c, ...y, ...w } } return c }; function i(l) { t = l(e) } function o(l) { const { props: c } = e, d = qw(e.parent) || {}, f = [], h = new Set; let p = {}, w = 1 / 0; for (let b = 0; b < _R; b++) { const g = VR[b], m = n[g], v = c[g] !== void 0 ? c[g] : d[g], S = lo(v), C = g === l ? m.isActive : null; C === !1 && (w = b); let k = v === d[g] && v !== c[g] && S; if (k && r && e.manuallyAnimateOnMount && (k = !1), m.protectedKeys = { ...p }, !m.isActive && C === null || !v && !m.prevProp || Ll(v) || typeof v == "boolean") continue; const T = $R(m.prevProp, v); let E = T || g === l && m.isActive && !k && S || b > w && S, A = !1; const R = Array.isArray(v) ? v : [v]; let _ = R.reduce(s(g), {}); C === !1 && (_ = {}); const { prevResolvedValues: I = {} } = m, G = { ...I, ..._ }, L = V => { E = !0, h.has(V) && (A = !0, h.delete(V)), m.needsAnimating[V] = !0; const N = e.getValue(V); N && (N.liveStyle = !1) }; for (const V in G) { const N = _[V], j = I[V]; if (p.hasOwnProperty(V)) continue; let O = !1; cd(N) && cd(j) ? O = !Qw(N, j) : O = N !== j, O ? N != null ? L(V) : h.add(V) : N !== void 0 && h.has(V) ? L(V) : m.protectedKeys[V] = !0 } m.prevProp = v, m.prevResolvedValues = _, m.isActive && (p = { ...p, ..._ }), r && e.blockInitialAnimation && (E = !1); const Q = k && T; E && (!Q || A) && f.push(...R.map(V => { const N = { type: g }; if (typeof V == "string" && r && !Q && e.manuallyAnimateOnMount && e.parent) { const { parent: j } = e, O = Es(j, V); if (j.enteringChildren && O) { const { delayChildren: U } = O.transition || {}; N.delay = Gw(j.enteringChildren, e, U) } } return { animation: V, options: N } })) } if (h.size) { const b = {}; if (typeof c.initial != "boolean") { const g = Es(e, Array.isArray(c.initial) ? c.initial[0] : c.initial); g && g.transition && (b.transition = g.transition) } h.forEach(g => { const m = e.getBaseTarget(g), v = e.getValue(g); v && (v.liveStyle = !0), b[g] = m ?? null }), f.push({ animation: b }) } let y = !!f.length; return r && (c.initial === !1 || c.initial === c.animate) && !e.manuallyAnimateOnMount && (y = !1), r = !1, y ? t(f) : Promise.resolve() } function a(l, c) { var f; if (n[l].isActive === c) return Promise.resolve(); (f = e.variantChildren) == null || f.forEach(h => { var p; return (p = h.animationState) == null ? void 0 : p.setActive(l, c) }), n[l].isActive = c; const d = o(l); for (const h in n) n[h].protectedKeys = {}; return d } return { animateChanges: o, setActive: a, setAnimateFunction: i, getState: () => n, reset: () => { n = Km() } } } function $R(e, t) { return typeof t == "string" ? t !== e : Array.isArray(t) ? !Qw(t, e) : !1 } function gr(e = !1) { return { isActive: e, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} } } function Km() { return { animate: gr(!0), whileInView: gr(), whileHover: gr(), whileTap: gr(), whileDrag: gr(), whileFocus: gr(), exit: gr() } } class dr { constructor(t) { this.isMounted = !1, this.node = t } update() { } } class UR extends dr { constructor(t) { super(t), t.animationState || (t.animationState = BR(t)) } updateAnimationControlsSubscription() { const { animate: t } = this.node.getProps(); Ll(t) && (this.unmountControls = t.subscribe(this.node)) } mount() { this.updateAnimationControlsSubscription() } update() { const { animate: t } = this.node.getProps(), { animate: n } = this.node.prevProps || {}; t !== n && this.updateAnimationControlsSubscription() } unmount() { var t; this.node.animationState.reset(), (t = this.unmountControls) == null || t.call(this) } } let WR = 0; class HR extends dr { constructor() { super(...arguments), this.id = WR++ } update() { if (!this.node.presenceContext) return; const { isPresent: t, onExitComplete: n } = this.node.presenceContext, { isPresent: r } = this.node.prevPresenceContext || {}; if (!this.node.animationState || t === r) return; const s = this.node.animationState.setActive("exit", !t); n && !t && s.then(() => { n(this.id) }) } mount() { const { register: t, onExitComplete: n } = this.node.presenceContext || {}; n && n(this.id), t && (this.unmount = t(this.id)) } unmount() { } } const KR = { animation: { Feature: UR }, exit: { Feature: HR } }; function co(e, t, n, r = { passive: !0 }) { return e.addEventListener(t, n, r), () => e.removeEventListener(t, n) } function To(e) { return { point: { x: e.pageX, y: e.pageY } } } const YR = e => t => Zf(t) && e(t, To(t)); function Di(e, t, n, r) { return co(e, t, YR(n), r) } const Xw = 1e-4, GR = 1 - Xw, QR = 1 + Xw, Zw = .01, qR = 0 - Zw, XR = 0 + Zw; function Ke(e) { return e.max - e.min } function ZR(e, t, n) { return Math.abs(e - t) <= n } function Ym(e, t, n, r = .5) { e.origin = r, e.originPoint = he(t.min, t.max, e.origin), e.scale = Ke(n) / Ke(t), e.translate = he(n.min, n.max, e.origin) - e.originPoint, (e.scale >= GR && e.scale <= QR || isNaN(e.scale)) && (e.scale = 1), (e.translate >= qR && e.translate <= XR || isNaN(e.translate)) && (e.translate = 0) } function Li(e, t, n, r) { Ym(e.x, t.x, n.x, r ? r.originX : void 0), Ym(e.y, t.y, n.y, r ? r.originY : void 0) } function Gm(e, t, n) { e.min = n.min + t.min, e.max = e.min + Ke(t) } function JR(e, t, n) { Gm(e.x, t.x, n.x), Gm(e.y, t.y, n.y) } function Qm(e, t, n) { e.min = t.min - n.min, e.max = e.min + Ke(t) } function sl(e, t, n) { Qm(e.x, t.x, n.x), Qm(e.y, t.y, n.y) } function ht(e) { return [e("x"), e("y")] } const Jw = ({ current: e }) => e ? e.ownerDocument.defaultView : null, qm = (e, t) => Math.abs(e - t); function eA(e, t) { const n = qm(e.x, t.x), r = qm(e.y, t.y); return Math.sqrt(n ** 2 + r ** 2) } class e1 { constructor(t, n, { transformPagePoint: r, contextWindow: s = window, dragSnapToOrigin: i = !1, distanceThreshold: o = 3 } = {}) { if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => { if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return; const h = Ac(this.lastMoveEventInfo, this.history), p = this.startEvent !== null, w = eA(h.offset, { x: 0, y: 0 }) >= this.distanceThreshold; if (!p && !w) return; const { point: y } = h, { timestamp: b } = Me; this.history.push({ ...y, timestamp: b }); const { onStart: g, onMove: m } = this.handlers; p || (g && g(this.lastMoveEvent, h), this.startEvent = this.lastMoveEvent), m && m(this.lastMoveEvent, h) }, this.handlePointerMove = (h, p) => { this.lastMoveEvent = h, this.lastMoveEventInfo = Rc(p, this.transformPagePoint), ue.update(this.updatePoint, !0) }, this.handlePointerUp = (h, p) => { this.end(); const { onEnd: w, onSessionEnd: y, resumeAnimation: b } = this.handlers; if (this.dragSnapToOrigin && b && b(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return; const g = Ac(h.type === "pointercancel" ? this.lastMoveEventInfo : Rc(p, this.transformPagePoint), this.history); this.startEvent && w && w(h, g), y && y(h, g) }, !Zf(t)) return; this.dragSnapToOrigin = i, this.handlers = n, this.transformPagePoint = r, this.distanceThreshold = o, this.contextWindow = s || window; const a = To(t), l = Rc(a, this.transformPagePoint), { point: c } = l, { timestamp: d } = Me; this.history = [{ ...c, timestamp: d }]; const { onSessionStart: f } = n; f && f(t, Ac(l, this.history)), this.removeListeners = So(Di(this.contextWindow, "pointermove", this.handlePointerMove), Di(this.contextWindow, "pointerup", this.handlePointerUp), Di(this.contextWindow, "pointercancel", this.handlePointerUp)) } updateHandlers(t) { this.handlers = t } end() { this.removeListeners && this.removeListeners(), or(this.updatePoint) } } function Rc(e, t) { return t ? { point: t(e.point) } : e } function Xm(e, t) { return { x: e.x - t.x, y: e.y - t.y } } function Ac({ point: e }, t) { return { point: e, delta: Xm(e, t1(t)), offset: Xm(e, tA(t)), velocity: nA(t, .1) } } function tA(e) { return e[0] } function t1(e) { return e[e.length - 1] } function nA(e, t) { if (e.length < 2) return { x: 0, y: 0 }; let n = e.length - 1, r = null; const s = t1(e); for (; n >= 0 && (r = e[n], !(s.timestamp - r.timestamp > Jt(t)));)n--; if (!r) return { x: 0, y: 0 }; const i = vt(s.timestamp - r.timestamp); if (i === 0) return { x: 0, y: 0 }; const o = { x: (s.x - r.x) / i, y: (s.y - r.y) / i }; return o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o } function rA(e, { min: t, max: n }, r) { return t !== void 0 && e < t ? e = r ? he(t, e, r.min) : Math.max(e, t) : n !== void 0 && e > n && (e = r ? he(n, e, r.max) : Math.min(e, n)), e } function Zm(e, t, n) { return { min: t !== void 0 ? e.min + t : void 0, max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0 } } function sA(e, { top: t, left: n, bottom: r, right: s }) { return { x: Zm(e.x, n, s), y: Zm(e.y, t, r) } } function Jm(e, t) { let n = t.min - e.min, r = t.max - e.max; return t.max - t.min < e.max - e.min && ([n, r] = [r, n]), { min: n, max: r } } function iA(e, t) { return { x: Jm(e.x, t.x), y: Jm(e.y, t.y) } } function oA(e, t) { let n = .5; const r = Ke(e), s = Ke(t); return s > r ? n = io(t.min, t.max - r, e.min) : r > s && (n = io(e.min, e.max - s, t.min)), xn(0, 1, n) } function aA(e, t) { const n = {}; return t.min !== void 0 && (n.min = t.min - e.min), t.max !== void 0 && (n.max = t.max - e.min), n } const fd = .35; function lA(e = fd) { return e === !1 ? e = 0 : e === !0 && (e = fd), { x: eg(e, "left", "right"), y: eg(e, "top", "bottom") } } function eg(e, t, n) { return { min: tg(e, t), max: tg(e, n) } } function tg(e, t) { return typeof e == "number" ? e : e[t] || 0 } const cA = new WeakMap; class uA { constructor(t) { this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = Te(), this.latestPointerEvent = null, this.latestPanInfo = null, this.visualElement = t } start(t, { snapToCursor: n = !1, distanceThreshold: r } = {}) { const { presenceContext: s } = this.visualElement; if (s && s.isPresent === !1) return; const i = f => { const { dragSnapToOrigin: h } = this.getProps(); h ? this.pauseAnimation() : this.stopAnimation(), n && this.snapToCursor(To(f).point) }, o = (f, h) => { const { drag: p, dragPropagation: w, onDragStart: y } = this.getProps(); if (p && !w && (this.openDragLock && this.openDragLock(), this.openDragLock = gj(p), !this.openDragLock)) return; this.latestPointerEvent = f, this.latestPanInfo = h, this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), ht(g => { let m = this.getAxisMotionValue(g).get() || 0; if (en.test(m)) { const { projection: v } = this.visualElement; if (v && v.layout) { const S = v.layout.layoutBox[g]; S && (m = Ke(S) * (parseFloat(m) / 100)) } } this.originPoint[g] = m }), y && ue.postRender(() => y(f, h)), ud(this.visualElement, "transform"); const { animationState: b } = this.visualElement; b && b.setActive("whileDrag", !0) }, a = (f, h) => { this.latestPointerEvent = f, this.latestPanInfo = h; const { dragPropagation: p, dragDirectionLock: w, onDirectionLock: y, onDrag: b } = this.getProps(); if (!p && !this.openDragLock) return; const { offset: g } = h; if (w && this.currentDirection === null) { this.currentDirection = dA(g), this.currentDirection !== null && y && y(this.currentDirection); return } this.updateAxis("x", h.point, g), this.updateAxis("y", h.point, g), this.visualElement.render(), b && b(f, h) }, l = (f, h) => { this.latestPointerEvent = f, this.latestPanInfo = h, this.stop(f, h), this.latestPointerEvent = null, this.latestPanInfo = null }, c = () => ht(f => { var h; return this.getAnimationState(f) === "paused" && ((h = this.getAxisMotionValue(f).animation) == null ? void 0 : h.play()) }), { dragSnapToOrigin: d } = this.getProps(); this.panSession = new e1(t, { onSessionStart: i, onStart: o, onMove: a, onSessionEnd: l, resumeAnimation: c }, { transformPagePoint: this.visualElement.getTransformPagePoint(), dragSnapToOrigin: d, distanceThreshold: r, contextWindow: Jw(this.visualElement) }) } stop(t, n) { const r = t || this.latestPointerEvent, s = n || this.latestPanInfo, i = this.isDragging; if (this.cancel(), !i || !s || !r) return; const { velocity: o } = s; this.startAnimation(o); const { onDragEnd: a } = this.getProps(); a && ue.postRender(() => a(r, s)) } cancel() { this.isDragging = !1; const { projection: t, animationState: n } = this.visualElement; t && (t.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0; const { dragPropagation: r } = this.getProps(); !r && this.openDragLock && (this.openDragLock(), this.openDragLock = null), n && n.setActive("whileDrag", !1) } updateAxis(t, n, r) { const { drag: s } = this.getProps(); if (!r || !ta(t, s, this.currentDirection)) return; const i = this.getAxisMotionValue(t); let o = this.originPoint[t] + r[t]; this.constraints && this.constraints[t] && (o = rA(o, this.constraints[t], this.elastic[t])), i.set(o) } resolveConstraints() { var i; const { dragConstraints: t, dragElastic: n } = this.getProps(), r = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (i = this.visualElement.projection) == null ? void 0 : i.layout, s = this.constraints; t && hs(t) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : t && r ? this.constraints = sA(r.layoutBox, t) : this.constraints = !1, this.elastic = lA(n), s !== this.constraints && r && this.constraints && !this.hasMutatedConstraints && ht(o => { this.constraints !== !1 && this.getAxisMotionValue(o) && (this.constraints[o] = aA(r.layoutBox[o], this.constraints[o])) }) } resolveRefConstraints() { const { dragConstraints: t, onMeasureDragConstraints: n } = this.getProps(); if (!t || !hs(t)) return !1; const r = t.current, { projection: s } = this.visualElement; if (!s || !s.layout) return !1; const i = fR(r, s.root, this.visualElement.getTransformPagePoint()); let o = iA(s.layout.layoutBox, i); if (n) { const a = n(cR(o)); this.hasMutatedConstraints = !!a, a && (o = Vw(a)) } return o } startAnimation(t) { const { drag: n, dragMomentum: r, dragElastic: s, dragTransition: i, dragSnapToOrigin: o, onDragTransitionEnd: a } = this.getProps(), l = this.constraints || {}, c = ht(d => { if (!ta(d, n, this.currentDirection)) return; let f = l && l[d] || {}; o && (f = { min: 0, max: 0 }); const h = s ? 200 : 1e6, p = s ? 40 : 1e7, w = { type: "inertia", velocity: r ? t[d] : 0, bounceStiffness: h, bounceDamping: p, timeConstant: 750, restDelta: 1, restSpeed: 10, ...i, ...f }; return this.startAxisValueAnimation(d, w) }); return Promise.all(c).then(a) } startAxisValueAnimation(t, n) { const r = this.getAxisMotionValue(t); return ud(this.visualElement, t), r.start(lh(t, r, 0, n, this.visualElement, !1)) } stopAnimation() { ht(t => this.getAxisMotionValue(t).stop()) } pauseAnimation() { ht(t => { var n; return (n = this.getAxisMotionValue(t).animation) == null ? void 0 : n.pause() }) } getAnimationState(t) { var n; return (n = this.getAxisMotionValue(t).animation) == null ? void 0 : n.state } getAxisMotionValue(t) { const n = `_drag${t.toUpperCase()}`, r = this.visualElement.getProps(), s = r[n]; return s || this.visualElement.getValue(t, (r.initial ? r.initial[t] : void 0) || 0) } snapToCursor(t) { ht(n => { const { drag: r } = this.getProps(); if (!ta(n, r, this.currentDirection)) return; const { projection: s } = this.visualElement, i = this.getAxisMotionValue(n); if (s && s.layout) { const { min: o, max: a } = s.layout.layoutBox[n]; i.set(t[n] - he(o, a, .5)) } }) } scalePositionWithinConstraints() { if (!this.visualElement.current) return; const { drag: t, dragConstraints: n } = this.getProps(), { projection: r } = this.visualElement; if (!hs(n) || !r || !this.constraints) return; this.stopAnimation(); const s = { x: 0, y: 0 }; ht(o => { const a = this.getAxisMotionValue(o); if (a && this.constraints !== !1) { const l = a.get(); s[o] = oA({ min: l, max: l }, this.constraints[o]) } }); const { transformTemplate: i } = this.visualElement.getProps(); this.visualElement.current.style.transform = i ? i({}, "") : "none", r.root && r.root.updateScroll(), r.updateLayout(), this.resolveConstraints(), ht(o => { if (!ta(o, t, null)) return; const a = this.getAxisMotionValue(o), { min: l, max: c } = this.constraints[o]; a.set(he(l, c, s[o])) }) } addListeners() { if (!this.visualElement.current) return; cA.set(this.visualElement, this); const t = this.visualElement.current, n = Di(t, "pointerdown", l => { const { drag: c, dragListener: d = !0 } = this.getProps(); c && d && this.start(l) }), r = () => { const { dragConstraints: l } = this.getProps(); hs(l) && l.current && (this.constraints = this.resolveRefConstraints()) }, { projection: s } = this.visualElement, i = s.addEventListener("measure", r); s && !s.layout && (s.root && s.root.updateScroll(), s.updateLayout()), ue.read(r); const o = co(window, "resize", () => this.scalePositionWithinConstraints()), a = s.addEventListener("didUpdate", ({ delta: l, hasLayoutChanged: c }) => { this.isDragging && c && (ht(d => { const f = this.getAxisMotionValue(d); f && (this.originPoint[d] += l[d].translate, f.set(f.get() + l[d].translate)) }), this.visualElement.render()) }); return () => { o(), n(), i(), a && a() } } getProps() { const t = this.visualElement.getProps(), { drag: n = !1, dragDirectionLock: r = !1, dragPropagation: s = !1, dragConstraints: i = !1, dragElastic: o = fd, dragMomentum: a = !0 } = t; return { ...t, drag: n, dragDirectionLock: r, dragPropagation: s, dragConstraints: i, dragElastic: o, dragMomentum: a } } } function ta(e, t, n) { return (t === !0 || t === e) && (n === null || n === e) } function dA(e, t = 10) { let n = null; return Math.abs(e.y) > t ? n = "y" : Math.abs(e.x) > t && (n = "x"), n } class fA extends dr { constructor(t) { super(t), this.removeGroupControls = wt, this.removeListeners = wt, this.controls = new uA(t) } mount() { const { dragControls: t } = this.node.getProps(); t && (this.removeGroupControls = t.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || wt } unmount() { this.removeGroupControls(), this.removeListeners() } } const ng = e => (t, n) => { e && ue.postRender(() => e(t, n)) }; class hA extends dr { constructor() { super(...arguments), this.removePointerDownListener = wt } onPointerDown(t) { this.session = new e1(t, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint(), contextWindow: Jw(this.node) }) } createPanHandlers() { const { onPanSessionStart: t, onPanStart: n, onPan: r, onPanEnd: s } = this.node.getProps(); return { onSessionStart: ng(t), onStart: ng(n), onMove: r, onEnd: (i, o) => { delete this.session, s && ue.postRender(() => s(i, o)) } } } mount() { this.removePointerDownListener = Di(this.node.current, "pointerdown", t => this.onPointerDown(t)) } update() { this.session && this.session.updateHandlers(this.createPanHandlers()) } unmount() { this.removePointerDownListener(), this.session && this.session.end() } } const wa = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }; let Mc = !1; class pA extends x.Component { componentDidMount() { const { visualElement: t, layoutGroup: n, switchLayoutGroup: r, layoutId: s } = this.props, { projection: i } = t; i && (n.group && n.group.add(i), r && r.register && s && r.register(i), Mc && i.root.didUpdate(), i.addEventListener("animationComplete", () => { this.safeToRemove() }), i.setOptions({ ...i.options, onExitComplete: () => this.safeToRemove() })), wa.hasEverUpdated = !0 } getSnapshotBeforeUpdate(t) { const { layoutDependency: n, visualElement: r, drag: s, isPresent: i } = this.props, { projection: o } = r; return o && (o.isPresent = i, Mc = !0, s || t.layoutDependency !== n || n === void 0 || t.isPresent !== i ? o.willUpdate() : this.safeToRemove(), t.isPresent !== i && (i ? o.promote() : o.relegate() || ue.postRender(() => { const a = o.getStack(); (!a || !a.members.length) && this.safeToRemove() }))), null } componentDidUpdate() { const { projection: t } = this.props.visualElement; t && (t.root.didUpdate(), Xf.postRender(() => { !t.currentAnimation && t.isLead() && this.safeToRemove() })) } componentWillUnmount() { const { visualElement: t, layoutGroup: n, switchLayoutGroup: r } = this.props, { projection: s } = t; Mc = !0, s && (s.scheduleCheckAfterUnmount(), n && n.group && n.group.remove(s), r && r.deregister && r.deregister(s)) } safeToRemove() { const { safeToRemove: t } = this.props; t && t() } render() { return null } } function n1(e) { const [t, n] = kw(), r = x.useContext(Af); return u.jsx(pA, { ...e, layoutGroup: r, switchLayoutGroup: x.useContext(Iw), isPresent: t, safeToRemove: n }) } function mA(e, t, n) { const r = Be(e) ? e : Ws(e); return r.start(lh("", r, t, n)), r.animation } const gA = (e, t) => e.depth - t.depth; class yA { constructor() { this.children = [], this.isDirty = !1 } add(t) { Lf(this.children, t), this.isDirty = !0 } remove(t) { Of(this.children, t), this.isDirty = !0 } forEach(t) { this.isDirty && this.children.sort(gA), this.isDirty = !1, this.children.forEach(t) } } function vA(e, t) { const n = Je.now(), r = ({ timestamp: s }) => { const i = s - n; i >= t && (or(r), e(i - t)) }; return ue.setup(r, !0), () => or(r) } const r1 = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], xA = r1.length, rg = e => typeof e == "string" ? parseFloat(e) : e, sg = e => typeof e == "number" || B.test(e); function wA(e, t, n, r, s, i) { s ? (e.opacity = he(0, n.opacity ?? 1, bA(r)), e.opacityExit = he(t.opacity ?? 1, 0, SA(r))) : i && (e.opacity = he(t.opacity ?? 1, n.opacity ?? 1, r)); for (let o = 0; o < xA; o++) { const a = `border${r1[o]}Radius`; let l = ig(t, a), c = ig(n, a); if (l === void 0 && c === void 0) continue; l || (l = 0), c || (c = 0), l === 0 || c === 0 || sg(l) === sg(c) ? (e[a] = Math.max(he(rg(l), rg(c), r), 0), (en.test(c) || en.test(l)) && (e[a] += "%")) : e[a] = c } (t.rotate || n.rotate) && (e.rotate = he(t.rotate || 0, n.rotate || 0, r)) } function ig(e, t) { return e[t] !== void 0 ? e[t] : e.borderRadius } const bA = s1(0, .5, Ux), SA = s1(.5, .95, wt); function s1(e, t, n) { return r => r < e ? 0 : r > t ? 1 : n(io(e, t, r)) } function og(e, t) { e.min = t.min, e.max = t.max } function Pt(e, t) { og(e.x, t.x), og(e.y, t.y) } function ag(e, t) { e.translate = t.translate, e.scale = t.scale, e.originPoint = t.originPoint, e.origin = t.origin } function lg(e, t, n, r, s) { return e -= t, e = rl(e, 1 / n, r), s !== void 0 && (e = rl(e, 1 / s, r)), e } function CA(e, t = 0, n = 1, r = .5, s, i = e, o = e) { if (en.test(t) && (t = parseFloat(t), t = he(o.min, o.max, t / 100) - o.min), typeof t != "number") return; let a = he(i.min, i.max, r); e === i && (a -= t), e.min = lg(e.min, t, n, a, s), e.max = lg(e.max, t, n, a, s) } function cg(e, t, [n, r, s], i, o) { CA(e, t[n], t[r], t[s], t.scale, i, o) } const kA = ["x", "scaleX", "originX"], TA = ["y", "scaleY", "originY"]; function ug(e, t, n, r) { cg(e.x, t, kA, n ? n.x : void 0, r ? r.x : void 0), cg(e.y, t, TA, n ? n.y : void 0, r ? r.y : void 0) } function dg(e) { return e.translate === 0 && e.scale === 1 } function i1(e) { return dg(e.x) && dg(e.y) } function fg(e, t) { return e.min === t.min && e.max === t.max } function EA(e, t) { return fg(e.x, t.x) && fg(e.y, t.y) } function hg(e, t) { return Math.round(e.min) === Math.round(t.min) && Math.round(e.max) === Math.round(t.max) } function o1(e, t) { return hg(e.x, t.x) && hg(e.y, t.y) } function pg(e) { return Ke(e.x) / Ke(e.y) } function mg(e, t) { return e.translate === t.translate && e.scale === t.scale && e.originPoint === t.originPoint } class NA { constructor() { this.members = [] } add(t) { Lf(this.members, t), t.scheduleRender() } remove(t) { if (Of(this.members, t), t === this.prevLead && (this.prevLead = void 0), t === this.lead) { const n = this.members[this.members.length - 1]; n && this.promote(n) } } relegate(t) { const n = this.members.findIndex(s => t === s); if (n === 0) return !1; let r; for (let s = n; s >= 0; s--) { const i = this.members[s]; if (i.isPresent !== !1) { r = i; break } } return r ? (this.promote(r), !0) : !1 } promote(t, n) { const r = this.lead; if (t !== r && (this.prevLead = r, this.lead = t, t.show(), r)) { r.instance && r.scheduleRender(), t.scheduleRender(), t.resumeFrom = r, n && (t.resumeFrom.preserveOpacity = !0), r.snapshot && (t.snapshot = r.snapshot, t.snapshot.latestValues = r.animationValues || r.latestValues), t.root && t.root.isUpdating && (t.isLayoutDirty = !0); const { crossfade: s } = t.options; s === !1 && r.hide() } } exitAnimationComplete() { this.members.forEach(t => { const { options: n, resumingFrom: r } = t; n.onExitComplete && n.onExitComplete(), r && r.options.onExitComplete && r.options.onExitComplete() }) } scheduleRender() { this.members.forEach(t => { t.instance && t.scheduleRender(!1) }) } removeLeadSnapshot() { this.lead && this.lead.snapshot && (this.lead.snapshot = void 0) } } function PA(e, t, n) { let r = ""; const s = e.x.translate / t.x, i = e.y.translate / t.y, o = (n == null ? void 0 : n.z) || 0; if ((s || i || o) && (r = `translate3d(${s}px, ${i}px, ${o}px) `), (t.x !== 1 || t.y !== 1) && (r += `scale(${1 / t.x}, ${1 / t.y}) `), n) { const { transformPerspective: c, rotate: d, rotateX: f, rotateY: h, skewX: p, skewY: w } = n; c && (r = `perspective(${c}px) ${r}`), d && (r += `rotate(${d}deg) `), f && (r += `rotateX(${f}deg) `), h && (r += `rotateY(${h}deg) `), p && (r += `skewX(${p}deg) `), w && (r += `skewY(${w}deg) `) } const a = e.x.scale * t.x, l = e.y.scale * t.y; return (a !== 1 || l !== 1) && (r += `scale(${a}, ${l})`), r || "none" } const Dc = ["", "X", "Y", "Z"], jA = 1e3; let RA = 0; function Lc(e, t, n, r) { const { latestValues: s } = t; s[e] && (n[e] = s[e], t.setStaticValue(e, 0), r && (r[e] = 0)) } function a1(e) { if (e.hasCheckedOptimisedAppear = !0, e.root === e) return; const { visualElement: t } = e.options; if (!t) return; const n = Kw(t); if (window.MotionHasOptimisedAnimation(n, "transform")) { const { layout: s, layoutId: i } = e.options; window.MotionCancelOptimisedAnimation(n, "transform", ue, !(s || i)) } const { parent: r } = e; r && !r.hasCheckedOptimisedAppear && a1(r) } function l1({ attachResizeListener: e, defaultParent: t, measureScroll: n, checkIsScrollRoot: r, resetTransform: s }) { return class { constructor(o = {}, a = t == null ? void 0 : t()) { this.id = RA++, this.animationId = 0, this.animationCommitId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.layoutVersion = 0, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => { this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots()) }, this.updateProjection = () => { this.projectionUpdateScheduled = !1, this.nodes.forEach(DA), this.nodes.forEach(FA), this.nodes.forEach(VA), this.nodes.forEach(LA) }, this.resolvedRelativeTargetAt = 0, this.linkedParentVersion = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = o, this.root = a ? a.root || a : this, this.path = a ? [...a.path, a] : [], this.parent = a, this.depth = a ? a.depth + 1 : 0; for (let l = 0; l < this.path.length; l++)this.path[l].shouldResetTransform = !0; this.root === this && (this.nodes = new yA) } addEventListener(o, a) { return this.eventHandlers.has(o) || this.eventHandlers.set(o, new Ff), this.eventHandlers.get(o).add(a) } notifyListeners(o, ...a) { const l = this.eventHandlers.get(o); l && l.notify(...a) } hasListeners(o) { return this.eventHandlers.has(o) } mount(o) { if (this.instance) return; this.isSVG = Cw(o) && !Sj(o), this.instance = o; const { layoutId: a, layout: l, visualElement: c } = this.options; if (c && !c.current && c.mount(o), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.root.hasTreeAnimated && (l || a) && (this.isLayoutDirty = !0), e) { let d, f = 0; const h = () => this.root.updateBlockedByResize = !1; ue.read(() => { f = window.innerWidth }), e(o, () => { const p = window.innerWidth; p !== f && (f = p, this.root.updateBlockedByResize = !0, d && d(), d = vA(h, 250), wa.hasAnimatedSinceResize && (wa.hasAnimatedSinceResize = !1, this.nodes.forEach(vg))) }) } a && this.root.registerSharedNode(a, this), this.options.animate !== !1 && c && (a || l) && this.addEventListener("didUpdate", ({ delta: d, hasLayoutChanged: f, hasRelativeLayoutChanged: h, layout: p }) => { if (this.isTreeAnimationBlocked()) { this.target = void 0, this.relativeTarget = void 0; return } const w = this.options.transition || c.getDefaultTransition() || UA, { onLayoutAnimationStart: y, onLayoutAnimationComplete: b } = c.getProps(), g = !this.targetLayout || !o1(this.targetLayout, p), m = !f && h; if (this.options.layoutRoot || this.resumeFrom || m || f && (g || !this.currentAnimation)) { this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0); const v = { ...Qf(w, "layout"), onPlay: y, onComplete: b }; (c.shouldReduceMotion || this.options.layoutRoot) && (v.delay = 0, v.type = !1), this.startAnimation(v), this.setAnimationOrigin(d, m) } else f || vg(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete(); this.targetLayout = p }) } unmount() { this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this); const o = this.getStack(); o && o.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, this.eventHandlers.clear(), or(this.updateProjection) } blockUpdate() { this.updateManuallyBlocked = !0 } unblockUpdate() { this.updateManuallyBlocked = !1 } isUpdateBlocked() { return this.updateManuallyBlocked || this.updateBlockedByResize } isTreeAnimationBlocked() { return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1 } startUpdate() { this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(_A), this.animationId++) } getTransformTemplate() { const { visualElement: o } = this.options; return o && o.getProps().transformTemplate } willUpdate(o = !0) { if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) { this.options.onExitComplete && this.options.onExitComplete(); return } if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && a1(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return; this.isLayoutDirty = !0; for (let d = 0; d < this.path.length; d++) { const f = this.path[d]; f.shouldResetTransform = !0, f.updateScroll("snapshot"), f.options.layoutRoot && f.willUpdate(!1) } const { layoutId: a, layout: l } = this.options; if (a === void 0 && !l) return; const c = this.getTransformTemplate(); this.prevTransformTemplateValue = c ? c(this.latestValues, "") : void 0, this.updateSnapshot(), o && this.notifyListeners("willUpdate") } update() { if (this.updateScheduled = !1, this.isUpdateBlocked()) { this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(gg); return } if (this.animationId <= this.animationCommitId) { this.nodes.forEach(yg); return } this.animationCommitId = this.animationId, this.isUpdating ? (this.isUpdating = !1, this.nodes.forEach(IA), this.nodes.forEach(AA), this.nodes.forEach(MA)) : this.nodes.forEach(yg), this.clearAllSnapshots(); const a = Je.now(); Me.delta = xn(0, 1e3 / 60, a - Me.timestamp), Me.timestamp = a, Me.isProcessing = !0, Sc.update.process(Me), Sc.preRender.process(Me), Sc.render.process(Me), Me.isProcessing = !1 } didUpdate() { this.updateScheduled || (this.updateScheduled = !0, Xf.read(this.scheduleUpdate)) } clearAllSnapshots() { this.nodes.forEach(OA), this.sharedNodes.forEach(zA) } scheduleUpdateProjection() { this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, ue.preRender(this.updateProjection, !1, !0)) } scheduleCheckAfterUnmount() { ue.postRender(() => { this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed() }) } updateSnapshot() { this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !Ke(this.snapshot.measuredBox.x) && !Ke(this.snapshot.measuredBox.y) && (this.snapshot = void 0)) } updateLayout() { if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return; if (this.resumeFrom && !this.resumeFrom.instance) for (let l = 0; l < this.path.length; l++)this.path[l].updateScroll(); const o = this.layout; this.layout = this.measure(!1), this.layoutVersion++, this.layoutCorrected = Te(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox); const { visualElement: a } = this.options; a && a.notify("LayoutMeasure", this.layout.layoutBox, o ? o.layoutBox : void 0) } updateScroll(o = "measure") { let a = !!(this.options.layoutScroll && this.instance); if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === o && (a = !1), a && this.instance) { const l = r(this.instance); this.scroll = { animationId: this.root.animationId, phase: o, isRoot: l, offset: n(this.instance), wasRoot: this.scroll ? this.scroll.isRoot : l } } } resetTransform() { if (!s) return; const o = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, a = this.projectionDelta && !i1(this.projectionDelta), l = this.getTransformTemplate(), c = l ? l(this.latestValues, "") : void 0, d = c !== this.prevTransformTemplateValue; o && this.instance && (a || xr(this.latestValues) || d) && (s(this.instance, c), this.shouldResetTransform = !1, this.scheduleRender()) } measure(o = !0) { const a = this.measurePageBox(); let l = this.removeElementScroll(a); return o && (l = this.removeTransform(l)), WA(l), { animationId: this.root.animationId, measuredBox: a, layoutBox: l, latestValues: {}, source: this.id } } measurePageBox() { var c; const { visualElement: o } = this.options; if (!o) return Te(); const a = o.measureViewportBox(); if (!(((c = this.scroll) == null ? void 0 : c.wasRoot) || this.path.some(HA))) { const { scroll: d } = this.root; d && (ps(a.x, d.offset.x), ps(a.y, d.offset.y)) } return a } removeElementScroll(o) { var l; const a = Te(); if (Pt(a, o), (l = this.scroll) != null && l.wasRoot) return a; for (let c = 0; c < this.path.length; c++) { const d = this.path[c], { scroll: f, options: h } = d; d !== this.root && f && h.layoutScroll && (f.wasRoot && Pt(a, o), ps(a.x, f.offset.x), ps(a.y, f.offset.y)) } return a } applyTransform(o, a = !1) { const l = Te(); Pt(l, o); for (let c = 0; c < this.path.length; c++) { const d = this.path[c]; !a && d.options.layoutScroll && d.scroll && d !== d.root && ms(l, { x: -d.scroll.offset.x, y: -d.scroll.offset.y }), xr(d.latestValues) && ms(l, d.latestValues) } return xr(this.latestValues) && ms(l, this.latestValues), l } removeTransform(o) { const a = Te(); Pt(a, o); for (let l = 0; l < this.path.length; l++) { const c = this.path[l]; if (!c.instance || !xr(c.latestValues)) continue; od(c.latestValues) && c.updateSnapshot(); const d = Te(), f = c.measurePageBox(); Pt(d, f), ug(a, c.latestValues, c.snapshot ? c.snapshot.layoutBox : void 0, d) } return xr(this.latestValues) && ug(a, this.latestValues), a } setTargetDelta(o) { this.targetDelta = o, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0 } setOptions(o) { this.options = { ...this.options, ...o, crossfade: o.crossfade !== void 0 ? o.crossfade : !0 } } clearMeasurements() { this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1 } forceRelativeParentToResolveTarget() { this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Me.timestamp && this.relativeParent.resolveTargetDelta(!0) } resolveTargetDelta(o = !1) { var p; const a = this.getLead(); this.isProjectionDirty || (this.isProjectionDirty = a.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = a.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = a.isSharedProjectionDirty); const l = !!this.resumingFrom || this !== a; if (!(o || l && this.isSharedProjectionDirty || this.isProjectionDirty || (p = this.parent) != null && p.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return; const { layout: d, layoutId: f } = this.options; if (!this.layout || !(d || f)) return; this.resolvedRelativeTargetAt = Me.timestamp; const h = this.getClosestProjectingParent(); h && this.linkedParentVersion !== h.layoutVersion && !h.options.layoutRoot && this.removeRelativeTarget(), !this.targetDelta && !this.relativeTarget && (h && h.layout ? this.createRelativeTarget(h, this.layout.layoutBox, h.layout.layoutBox) : this.removeRelativeTarget()), !(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = Te(), this.targetWithTransforms = Te()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), JR(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : Pt(this.target, this.layout.layoutBox), zw(this.target, this.targetDelta)) : Pt(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget && (this.attemptToResolveRelativeTarget = !1, h && !!h.resumingFrom == !!this.resumingFrom && !h.options.layoutScroll && h.target && this.animationProgress !== 1 ? this.createRelativeTarget(h, this.target, h.target) : this.relativeParent = this.relativeTarget = void 0)) } getClosestProjectingParent() { if (!(!this.parent || od(this.parent.latestValues) || _w(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent() } isProjecting() { return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout) } createRelativeTarget(o, a, l) { this.relativeParent = o, this.linkedParentVersion = o.layoutVersion, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Te(), this.relativeTargetOrigin = Te(), sl(this.relativeTargetOrigin, a, l), Pt(this.relativeTarget, this.relativeTargetOrigin) } removeRelativeTarget() { this.relativeParent = this.relativeTarget = void 0 } calcProjection() { var w; const o = this.getLead(), a = !!this.resumingFrom || this !== o; let l = !0; if ((this.isProjectionDirty || (w = this.parent) != null && w.isProjectionDirty) && (l = !1), a && (this.isSharedProjectionDirty || this.isTransformDirty) && (l = !1), this.resolvedRelativeTargetAt === Me.timestamp && (l = !1), l) return; const { layout: c, layoutId: d } = this.options; if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(c || d)) return; Pt(this.layoutCorrected, this.layout.layoutBox); const f = this.treeScale.x, h = this.treeScale.y; dR(this.layoutCorrected, this.treeScale, this.path, a), o.layout && !o.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (o.target = o.layout.layoutBox, o.targetWithTransforms = Te()); const { target: p } = o; if (!p) { this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender()); return } !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (ag(this.prevProjectionDelta.x, this.projectionDelta.x), ag(this.prevProjectionDelta.y, this.projectionDelta.y)), Li(this.projectionDelta, this.layoutCorrected, p, this.latestValues), (this.treeScale.x !== f || this.treeScale.y !== h || !mg(this.projectionDelta.x, this.prevProjectionDelta.x) || !mg(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", p)) } hide() { this.isVisible = !1 } show() { this.isVisible = !0 } scheduleRender(o = !0) { var a; if ((a = this.options.visualElement) == null || a.scheduleRender(), o) { const l = this.getStack(); l && l.scheduleRender() } this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0) } createProjectionDeltas() { this.prevProjectionDelta = gs(), this.projectionDelta = gs(), this.projectionDeltaWithTransform = gs() } setAnimationOrigin(o, a = !1) { const l = this.snapshot, c = l ? l.latestValues : {}, d = { ...this.latestValues }, f = gs(); (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a; const h = Te(), p = l ? l.source : void 0, w = this.layout ? this.layout.source : void 0, y = p !== w, b = this.getStack(), g = !b || b.members.length <= 1, m = !!(y && !g && this.options.crossfade === !0 && !this.path.some($A)); this.animationProgress = 0; let v; this.mixTargetDelta = S => { const C = S / 1e3; xg(f.x, o.x, C), xg(f.y, o.y, C), this.setTargetDelta(f), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (sl(h, this.layout.layoutBox, this.relativeParent.layout.layoutBox), BA(this.relativeTarget, this.relativeTargetOrigin, h, C), v && EA(this.relativeTarget, v) && (this.isProjectionDirty = !1), v || (v = Te()), Pt(v, this.relativeTarget)), y && (this.animationValues = d, wA(d, c, this.latestValues, C, m, g)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = C }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0) } startAnimation(o) { var a, l, c; this.notifyListeners("animationStart"), (a = this.currentAnimation) == null || a.stop(), (c = (l = this.resumingFrom) == null ? void 0 : l.currentAnimation) == null || c.stop(), this.pendingAnimation && (or(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = ue.update(() => { wa.hasAnimatedSinceResize = !0, this.motionValue || (this.motionValue = Ws(0)), this.currentAnimation = mA(this.motionValue, [0, 1e3], { ...o, velocity: 0, isSync: !0, onUpdate: d => { this.mixTargetDelta(d), o.onUpdate && o.onUpdate(d) }, onStop: () => { }, onComplete: () => { o.onComplete && o.onComplete(), this.completeAnimation() } }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0 }) } completeAnimation() { this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0); const o = this.getStack(); o && o.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete") } finishAnimation() { this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(jA), this.currentAnimation.stop()), this.completeAnimation() } applyTransformsToTarget() { const o = this.getLead(); let { targetWithTransforms: a, target: l, layout: c, latestValues: d } = o; if (!(!a || !l || !c)) { if (this !== o && this.layout && c && c1(this.options.animationType, this.layout.layoutBox, c.layoutBox)) { l = this.target || Te(); const f = Ke(this.layout.layoutBox.x); l.x.min = o.target.x.min, l.x.max = l.x.min + f; const h = Ke(this.layout.layoutBox.y); l.y.min = o.target.y.min, l.y.max = l.y.min + h } Pt(a, l), ms(a, d), Li(this.projectionDeltaWithTransform, this.layoutCorrected, a, d) } } registerSharedNode(o, a) { this.sharedNodes.has(o) || this.sharedNodes.set(o, new NA), this.sharedNodes.get(o).add(a); const c = a.options.initialPromotionConfig; a.promote({ transition: c ? c.transition : void 0, preserveFollowOpacity: c && c.shouldPreserveFollowOpacity ? c.shouldPreserveFollowOpacity(a) : void 0 }) } isLead() { const o = this.getStack(); return o ? o.lead === this : !0 } getLead() { var a; const { layoutId: o } = this.options; return o ? ((a = this.getStack()) == null ? void 0 : a.lead) || this : this } getPrevLead() { var a; const { layoutId: o } = this.options; return o ? (a = this.getStack()) == null ? void 0 : a.prevLead : void 0 } getStack() { const { layoutId: o } = this.options; if (o) return this.root.sharedNodes.get(o) } promote({ needsReset: o, transition: a, preserveFollowOpacity: l } = {}) { const c = this.getStack(); c && c.promote(this, l), o && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({ transition: a }) } relegate() { const o = this.getStack(); return o ? o.relegate(this) : !1 } resetSkewAndRotation() { const { visualElement: o } = this.options; if (!o) return; let a = !1; const { latestValues: l } = o; if ((l.z || l.rotate || l.rotateX || l.rotateY || l.rotateZ || l.skewX || l.skewY) && (a = !0), !a) return; const c = {}; l.z && Lc("z", o, c, this.animationValues); for (let d = 0; d < Dc.length; d++)Lc(`rotate${Dc[d]}`, o, c, this.animationValues), Lc(`skew${Dc[d]}`, o, c, this.animationValues); o.render(); for (const d in c) o.setStaticValue(d, c[d]), this.animationValues && (this.animationValues[d] = c[d]); o.scheduleRender() } applyProjectionStyles(o, a) { if (!this.instance || this.isSVG) return; if (!this.isVisible) { o.visibility = "hidden"; return } const l = this.getTransformTemplate(); if (this.needsReset) { this.needsReset = !1, o.visibility = "", o.opacity = "", o.pointerEvents = xa(a == null ? void 0 : a.pointerEvents) || "", o.transform = l ? l(this.latestValues, "") : "none"; return } const c = this.getLead(); if (!this.projectionDelta || !this.layout || !c.target) { this.options.layoutId && (o.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, o.pointerEvents = xa(a == null ? void 0 : a.pointerEvents) || ""), this.hasProjected && !xr(this.latestValues) && (o.transform = l ? l({}, "") : "none", this.hasProjected = !1); return } o.visibility = ""; const d = c.animationValues || c.latestValues; this.applyTransformsToTarget(); let f = PA(this.projectionDeltaWithTransform, this.treeScale, d); l && (f = l(d, f)), o.transform = f; const { x: h, y: p } = this.projectionDelta; o.transformOrigin = `${h.origin * 100}% ${p.origin * 100}% 0`, c.animationValues ? o.opacity = c === this ? d.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : d.opacityExit : o.opacity = c === this ? d.opacity !== void 0 ? d.opacity : "" : d.opacityExit !== void 0 ? d.opacityExit : 0; for (const w in id) { if (d[w] === void 0) continue; const { correct: y, applyTo: b, isCSSVariable: g } = id[w], m = f === "none" ? d[w] : y(d[w], c); if (b) { const v = b.length; for (let S = 0; S < v; S++)o[b[S]] = m } else g ? this.options.visualElement.renderState.vars[w] = m : o[w] = m } this.options.layoutId && (o.pointerEvents = c === this ? xa(a == null ? void 0 : a.pointerEvents) || "" : "none") } clearSnapshot() { this.resumeFrom = this.snapshot = void 0 } resetTree() { this.root.nodes.forEach(o => { var a; return (a = o.currentAnimation) == null ? void 0 : a.stop() }), this.root.nodes.forEach(gg), this.root.sharedNodes.clear() } } } function AA(e) { e.updateLayout() } function MA(e) { var n; const t = ((n = e.resumeFrom) == null ? void 0 : n.snapshot) || e.snapshot; if (e.isLead() && e.layout && t && e.hasListeners("didUpdate")) { const { layoutBox: r, measuredBox: s } = e.layout, { animationType: i } = e.options, o = t.source !== e.layout.source; i === "size" ? ht(f => { const h = o ? t.measuredBox[f] : t.layoutBox[f], p = Ke(h); h.min = r[f].min, h.max = h.min + p }) : c1(i, t.layoutBox, r) && ht(f => { const h = o ? t.measuredBox[f] : t.layoutBox[f], p = Ke(r[f]); h.max = h.min + p, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[f].max = e.relativeTarget[f].min + p) }); const a = gs(); Li(a, r, t.layoutBox); const l = gs(); o ? Li(l, e.applyTransform(s, !0), t.measuredBox) : Li(l, r, t.layoutBox); const c = !i1(a); let d = !1; if (!e.resumeFrom) { const f = e.getClosestProjectingParent(); if (f && !f.resumeFrom) { const { snapshot: h, layout: p } = f; if (h && p) { const w = Te(); sl(w, t.layoutBox, h.layoutBox); const y = Te(); sl(y, r, p.layoutBox), o1(w, y) || (d = !0), f.options.layoutRoot && (e.relativeTarget = y, e.relativeTargetOrigin = w, e.relativeParent = f) } } } e.notifyListeners("didUpdate", { layout: r, snapshot: t, delta: l, layoutDelta: a, hasLayoutChanged: c, hasRelativeLayoutChanged: d }) } else if (e.isLead()) { const { onExitComplete: r } = e.options; r && r() } e.options.transition = void 0 } function DA(e) { e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty)) } function LA(e) { e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1 } function OA(e) { e.clearSnapshot() } function gg(e) { e.clearMeasurements() } function yg(e) { e.isLayoutDirty = !1 } function IA(e) { const { visualElement: t } = e.options; t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"), e.resetTransform() } function vg(e) { e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0 } function FA(e) { e.resolveTargetDelta() } function VA(e) { e.calcProjection() } function _A(e) { e.resetSkewAndRotation() } function zA(e) { e.removeLeadSnapshot() } function xg(e, t, n) { e.translate = he(t.translate, 0, n), e.scale = he(t.scale, 1, n), e.origin = t.origin, e.originPoint = t.originPoint } function wg(e, t, n, r) { e.min = he(t.min, n.min, r), e.max = he(t.max, n.max, r) } function BA(e, t, n, r) { wg(e.x, t.x, n.x, r), wg(e.y, t.y, n.y, r) } function $A(e) { return e.animationValues && e.animationValues.opacityExit !== void 0 } const UA = { duration: .45, ease: [.4, 0, .1, 1] }, bg = e => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e), Sg = bg("applewebkit/") && !bg("chrome/") ? Math.round : wt; function Cg(e) { e.min = Sg(e.min), e.max = Sg(e.max) } function WA(e) { Cg(e.x), Cg(e.y) } function c1(e, t, n) { return e === "position" || e === "preserve-aspect" && !ZR(pg(t), pg(n), .2) } function HA(e) { var t; return e !== e.root && ((t = e.scroll) == null ? void 0 : t.wasRoot) } const KA = l1({ attachResizeListener: (e, t) => co(e, "resize", t), measureScroll: () => ({ x: document.documentElement.scrollLeft || document.body.scrollLeft, y: document.documentElement.scrollTop || document.body.scrollTop }), checkIsScrollRoot: () => !0 }), Oc = { current: void 0 }, u1 = l1({ measureScroll: e => ({ x: e.scrollLeft, y: e.scrollTop }), defaultParent: () => { if (!Oc.current) { const e = new KA({}); e.mount(window), e.setOptions({ layoutScroll: !0 }), Oc.current = e } return Oc.current }, resetTransform: (e, t) => { e.style.transform = t !== void 0 ? t : "none" }, checkIsScrollRoot: e => window.getComputedStyle(e).position === "fixed" }), YA = { pan: { Feature: hA }, drag: { Feature: fA, ProjectionNode: u1, MeasureLayout: n1 } }; function kg(e, t, n) { const { props: r } = e; e.animationState && r.whileHover && e.animationState.setActive("whileHover", n === "Start"); const s = "onHover" + n, i = r[s]; i && ue.postRender(() => i(t, To(t))) } class GA extends dr { mount() { const { current: t } = this.node; t && (this.unmount = yj(t, (n, r) => (kg(this.node, r, "Start"), s => kg(this.node, s, "End")))) } unmount() { } } class QA extends dr { constructor() { super(...arguments), this.isActive = !1 } onFocus() { let t = !1; try { t = this.node.current.matches(":focus-visible") } catch { t = !0 } !t || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0) } onBlur() { !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1) } mount() { this.unmount = So(co(this.node.current, "focus", () => this.onFocus()), co(this.node.current, "blur", () => this.onBlur())) } unmount() { } } function Tg(e, t, n) { const { props: r } = e; if (e.current instanceof HTMLButtonElement && e.current.disabled) return; e.animationState && r.whileTap && e.animationState.setActive("whileTap", n === "Start"); const s = "onTap" + (n === "End" ? "" : n), i = r[s]; i && ue.postRender(() => i(t, To(t))) } class qA extends dr { mount() { const { current: t } = this.node; t && (this.unmount = bj(t, (n, r) => (Tg(this.node, r, "Start"), (s, { success: i }) => Tg(this.node, s, i ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget })) } unmount() { } } const hd = new WeakMap, Ic = new WeakMap, XA = e => { const t = hd.get(e.target); t && t(e) }, ZA = e => { e.forEach(XA) }; function JA({ root: e, ...t }) { const n = e || document; Ic.has(n) || Ic.set(n, {}); const r = Ic.get(n), s = JSON.stringify(t); return r[s] || (r[s] = new IntersectionObserver(ZA, { root: e, ...t })), r[s] } function eM(e, t, n) { const r = JA(t); return hd.set(e, n), r.observe(e), () => { hd.delete(e), r.unobserve(e) } } const tM = { some: 0, all: 1 }; class nM extends dr { constructor() { super(...arguments), this.hasEnteredView = !1, this.isInView = !1 } startObserver() { this.unmount(); const { viewport: t = {} } = this.node.getProps(), { root: n, margin: r, amount: s = "some", once: i } = t, o = { root: n ? n.current : void 0, rootMargin: r, threshold: typeof s == "number" ? s : tM[s] }, a = l => { const { isIntersecting: c } = l; if (this.isInView === c || (this.isInView = c, i && !c && this.hasEnteredView)) return; c && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", c); const { onViewportEnter: d, onViewportLeave: f } = this.node.getProps(), h = c ? d : f; h && h(l) }; return eM(this.node.current, o, a) } mount() { this.startObserver() } update() { if (typeof IntersectionObserver > "u") return; const { props: t, prevProps: n } = this.node;["amount", "margin", "root"].some(rM(t, n)) && this.startObserver() } unmount() { } } function rM({ viewport: e = {} }, { viewport: t = {} } = {}) { return n => e[n] !== t[n] } const sM = { inView: { Feature: nM }, tap: { Feature: qA }, focus: { Feature: QA }, hover: { Feature: GA } }, iM = { layout: { ProjectionNode: u1, MeasureLayout: n1 } }, oM = { ...KR, ...sM, ...YA, ...iM }, K = lR(oM, bR), aM = "/assets/hero-steakhouse-Cs7R1vV3.jpg", d1 = "/assets/menu-muttonchop-DIfIoEGg.jpg", ch = "/assets/history-pipes-BnYO-eNP.jpg", pd = "/assets/private-dining-room-CW_p3SPv.jpg", Eg = [{ name: "Menus", href: "/menus" }, { name: "History", href: "/history" }, { name: "Private Dining", href: "/private-dining" }, { name: "Reservations", href: "/reservations" }, { name: "Contact", href: "/contact" }]; function lM() { const [e, t] = x.useState(!1), [n, r] = x.useState(!1), [s, i] = x.useState(!1), o = Js(); return x.useEffect(() => { const a = () => { t(window.scrollY > 50) }; return window.addEventListener("scroll", a), () => window.removeEventListener("scroll", a) }, []), x.useEffect(() => { r(!1) }, [o]), u.jsxs(u.Fragment, { children: [u.jsx("header", { className: `fixed top-0 left-0 right-0 z-50 transition-all duration-500 ${e ? "bg-charcoal/95 backdrop-blur-md shadow-elegant py-3" : "bg-transparent py-6"}`, children: u.jsxs("nav", { className: "keens-container flex items-center justify-between", "aria-label": "Main navigation", children: [u.jsx(fe, { to: "/", className: `transition-transform duration-500 ${e ? "scale-90" : "scale-100"}`, "aria-label": "Keens Steakhouse Home", children: u.jsxs("div", { className: "flex items-center gap-3", children: [u.jsx("span", { className: "font-heading text-2xl md:text-3xl text-primary tracking-wide", children: "KEENS" }), u.jsx("span", { className: "hidden sm:block text-foreground/60 text-sm font-body tracking-widest uppercase", children: "Est. 1885" })] }) }), u.jsx("div", { className: "hidden lg:flex items-center gap-8", children: Eg.map(a => u.jsx(fe, { to: a.href, className: `font-body text-sm tracking-wide uppercase transition-colors duration-300 hover:text-primary ${o.pathname === a.href ? "text-primary" : "text-foreground/80"}`, children: a.name }, a.name)) }), u.jsxs("div", { className: "flex items-center gap-4", children: [u.jsx("button", { onClick: () => i(!0), className: "p-2 text-foreground/80 hover:text-primary transition-colors", "aria-label": "Search", children: u.jsx(tk, { className: "w-5 h-5" }) }), u.jsx(fe, { to: "/reservations", className: "hidden sm:block btn-gold text-sm", children: "Book a Table" }), u.jsx("button", { onClick: () => r(!0), className: "lg:hidden p-2 text-foreground/80 hover:text-primary transition-colors", "aria-label": "Open menu", "aria-expanded": n, children: u.jsx(ek, { className: "w-6 h-6" }) })] })] }) }), u.jsx(Dm, { children: n && u.jsx(K.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 z-[60] bg-charcoal/98 backdrop-blur-lg lg:hidden", children: u.jsxs("div", { className: "flex flex-col h-full", children: [u.jsxs("div", { className: "flex items-center justify-between p-6", children: [u.jsx("span", { className: "font-heading text-2xl text-primary", children: "KEENS" }), u.jsx("button", { onClick: () => r(!1), className: "p-2 text-foreground/80 hover:text-primary transition-colors", "aria-label": "Close menu", children: u.jsx(Lu, { className: "w-6 h-6" }) })] }), u.jsx("nav", { className: "flex-1 flex flex-col items-center justify-center gap-8", children: Eg.map((a, l) => u.jsx(K.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { delay: l * .1 }, children: u.jsx(fe, { to: a.href, className: `font-heading text-3xl tracking-wide transition-colors duration-300 hover:text-primary ${o.pathname === a.href ? "text-primary" : "text-foreground"}`, style: { minHeight: "44px", display: "flex", alignItems: "center" }, children: a.name }) }, a.name)) }), u.jsxs("div", { className: "p-6 flex flex-col gap-4", children: [u.jsx(fe, { to: "/reservations", className: "btn-gold text-center w-full", children: "Book a Table" }), u.jsxs("a", { href: "tel:+12129473636", className: "btn-outline-gold text-center w-full flex items-center justify-center gap-2", children: [u.jsx(zr, { className: "w-4 h-4" }), "212-947-3636"] })] })] }) }) }), u.jsx(Dm, { children: s && u.jsxs(K.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 z-[70] bg-charcoal/98 backdrop-blur-lg flex items-center justify-center", children: [u.jsx("button", { onClick: () => i(!1), className: "absolute top-6 right-6 p-2 text-foreground/80 hover:text-primary transition-colors", "aria-label": "Close search", children: u.jsx(Lu, { className: "w-6 h-6" }) }), u.jsx("div", { className: "w-full max-w-2xl px-6", children: u.jsxs(K.div, { initial: { y: 20, opacity: 0 }, animate: { y: 0, opacity: 1 }, transition: { delay: .1 }, children: [u.jsx("label", { htmlFor: "search-input", className: "sr-only", children: "Search Keens" }), u.jsx("input", { id: "search-input", type: "search", placeholder: "Search menus, history, scotch...", className: "w-full bg-transparent border-b-2 border-primary/50 focus:border-primary py-4 text-2xl font-heading text-foreground placeholder:text-foreground/40 outline-none transition-colors", autoFocus: !0 }), u.jsx("p", { className: "mt-4 text-sm text-foreground/60 font-body", children: 'Try searching for "Mutton Chop", "Scotch", or "Private Dining"' })] }) })] }) })] }) } const Ng = { navigate: [{ name: "Our Menus", href: "/menus" }, { name: "History & Heritage", href: "/history" }, { name: "Private Dining", href: "/private-dining" }, { name: "Reservations", href: "/reservations" }, { name: "Contact Us", href: "/contact" }], legal: [{ name: "Privacy Policy", href: "/privacy" }, { name: "Terms of Service", href: "/terms" }, { name: "Accessibility", href: "/accessibility" }] }, cM = [{ name: "Instagram", href: "https://instagram.com/keenssteakhouse", icon: JC }, { name: "Facebook", href: "https://facebook.com/keenssteakhouse", icon: ZC }, { name: "Twitter", href: "https://twitter.com/keenssteakhouse", icon: rk }]; function uM() { return u.jsx("footer", { className: "bg-charcoal border-t border-border/30", role: "contentinfo", children: u.jsxs("div", { className: "keens-container py-16", children: [u.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-12", children: [u.jsxs("div", { className: "space-y-6", children: [u.jsxs(fe, { to: "/", className: "inline-block", children: [u.jsx("span", { className: "font-heading text-3xl text-primary", children: "KEENS" }), u.jsx("p", { className: "text-sm font-body text-foreground/60 mt-1", children: "Steakhouse  Est. 1885" })] }), u.jsx("p", { className: "text-sm text-foreground/70 font-body leading-relaxed", children: "A New York institution for 140 years. Home of the legendary Mutton Chop and the world's largest single malt scotch collection." }), u.jsx("div", { className: "flex gap-4", children: cM.map(e => u.jsx("a", { href: e.href, target: "_blank", rel: "noopener noreferrer", className: "p-2 bg-muted/50 rounded-sm text-foreground/60 hover:text-primary hover:bg-muted transition-colors", "aria-label": e.name, children: u.jsx(e.icon, { className: "w-5 h-5" }) }, e.name)) })] }), u.jsxs("div", { className: "space-y-6", children: [u.jsx("h3", { className: "font-heading text-lg text-primary", children: "Visit Us" }), u.jsxs("ul", { className: "space-y-4 font-body text-sm", children: [u.jsxs("li", { className: "flex items-start gap-3 text-foreground/70", children: [u.jsx(gf, { className: "w-4 h-4 mt-1 text-primary/60" }), u.jsxs("address", { className: "not-italic", children: ["72 West 36th Street", u.jsx("br", {}), "New York, NY 10018"] })] }), u.jsx("li", { children: u.jsxs("a", { href: "tel:+12129473636", className: "flex items-center gap-3 text-foreground/70 hover:text-primary transition-colors", children: [u.jsx(zr, { className: "w-4 h-4 text-primary/60" }), "212-947-3636"] }) }), u.jsx("li", { children: u.jsxs("a", { href: "mailto:info@keenssteakhouse.com", className: "flex items-center gap-3 text-foreground/70 hover:text-primary transition-colors", children: [u.jsx(mf, { className: "w-4 h-4 text-primary/60" }), "info@keenssteakhouse.com"] }) })] })] }), u.jsxs("div", { className: "space-y-6", children: [u.jsx("h3", { className: "font-heading text-lg text-primary", children: "Hours" }), u.jsxs("ul", { className: "space-y-3 font-body text-sm text-foreground/70", children: [u.jsxs("li", { className: "flex items-start gap-3", children: [u.jsx(Cs, { className: "w-4 h-4 mt-0.5 text-primary/60" }), u.jsxs("div", { children: [u.jsx("p", { className: "text-foreground/90", children: "Monday  Friday" }), u.jsx("p", { children: "Lunch: 11:45am  2:30pm" }), u.jsx("p", { children: "Dinner: 5:00pm  10:30pm" })] })] }), u.jsxs("li", { className: "flex items-start gap-3", children: [u.jsx(Cs, { className: "w-4 h-4 mt-0.5 text-primary/60 opacity-0" }), u.jsxs("div", { children: [u.jsx("p", { className: "text-foreground/90", children: "Saturday" }), u.jsx("p", { children: "Dinner: 5:00pm  10:30pm" })] })] }), u.jsxs("li", { className: "flex items-start gap-3", children: [u.jsx(Cs, { className: "w-4 h-4 mt-0.5 text-primary/60 opacity-0" }), u.jsxs("div", { children: [u.jsx("p", { className: "text-foreground/90", children: "Sunday" }), u.jsx("p", { children: "Dinner: 5:00pm  9:00pm" })] })] })] })] }), u.jsxs("div", { className: "space-y-6", children: [u.jsx("h3", { className: "font-heading text-lg text-primary", children: "Navigate" }), u.jsx("ul", { className: "space-y-3 font-body text-sm", children: Ng.navigate.map(e => u.jsx("li", { children: u.jsx(fe, { to: e.href, className: "text-foreground/70 hover:text-primary transition-colors", children: e.name }) }, e.name)) })] })] }), u.jsx("div", { className: "mt-16 pt-8 border-t border-border/20", children: u.jsxs("div", { className: "flex flex-col md:flex-row items-center justify-between gap-4", children: [u.jsx("p", { className: "text-sm text-foreground/50 font-body", children: " 2025 Keens Steakhouse. All rights reserved." }), u.jsx("nav", { className: "flex gap-6", "aria-label": "Legal links", children: Ng.legal.map(e => u.jsx(fe, { to: e.href, className: "text-sm text-foreground/50 hover:text-primary transition-colors font-body", children: e.name }, e.name)) })] }) })] }) }) } function dM() { return u.jsx("div", { className: "fixed bottom-0 left-0 right-0 z-50 lg:hidden bg-charcoal/95 backdrop-blur-md border-t border-border/30 mobile-bottom-bar", children: u.jsxs("div", { className: "flex", children: [u.jsxs(fe, { to: "/reservations", className: "flex-1 flex items-center justify-center gap-2 py-4 text-foreground font-body text-sm font-medium hover:bg-primary hover:text-primary-foreground transition-colors", style: { minHeight: "56px" }, children: [u.jsx(Zi, { className: "w-5 h-5" }), "Reservations"] }), u.jsx("div", { className: "w-px bg-border/30" }), u.jsxs("a", { href: "tel:+12129473636", className: "flex-1 flex items-center justify-center gap-2 py-4 text-primary font-body text-sm font-medium hover:bg-primary hover:text-primary-foreground transition-colors", style: { minHeight: "56px" }, children: [u.jsx(zr, { className: "w-5 h-5" }), "Call Now"] })] }) }) } function fr({ children: e }) { return u.jsxs("div", { className: "min-h-screen flex flex-col", children: [u.jsx(lM, {}), u.jsx("main", { id: "main-content", className: "flex-1 pb-16 lg:pb-0", children: e }), u.jsx(uM, {}), u.jsx(dM, {})] }) } const fM = [{ source: "The New York Times", year: 2024, quote: "A cathedral of beef that remains essential to the New York dining experience.", rating: 4 }, { source: "Eater NY", year: 2025, quote: "The legendary mutton chop is worth every pennya pilgrimage for carnivores.", rating: 5 }, { source: "Michelin Guide", year: 2024, quote: "An institution where history meets exceptional prime beef.", rating: null }], hM = [{ title: "Our Menus", description: "Prime steaks, legendary mutton chops & curated scotch", href: "/menus", image: d1, alt: "Close-up of a 26-ounce Mutton Chop with mint jelly on a white plate" }, { title: "Private Dining", description: "Historic rooms for unforgettable gatherings", href: "/private-dining", image: pd, alt: "Elegant private dining room with candlelit table settings and vintage portraits" }, { title: "Our History", description: "140 years of New York dining heritage", href: "/history", image: ch, alt: "Vintage photograph of clay tobacco pipes hanging from ornate ceiling" }]; function pM() { return u.jsxs(fr, { children: [u.jsxs("section", { className: "relative min-h-screen flex items-center justify-center overflow-hidden hero-section", children: [u.jsxs("div", { className: "absolute inset-0", children: [u.jsx("img", { src: aM, alt: "Sizzling prime aged ribeye steak in a classic New York steakhouse setting with mahogany paneling and vintage pipes", className: "w-full h-full object-cover" }), u.jsx("div", { className: "absolute inset-0 bg-gradient-to-b from-charcoal/60 via-charcoal/40 to-mahogany" }), u.jsx("div", { className: "absolute inset-0 smoke-overlay animate-smoke" })] }), u.jsxs("div", { className: "relative z-10 keens-container text-center py-32", children: [u.jsxs(K.div, { initial: { opacity: 0, y: 30 }, animate: { opacity: 1, y: 0 }, transition: { duration: .8, delay: .2 }, className: "space-y-6", children: [u.jsx("p", { className: "font-mono text-primary/90 text-sm tracking-[0.3em] uppercase", children: "Established 1885  Manhattan" }), u.jsxs("h1", { className: "font-heading text-5xl md:text-6xl lg:text-7xl text-foreground leading-tight", children: ["A New York Legend", u.jsx("br", {}), u.jsx("span", { className: "italic text-primary", children: "Since 1885" })] }), u.jsx("p", { className: "font-heading text-xl md:text-2xl text-foreground/80 italic", children: "Home of the Mutton Chop" })] }), u.jsxs(K.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .8, delay: .6 }, className: "mt-12 flex flex-col sm:flex-row items-center justify-center gap-4", children: [u.jsxs(fe, { to: "/reservations", className: "btn-gold flex items-center gap-2", children: [u.jsx(Zi, { className: "w-5 h-5" }), "Reserve Your Table"] }), u.jsxs(fe, { to: "/menus", className: "btn-outline-gold flex items-center gap-2", children: ["Explore Our Menus", u.jsx(Xt, { className: "w-4 h-4" })] })] }), u.jsx(K.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, transition: { delay: 1.2 }, className: "absolute bottom-12 left-1/2 -translate-x-1/2", children: u.jsx("div", { className: "w-6 h-10 border-2 border-primary/50 rounded-full flex justify-center pt-2", children: u.jsx(K.div, { animate: { y: [0, 8, 0] }, transition: { duration: 1.5, repeat: 1 / 0 }, className: "w-1.5 h-1.5 bg-primary rounded-full" }) }) })] })] }), u.jsx("section", { className: "bg-charcoal py-16 border-y border-border/20", children: u.jsx("div", { className: "keens-container", children: u.jsx("div", { className: "grid grid-cols-1 md:grid-cols-3 gap-8", children: fM.map((e, t) => u.jsxs(K.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { delay: t * .1 }, className: "text-center p-6", children: [u.jsxs("p", { className: "font-body text-foreground/70 italic mb-4", children: ['"', e.quote, '"'] }), u.jsx("div", { className: "flex items-center justify-center gap-1 mb-2", children: e.rating && Array.from({ length: e.rating }).map((n, r) => u.jsx(nk, { className: "w-4 h-4 fill-primary text-primary" }, r)) }), u.jsx("p", { className: "font-heading text-primary text-sm", children: e.source }), u.jsx("p", { className: "font-mono text-foreground/50 text-xs", children: e.year })] }, e.source)) }) }) }), u.jsx("section", { className: "keens-section bg-mahogany", children: u.jsx("div", { className: "keens-container", children: u.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-2 gap-12 items-center", children: [u.jsxs(K.div, { initial: { opacity: 0, x: -30 }, whileInView: { opacity: 1, x: 0 }, viewport: { once: !0 }, className: "space-y-6", children: [u.jsx("span", { className: "font-mono text-primary/80 text-sm tracking-widest uppercase", children: "Our Signature Dish" }), u.jsxs("h2", { className: "font-heading text-4xl md:text-5xl text-foreground", children: ["The Legendary", u.jsx("br", {}), u.jsx("span", { className: "italic text-primary", children: "Mutton Chop" })] }), u.jsx("p", { className: "keens-body", children: "Our signature Mutton Chop is not goatit is a saddle of lamb, aged to perfection, a cut unique to Keens since 1885. Each 26-ounce masterpiece is hand-cut and broiled to your specification, served with our house-made mint jelly." }), u.jsx("p", { className: "keens-body", children: "This is not simply a meal. It is a rite of passage for those who appreciate the art of meat at its finest." }), u.jsxs(fe, { to: "/menus", className: "inline-flex items-center gap-2 text-primary font-body font-semibold hover:gap-4 transition-all", children: ["View Full Menu", u.jsx(Xt, { className: "w-5 h-5" })] })] }), u.jsxs(K.div, { initial: { opacity: 0, x: 30 }, whileInView: { opacity: 1, x: 0 }, viewport: { once: !0 }, className: "relative", children: [u.jsx("img", { src: d1, alt: "Close-up of a 26-ounce Mutton Chop with mint jelly, steam rising, on a white bone china plate", className: "w-full rounded-sm shadow-elegant" }), u.jsx("div", { className: "absolute -bottom-4 -right-4 bg-primary text-primary-foreground px-6 py-3 rounded-sm", children: u.jsx("span", { className: "font-mono text-lg font-bold", children: "26 oz" }) })] })] }) }) }), u.jsx("section", { className: "keens-section bg-charcoal", children: u.jsxs("div", { className: "keens-container", children: [u.jsxs(K.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, className: "text-center mb-16", children: [u.jsx("h2", { className: "font-heading text-3xl md:text-4xl text-foreground mb-4", children: "Experience Keens" }), u.jsx("div", { className: "gold-accent max-w-xs mx-auto" })] }), u.jsx("div", { className: "grid grid-cols-1 md:grid-cols-3 gap-8", children: hM.map((e, t) => u.jsx(K.div, { initial: { opacity: 0, y: 30 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { delay: t * .15 }, children: u.jsxs(fe, { to: e.href, className: "keens-card block group", children: [u.jsx("div", { className: "aspect-[4/3] overflow-hidden", children: u.jsx("img", { src: e.image, alt: e.alt, className: "w-full h-full object-cover transition-transform duration-700 group-hover:scale-110" }) }), u.jsxs("div", { className: "p-6", children: [u.jsx("h3", { className: "font-heading text-xl text-foreground mb-2 group-hover:text-primary transition-colors", children: e.title }), u.jsx("p", { className: "text-foreground/60 text-sm font-body", children: e.description }), u.jsxs("div", { className: "mt-4 flex items-center gap-2 text-primary text-sm font-body font-medium", children: ["Discover", u.jsx(Xt, { className: "w-4 h-4 group-hover:translate-x-1 transition-transform" })] })] })] }) }, e.title)) })] }) }), u.jsx("section", { className: "keens-section bg-mahogany", children: u.jsx("div", { className: "keens-container", children: u.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-2 gap-16", children: [u.jsxs(K.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, className: "space-y-6", children: [u.jsxs("div", { className: "flex items-center gap-3 text-primary", children: [u.jsx(Cs, { className: "w-6 h-6" }), u.jsx("h3", { className: "font-heading text-2xl", children: "Hours of Operation" })] }), u.jsxs("div", { className: "space-y-4 font-body", children: [u.jsxs("div", { className: "flex justify-between items-center py-3 border-b border-border/20", children: [u.jsx("span", { className: "text-foreground/80", children: "Monday  Friday" }), u.jsxs("div", { className: "text-right text-foreground/60 text-sm", children: [u.jsx("p", { children: "Lunch: 11:45am  2:30pm" }), u.jsx("p", { children: "Dinner: 5:00pm  10:30pm" })] })] }), u.jsxs("div", { className: "flex justify-between items-center py-3 border-b border-border/20", children: [u.jsx("span", { className: "text-foreground/80", children: "Saturday" }), u.jsx("span", { className: "text-foreground/60 text-sm", children: "Dinner: 5:00pm  10:30pm" })] }), u.jsxs("div", { className: "flex justify-between items-center py-3", children: [u.jsx("span", { className: "text-foreground/80", children: "Sunday" }), u.jsx("span", { className: "text-foreground/60 text-sm", children: "Dinner: 5:00pm  9:00pm" })] })] })] }), u.jsxs(K.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { delay: .1 }, className: "space-y-6", children: [u.jsx("h3", { className: "font-heading text-2xl text-primary", children: "Dress Code" }), u.jsx("p", { className: "keens-body", children: "Keens maintains a tradition of elegant dining. We kindly request Business Casual attire. Jackets are appreciated but not required for gentlemen." }), u.jsx("p", { className: "keens-body text-foreground/60 text-sm", children: "Athletic wear, shorts, and flip-flops are not permitted in the dining rooms. We reserve the right to provide a jacket if needed." }), u.jsx("div", { className: "vintage-divider", children: u.jsx("span", { className: "text-primary text-2xl", children: "" }) }), u.jsx("p", { className: "text-foreground/70 text-sm font-body italic", children: `"Dress as if you're meeting someone important. At Keens, you just might."` })] })] }) }) }), u.jsxs("section", { className: "relative py-24 overflow-hidden", children: [u.jsxs("div", { className: "absolute inset-0", children: [u.jsx("img", { src: ch, alt: "Historic Keens interior with clay pipes and chandeliers", className: "w-full h-full object-cover opacity-30" }), u.jsx("div", { className: "absolute inset-0 bg-gradient-to-r from-charcoal via-charcoal/95 to-charcoal" })] }), u.jsx("div", { className: "relative keens-container text-center", children: u.jsxs(K.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, className: "max-w-2xl mx-auto space-y-6", children: [u.jsx("h2", { className: "font-heading text-3xl md:text-4xl text-foreground", children: "Join 140 Years of History" }), u.jsx("p", { className: "keens-body", children: "Reserve your place at New York's most storied table. Whether it's a celebration, a business dinner, or simply a craving for the finest beef in Manhattanwe await your arrival." }), u.jsxs("div", { className: "flex flex-col sm:flex-row items-center justify-center gap-4 mt-8", children: [u.jsx(fe, { to: "/reservations", className: "btn-gold", children: "Make a Reservation" }), u.jsx("a", { href: "tel:+12129473636", className: "btn-outline-gold", children: "Call 212-947-3636" })] })] }) })] })] }) } const mM = { dinner: [{ title: "From the Raw Bar", items: [{ name: "Oysters on the Half Shell", description: "Half dozen, rotating selection from the East Coast", price: 24, glutenFree: !0 }, { name: "Jumbo Shrimp Cocktail", description: "Five colossal shrimp with house cocktail sauce", price: 32, glutenFree: !0 }, { name: "Keens Seafood Tower", description: "Oysters, clams, shrimp, lobster tail, king crab", price: 175, glutenFree: !0 }] }, { title: "Steaks & Chops", items: [{ name: "The Legendary Mutton Chop", description: "26 oz. saddle of lamb, aged and broiled to perfection. Served with mint jelly", price: 72, glutenFree: !0 }, { name: "Prime Porterhouse for Two", description: "32 oz. dry-aged 28 days, bone-in", price: 159, glutenFree: !0 }, { name: "Filet Mignon", description: "12 oz. center cut, wrapped in applewood bacon", price: 68, glutenFree: !0 }, { name: "Prime New York Strip", description: "20 oz. dry-aged, bone-in", price: 72, glutenFree: !0 }, { name: "Prime Ribeye", description: "24 oz. heavily marbled, boneless", price: 76, glutenFree: !0 }, { name: "T-Bone Steak", description: "24 oz. classic cut with tenderloin and strip", price: 74, glutenFree: !0 }] }, { title: "Sides", items: [{ name: "Creamed Spinach", description: "Classic steakhouse preparation", price: 16, vegetarian: !0, glutenFree: !0 }, { name: "Sauted Mushrooms", description: "Wild mushroom medley with thyme butter", price: 18, vegetarian: !0, glutenFree: !0 }, { name: "German Potatoes", description: "Roasted with bacon and caramelized onions", price: 14, glutenFree: !0 }, { name: "Baked Potato", description: "Loaded with sour cream, chives, bacon", price: 12, glutenFree: !0 }, { name: "Asparagus Hollandaise", description: "Jumbo spears with house-made hollandaise", price: 18, vegetarian: !0, glutenFree: !0 }] }], lunch: [{ title: "Appetizers", items: [{ name: "Caesar Salad", description: "Romaine hearts, house-made dressing, aged parmesan", price: 18, vegetarian: !0 }, { name: "Wedge Salad", description: "Iceberg, blue cheese, bacon, tomatoes", price: 16, glutenFree: !0 }, { name: "French Onion Soup", description: "Caramelized onions, gruyre crouton", price: 14 }] }, { title: "Lunch Entres", items: [{ name: "Prime Burger", description: "8 oz. dry-aged beef, cheddar, special sauce", price: 28 }, { name: "Filet Mignon Lunch Cut", description: "8 oz. with barnaise sauce", price: 48, glutenFree: !0 }, { name: "Grilled Scottish Salmon", description: "Pan-roasted with lemon beurre blanc", price: 36, glutenFree: !0 }, { name: "Lamb Chops", description: "Double-cut, herb-crusted", price: 54, glutenFree: !0 }] }], pub: [{ title: "Bar Bites", items: [{ name: "Deviled Eggs", description: "Classic preparation with paprika", price: 10, vegetarian: !0, glutenFree: !0 }, { name: "Bacon-Wrapped Dates", description: "Stuffed with manchego cheese", price: 14, glutenFree: !0 }, { name: "Smoked Salmon Toast", description: "House-cured, cream cheese, capers", price: 18 }, { name: "Mini Crab Cakes", description: "Maryland-style with remoulade", price: 22 }] }, { title: "Pub Classics", items: [{ name: "Fish & Chips", description: "Beer-battered Atlantic cod, malt vinegar aioli", price: 26 }, { name: "Shepherd's Pie", description: "Ground lamb, vegetables, mashed potato crust", price: 24 }, { name: "Chicken Pot Pie", description: "Free-range chicken, puff pastry top", price: 22 }] }], dessert: [{ title: "Sweet Endings", items: [{ name: "New York Cheesecake", description: "Dense, creamy, with strawberry compote", price: 16, vegetarian: !0 }, { name: "Crme Brle", description: "Tahitian vanilla bean custard", price: 14, vegetarian: !0, glutenFree: !0 }, { name: "Chocolate Lava Cake", description: "Warm Valrhona chocolate, vanilla ice cream", price: 16, vegetarian: !0 }, { name: "Key Lime Pie", description: "Graham cracker crust, whipped cream", price: 14, vegetarian: !0 }, { name: "Apple Tart", description: "Warm with cinnamon ice cream and caramel", price: 15, vegetarian: !0 }] }, { title: "After Dinner", items: [{ name: "Cheese Selection", description: "Artisanal cheeses with honeycomb, nuts", price: 24, vegetarian: !0, glutenFree: !0 }, { name: "Cognac Flight", description: "Three premium selections", price: 45, vegetarian: !0, glutenFree: !0 }, { name: "Espresso Martini", description: "Keens house recipe", price: 18, vegetarian: !0, glutenFree: !0 }] }], scotch: [] }, gM = [{ name: "Macallan 12 Year", region: "Speyside", age: 12, price: 24 }, { name: "Lagavulin 16 Year", region: "Islay", age: 16, price: 32 }, { name: "Glenfiddich 18 Year", region: "Speyside", age: 18, price: 38 }, { name: "Talisker 10 Year", region: "Island", age: 10, price: 22 }, { name: "Highland Park 18 Year", region: "Island", age: 18, price: 42 }, { name: "Ardbeg Uigeadail", region: "Islay", age: null, price: 28 }, { name: "Glenmorangie Signet", region: "Highland", age: null, price: 65 }, { name: "Balvenie DoubleWood 17", region: "Speyside", age: 17, price: 48 }, { name: "Oban 14 Year", region: "Highland", age: 14, price: 26 }, { name: "Laphroaig Quarter Cask", region: "Islay", age: null, price: 20 }, { name: "Springbank 15 Year", region: "Campbeltown", age: 15, price: 44 }, { name: "Bunnahabhain 18 Year", region: "Islay", age: 18, price: 52 }], yM = [{ id: "dinner", label: "Dinner" }, { id: "lunch", label: "Lunch" }, { id: "pub", label: "Pub" }, { id: "dessert", label: "Dessert" }, { id: "scotch", label: "Scotch" }]; function vM() { const [e, t] = x.useState("dinner"), [n, r] = x.useState(!1), [s, i] = x.useState(!1), [o, a] = x.useState("name"), [l, c] = x.useState(""), d = gM.filter(h => h.name.toLowerCase().includes(l.toLowerCase()) || h.region.toLowerCase().includes(l.toLowerCase())).sort((h, p) => o === "price" ? h.price - p.price : o === "age" ? (p.age || 0) - (h.age || 0) : h.name.localeCompare(p.name)), f = h => !(n && !h.vegetarian || s && !h.glutenFree); return u.jsxs(fr, { children: [u.jsx("section", { className: "pt-32 pb-16 bg-mahogany", children: u.jsxs("div", { className: "keens-container", children: [u.jsx("nav", { "aria-label": "Breadcrumb", className: "mb-8", children: u.jsxs("ol", { className: "flex items-center gap-2 text-sm font-body text-foreground/60", children: [u.jsx("li", { children: u.jsx(fe, { to: "/", className: "hover:text-primary transition-colors", children: "Home" }) }), u.jsx("li", { children: u.jsx(Xt, { className: "w-4 h-4" }) }), u.jsx("li", { className: "text-primary", children: "Menus" })] }) }), u.jsxs(K.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, className: "max-w-3xl", children: [u.jsxs("h1", { className: "font-heading text-4xl md:text-5xl text-foreground mb-4", children: ["Our ", u.jsx("span", { className: "italic text-primary", children: "Menus" })] }), u.jsx("p", { className: "keens-body", children: "From the legendary Mutton Chop to prime dry-aged steaks and the world's largest collection of single malt scotchevery dish at Keens tells a story of excellence." })] })] }) }), u.jsx("div", { className: "sticky top-16 z-40 bg-charcoal/95 backdrop-blur-md border-b border-border/30", children: u.jsx("div", { className: "keens-container py-4", children: u.jsxs("div", { className: "flex flex-wrap items-center gap-4", children: [u.jsx("div", { className: "flex gap-2 flex-wrap", children: yM.map(h => u.jsx("button", { onClick: () => t(h.id), className: `px-4 py-2 text-sm font-body font-medium rounded-sm transition-colors ${e === h.id ? "bg-primary text-primary-foreground" : "text-foreground/70 hover:text-primary hover:bg-muted/50"}`, children: h.label }, h.id)) }), e !== "scotch" && u.jsxs("div", { className: "flex items-center gap-4 ml-auto", children: [u.jsxs("label", { className: "flex items-center gap-2 text-sm font-body text-foreground/70 cursor-pointer", children: [u.jsx("input", { type: "checkbox", checked: n, onChange: h => r(h.target.checked), className: "w-4 h-4 accent-primary" }), u.jsx(gc, { className: "w-4 h-4 text-hunter" }), "Vegetarian"] }), u.jsxs("label", { className: "flex items-center gap-2 text-sm font-body text-foreground/70 cursor-pointer", children: [u.jsx("input", { type: "checkbox", checked: s, onChange: h => i(h.target.checked), className: "w-4 h-4 accent-primary" }), u.jsx(qC, { className: "w-4 h-4 text-primary" }), "Gluten-Free"] })] })] }) }) }), u.jsx("section", { className: "keens-section bg-charcoal min-h-[60vh]", children: u.jsx("div", { className: "keens-container", children: e === "scotch" ? u.jsxs(K.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, transition: { duration: .3 }, children: [u.jsxs("div", { className: "mb-8 flex flex-col sm:flex-row gap-4 items-start sm:items-center justify-between", children: [u.jsxs("div", { children: [u.jsx("h2", { className: "font-heading text-2xl text-foreground mb-2", children: "Single Malt Scotch Collection" }), u.jsx("p", { className: "text-foreground/60 text-sm font-body", children: "The world's largest collection with over 200 selections" })] }), u.jsxs("div", { className: "flex gap-4", children: [u.jsx("input", { type: "search", placeholder: "Search by name or region...", value: l, onChange: h => c(h.target.value), className: "px-4 py-2 bg-muted border border-border rounded-sm text-foreground placeholder:text-foreground/40 focus:outline-none focus:ring-2 focus:ring-primary text-sm font-body" }), u.jsxs("select", { value: o, onChange: h => a(h.target.value), className: "px-4 py-2 bg-muted border border-border rounded-sm text-foreground focus:outline-none focus:ring-2 focus:ring-primary text-sm font-body", "aria-label": "Sort scotch list", children: [u.jsx("option", { value: "name", children: "Sort by Name" }), u.jsx("option", { value: "price", children: "Price: Low to High" }), u.jsx("option", { value: "age", children: "Age: High to Low" })] })] })] }), u.jsx("div", { className: "overflow-x-auto", children: u.jsxs("table", { className: "w-full border-collapse", children: [u.jsx("thead", { children: u.jsxs("tr", { className: "border-b border-border/30", children: [u.jsx("th", { className: "text-left py-4 px-4 font-heading text-primary text-sm", children: "Name" }), u.jsx("th", { className: "text-left py-4 px-4 font-heading text-primary text-sm", children: "Region" }), u.jsx("th", { className: "text-center py-4 px-4 font-heading text-primary text-sm", children: "Age" }), u.jsx("th", { className: "text-right py-4 px-4 font-heading text-primary text-sm", children: "Price" })] }) }), u.jsx("tbody", { children: d.map((h, p) => u.jsxs(K.tr, { initial: { opacity: 0, y: 10 }, animate: { opacity: 1, y: 0 }, transition: { delay: p * .03 }, className: "border-b border-border/10 hover:bg-muted/30 transition-colors", children: [u.jsx("td", { className: "py-4 px-4 font-body text-foreground", children: h.name }), u.jsx("td", { className: "py-4 px-4 font-body text-foreground/70", children: h.region }), u.jsx("td", { className: "py-4 px-4 font-mono text-foreground/70 text-center", children: h.age ? `${h.age}yr` : "NAS" }), u.jsxs("td", { className: "py-4 px-4 font-mono text-primary text-right", children: ["$", h.price] })] }, h.name)) })] }) })] }, "scotch") : u.jsx(K.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, transition: { duration: .3 }, className: "space-y-12", children: mM[e].map(h => u.jsxs("div", { children: [u.jsx("h2", { className: "font-heading text-2xl text-primary mb-6", children: h.title }), u.jsx("div", { className: "space-y-4", children: h.items.map(p => u.jsxs("div", { className: `flex flex-col sm:flex-row sm:items-start justify-between py-4 border-b border-border/10 transition-opacity ${f(p) ? "opacity-100" : "opacity-30"}`, children: [u.jsxs("div", { className: "flex-1", children: [u.jsxs("div", { className: "flex items-center gap-2 mb-1", children: [u.jsx("h3", { className: "font-body font-semibold text-foreground", children: p.name }), p.vegetarian && u.jsx("span", { className: "text-hunter", title: "Vegetarian", children: u.jsx(gc, { className: "w-4 h-4" }) }), p.glutenFree && u.jsx("span", { className: "text-primary text-xs font-mono", children: "[GF]" })] }), u.jsx("p", { className: "text-foreground/60 text-sm font-body", children: p.description })] }), u.jsx("span", { className: "keens-price text-lg mt-2 sm:mt-0 sm:ml-4", children: typeof p.price == "number" ? `$${p.price}` : p.price })] }, p.name)) })] }, h.title)) }, e) }) }), u.jsx("section", { className: "py-8 bg-mahogany border-t border-border/20", children: u.jsx("div", { className: "keens-container", children: u.jsxs("p", { className: "text-foreground/60 text-sm font-body text-center", children: [u.jsx(gc, { className: "w-4 h-4 inline text-hunter mr-1" }), " Vegetarian |", u.jsx("span", { className: "font-mono", children: "[GF]" }), " Gluten-Free | Please inform your server of any allergies or dietary restrictions."] }) }) })] }) } const xM = [{ year: 1885, title: "Albert Keen Opens His Doors", description: "Albert Keen transforms a modest chophouse on 36th Street into what would become a New York institution. The famous pipe collection begins with just a handful of clay pipes for loyal patrons." }, { year: 1899, title: "The Pipe Club Flourishes", description: "With over 15,000 numbered pipes hanging from the ceilings, Keens becomes the headquarters of the informal Pipe Club. Members include businessmen, politicians, and theatrical stars." }, { year: 1905, title: "Lillie Langtry Makes History", description: "Famed actress Lillie Langtry sues Keens for denying her entrywomen were not permitted in the main dining room. She wins, and Keens opens its doors to all, making history in New York's dining scene." }, { year: 1920, title: "Surviving Prohibition", description: "Like many establishments, Keens navigates the Prohibition era with creativity and resilience, focusing on its legendary food while the nation goes dry." }, { year: 1950, title: "Pipes of the Famous", description: "The pipe collection grows to include pipes belonging to Babe Ruth, Albert Einstein, Douglas MacArthur, Teddy Roosevelt, and countless other luminaries of the 20th century." }, { year: 1978, title: "Landmark Status", description: "Keens is designated a New York City Landmark, preserving its historic interior with its pressed tin ceilings, dark wood paneling, and theatrical memorabilia for future generations." }, { year: 2e3, title: "The Scotch Renaissance", description: "Keens builds what becomes the largest single malt scotch collection in the Western Hemisphere, with over 200 expressions from Scotland's finest distilleries." }, { year: 2025, title: "140 Years of Excellence", description: "Keens celebrates 140 years of serving New York's finest steaks and chops, remaining true to Albert Keen's original vision while embracing modern excellence." }], wM = [{ name: "Babe Ruth", description: "Baseball's Sultan of Swat, pipe #17,459" }, { name: "Albert Einstein", description: "The genius who revolutionized physics" }, { name: "Douglas MacArthur", description: "Five-star general and American hero" }, { name: "Teddy Roosevelt", description: "26th President of the United States" }, { name: "Will Rogers", description: "Beloved humorist and social commentator" }, { name: "Buffalo Bill Cody", description: "Legendary frontiersman and showman" }]; function bM() { return u.jsxs(fr, { children: [u.jsxs("section", { className: "relative pt-32 pb-24 overflow-hidden", children: [u.jsxs("div", { className: "absolute inset-0", children: [u.jsx("img", { src: ch, alt: "Historic interior of Keens Steakhouse showing hundreds of clay tobacco pipes hanging from the ornate ceiling with chandeliers and vintage portraits", className: "w-full h-full object-cover opacity-40" }), u.jsx("div", { className: "absolute inset-0 bg-gradient-to-b from-charcoal/80 via-mahogany/90 to-mahogany" }), u.jsx("div", { className: "smoke-overlay animate-smoke" })] }), u.jsxs("div", { className: "relative keens-container", children: [u.jsx("nav", { "aria-label": "Breadcrumb", className: "mb-8", children: u.jsxs("ol", { className: "flex items-center gap-2 text-sm font-body text-foreground/60", children: [u.jsx("li", { children: u.jsx(fe, { to: "/", className: "hover:text-primary transition-colors", children: "Home" }) }), u.jsx("li", { children: u.jsx(Xt, { className: "w-4 h-4" }) }), u.jsx("li", { className: "text-primary", children: "History" })] }) }), u.jsxs(K.div, { initial: { opacity: 0, y: 30 }, animate: { opacity: 1, y: 0 }, transition: { duration: .8 }, className: "max-w-3xl", children: [u.jsx("p", { className: "font-mono text-primary/80 text-sm tracking-widest uppercase mb-4", children: "Since 1885" }), u.jsxs("h1", { className: "font-heading text-4xl md:text-5xl lg:text-6xl text-foreground mb-6", children: ["A Story Written", u.jsx("br", {}), u.jsx("span", { className: "italic text-primary", children: "in Smoke & Steel" })] }), u.jsx("p", { className: "keens-body text-xl", children: "For 140 years, Keens has been more than a restaurant. It is a living museum, a gathering place for the great and the hungry, and a testament to the enduring art of the American steakhouse." })] })] })] }), u.jsx("section", { className: "keens-section bg-charcoal", children: u.jsxs("div", { className: "keens-container", children: [u.jsxs(K.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, className: "text-center mb-16", children: [u.jsx("h2", { className: "font-heading text-3xl text-foreground mb-4", children: "Through the Years" }), u.jsx("div", { className: "gold-accent max-w-xs mx-auto" })] }), u.jsxs("div", { className: "relative", children: [u.jsx("div", { className: "absolute left-4 md:left-1/2 top-0 bottom-0 w-px bg-gradient-to-b from-primary/0 via-primary/50 to-primary/0" }), u.jsx("div", { className: "space-y-16", children: xM.map((e, t) => u.jsxs(K.div, { initial: { opacity: 0, y: 30 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0, margin: "-100px" }, transition: { delay: .1 }, className: `relative flex flex-col md:flex-row gap-8 ${t % 2 === 0 ? "md:flex-row" : "md:flex-row-reverse"}`, children: [u.jsx("div", { className: "absolute left-4 md:left-1/2 w-4 h-4 -translate-x-1/2 bg-primary rounded-full border-4 border-charcoal z-10" }), u.jsxs("div", { className: `flex-1 pl-12 md:pl-0 ${t % 2 === 0 ? "md:pr-16 md:text-right" : "md:pl-16"}`, children: [u.jsx("span", { className: "font-mono text-3xl text-primary font-bold", children: e.year }), u.jsx("h3", { className: "font-heading text-xl text-foreground mt-2 mb-3", children: e.title }), u.jsx("p", { className: "text-foreground/70 font-body leading-relaxed", children: e.description })] }), u.jsx("div", { className: "hidden md:block flex-1" })] }, e.year)) })] })] }) }), u.jsx("section", { className: "keens-section bg-mahogany", children: u.jsx("div", { className: "keens-container", children: u.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-2 gap-16 items-center", children: [u.jsxs(K.div, { initial: { opacity: 0, x: -30 }, whileInView: { opacity: 1, x: 0 }, viewport: { once: !0 }, className: "space-y-6", children: [u.jsx("span", { className: "font-mono text-hunter text-sm tracking-widest uppercase", children: "The Collection" }), u.jsx("h2", { className: "font-heading text-4xl text-foreground", children: "The Pipe Club" }), u.jsx("p", { className: "keens-body", children: "Over 90,000 churchwarden clay pipes hang from the ceilings of Keens, each one numbered and registered to a patron who would smoke after dinner. It is the largest such collection in the world." }), u.jsx("p", { className: "keens-body", children: "Among them are pipes belonging to presidents, generals, athletes, artists, and tycoonsa silent congregation of history's most fascinating figures." })] }), u.jsx(K.div, { initial: { opacity: 0, x: 30 }, whileInView: { opacity: 1, x: 0 }, viewport: { once: !0 }, className: "grid grid-cols-2 gap-4", children: wM.map((e, t) => u.jsxs(K.div, { initial: { opacity: 0, scale: .95 }, whileInView: { opacity: 1, scale: 1 }, viewport: { once: !0 }, transition: { delay: t * .1 }, className: "keens-card p-5 group cursor-pointer", children: [u.jsx("h4", { className: "font-heading text-lg text-primary group-hover:text-foreground transition-colors", children: e.name }), u.jsx("p", { className: "text-foreground/60 text-sm font-body mt-2", children: e.description })] }, e.name)) })] }) }) }), u.jsx("section", { className: "py-20 bg-charcoal", children: u.jsx("div", { className: "keens-container", children: u.jsxs(K.blockquote, { initial: { opacity: 0 }, whileInView: { opacity: 1 }, viewport: { once: !0 }, className: "max-w-3xl mx-auto text-center", children: [u.jsx("div", { className: "text-6xl text-primary/30 font-heading mb-4", children: '"' }), u.jsx("p", { className: "font-heading text-2xl md:text-3xl text-foreground italic leading-relaxed mb-6", children: "Keens is not just a restaurant. It is a cathedral of beef, a museum of masculine indulgence, and a living room for New York's most interesting characters for over a century." }), u.jsx("footer", { className: "font-body text-foreground/60", children: " The New York Times" })] }) }) }), u.jsx("section", { className: "py-16 bg-mahogany border-t border-border/20", children: u.jsxs("div", { className: "keens-container text-center", children: [u.jsx("h3", { className: "font-heading text-2xl text-foreground mb-6", children: "Become Part of the Story" }), u.jsx(fe, { to: "/reservations", className: "btn-gold", children: "Make a Reservation" })] }) })] }) } const SM = [{ name: "The Lincoln Room", capacity: "20-40 Guests", description: "Our most distinguished private space, featuring original memorabilia from President Lincoln's era and dark walnut paneling.", features: ["Full privacy", "Dedicated bar", "Custom menus", "A/V equipped"] }, { name: "The Lambs Room", capacity: "15-30 Guests", description: "Named for The Lambs Club, a theatrical society whose members frequented Keens. Perfect for celebrations and reunions.", features: ["Theatrical decor", "Intimate setting", "Wine selection service"] }, { name: "The Bull Moose Room", capacity: "40-80 Guests", description: "Our largest private space, named in honor of Theodore Roosevelt. Ideal for corporate events and large celebrations.", features: ["Fireplace", "Stage area", "Full A/V", "Private entrance"] }]; function CM() { const [e, t] = x.useState({ name: "", email: "", phone: "", date: "", guestCount: "", occasion: "", message: "" }), [n, r] = x.useState(!1), s = async i => { i.preventDefault(), r(!0), await new Promise(o => setTimeout(o, 1500)), Zv({ title: "Inquiry Received", description: "Our events team will contact you within 24 hours." }), t({ name: "", email: "", phone: "", date: "", guestCount: "", occasion: "", message: "" }), r(!1) }; return u.jsxs(fr, { children: [u.jsxs("section", { className: "relative pt-32 pb-24 overflow-hidden", children: [u.jsxs("div", { className: "absolute inset-0", children: [u.jsx("img", { src: pd, alt: "Elegant private dining room at Keens Steakhouse with candlelit table settings, crystal glassware, and vintage portraits", className: "w-full h-full object-cover opacity-50" }), u.jsx("div", { className: "absolute inset-0 bg-gradient-to-b from-charcoal/80 via-mahogany/90 to-mahogany" })] }), u.jsxs("div", { className: "relative keens-container", children: [u.jsx("nav", { "aria-label": "Breadcrumb", className: "mb-8", children: u.jsxs("ol", { className: "flex items-center gap-2 text-sm font-body text-foreground/60", children: [u.jsx("li", { children: u.jsx(fe, { to: "/", className: "hover:text-primary transition-colors", children: "Home" }) }), u.jsx("li", { children: u.jsx(Xt, { className: "w-4 h-4" }) }), u.jsx("li", { className: "text-primary", children: "Private Dining" })] }) }), u.jsxs(K.div, { initial: { opacity: 0, y: 30 }, animate: { opacity: 1, y: 0 }, transition: { duration: .8 }, className: "max-w-3xl", children: [u.jsxs("h1", { className: "font-heading text-4xl md:text-5xl lg:text-6xl text-foreground mb-6", children: ["Private Dining", u.jsx("br", {}), u.jsx("span", { className: "italic text-primary", children: "& Events" })] }), u.jsx("p", { className: "keens-body text-xl", children: "Host your celebration in one of New York's most historic and atmospheric settings. From intimate gatherings to grand corporate events, Keens offers unparalleled private dining experiences." })] })] })] }), u.jsx("section", { className: "keens-section bg-charcoal", children: u.jsxs("div", { className: "keens-container", children: [u.jsxs(K.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, className: "text-center mb-16", children: [u.jsx("h2", { className: "font-heading text-3xl text-foreground mb-4", children: "Our Private Rooms" }), u.jsx("div", { className: "gold-accent max-w-xs mx-auto" })] }), u.jsx("div", { className: "grid grid-cols-1 md:grid-cols-3 gap-8", children: SM.map((i, o) => u.jsxs(K.div, { initial: { opacity: 0, y: 30 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { delay: o * .15 }, className: "keens-card group", children: [u.jsxs("div", { className: "relative aspect-[4/3] overflow-hidden", children: [u.jsx("img", { src: pd, alt: `${i.name} private dining space at Keens Steakhouse`, className: "w-full h-full object-cover transition-transform duration-700 group-hover:scale-110" }), u.jsxs("div", { className: "absolute top-4 right-4 bg-charcoal/90 backdrop-blur-sm px-4 py-2 rounded-sm flex items-center gap-2", children: [u.jsx(Dp, { className: "w-4 h-4 text-primary" }), u.jsx("span", { className: "text-sm font-mono text-foreground", children: i.capacity })] })] }), u.jsxs("div", { className: "p-6", children: [u.jsx("h3", { className: "font-heading text-xl text-primary mb-3", children: i.name }), u.jsx("p", { className: "text-foreground/70 text-sm font-body mb-4", children: i.description }), u.jsx("ul", { className: "flex flex-wrap gap-2", children: i.features.map(a => u.jsx("li", { className: "text-xs font-mono text-foreground/50 bg-muted/50 px-2 py-1 rounded-sm", children: a }, a)) })] })] }, i.name)) })] }) }), u.jsx("section", { className: "keens-section bg-mahogany", children: u.jsx("div", { className: "keens-container", children: u.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-2 gap-16", children: [u.jsxs(K.div, { initial: { opacity: 0, x: -30 }, whileInView: { opacity: 1, x: 0 }, viewport: { once: !0 }, children: [u.jsx("h2", { className: "font-heading text-3xl text-foreground mb-6", children: "Inquire About Private Events" }), u.jsxs("form", { onSubmit: s, className: "space-y-6", children: [u.jsxs("div", { className: "grid grid-cols-1 sm:grid-cols-2 gap-4", children: [u.jsxs("div", { children: [u.jsx("label", { htmlFor: "name", className: "block text-sm font-body text-foreground/80 mb-2", children: "Full Name *" }), u.jsxs("div", { className: "relative", children: [u.jsx(sk, { className: "absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-foreground/40" }), u.jsx("input", { type: "text", id: "name", required: !0, value: e.name, onChange: i => t({ ...e, name: i.target.value }), className: "w-full pl-10 pr-4 py-3 bg-muted border border-border rounded-sm text-foreground placeholder:text-foreground/40 focus:outline-none focus:ring-2 focus:ring-primary font-body", placeholder: "Your name" })] })] }), u.jsxs("div", { children: [u.jsx("label", { htmlFor: "email", className: "block text-sm font-body text-foreground/80 mb-2", children: "Email Address *" }), u.jsxs("div", { className: "relative", children: [u.jsx(mf, { className: "absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-foreground/40" }), u.jsx("input", { type: "email", id: "email", required: !0, value: e.email, onChange: i => t({ ...e, email: i.target.value }), className: "w-full pl-10 pr-4 py-3 bg-muted border border-border rounded-sm text-foreground placeholder:text-foreground/40 focus:outline-none focus:ring-2 focus:ring-primary font-body", placeholder: "your@email.com" })] })] })] }), u.jsxs("div", { className: "grid grid-cols-1 sm:grid-cols-2 gap-4", children: [u.jsxs("div", { children: [u.jsx("label", { htmlFor: "phone", className: "block text-sm font-body text-foreground/80 mb-2", children: "Phone Number *" }), u.jsxs("div", { className: "relative", children: [u.jsx(zr, { className: "absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-foreground/40" }), u.jsx("input", { type: "tel", id: "phone", required: !0, value: e.phone, onChange: i => t({ ...e, phone: i.target.value }), className: "w-full pl-10 pr-4 py-3 bg-muted border border-border rounded-sm text-foreground placeholder:text-foreground/40 focus:outline-none focus:ring-2 focus:ring-primary font-body", placeholder: "(212) 555-0123" })] })] }), u.jsxs("div", { children: [u.jsx("label", { htmlFor: "date", className: "block text-sm font-body text-foreground/80 mb-2", children: "Preferred Date *" }), u.jsxs("div", { className: "relative", children: [u.jsx(Zi, { className: "absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-foreground/40" }), u.jsx("input", { type: "date", id: "date", required: !0, value: e.date, onChange: i => t({ ...e, date: i.target.value }), className: "w-full pl-10 pr-4 py-3 bg-muted border border-border rounded-sm text-foreground focus:outline-none focus:ring-2 focus:ring-primary font-body" })] })] })] }), u.jsxs("div", { className: "grid grid-cols-1 sm:grid-cols-2 gap-4", children: [u.jsxs("div", { children: [u.jsx("label", { htmlFor: "guestCount", className: "block text-sm font-body text-foreground/80 mb-2", children: "Number of Guests *" }), u.jsxs("div", { className: "relative", children: [u.jsx(Dp, { className: "absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-foreground/40" }), u.jsx("input", { type: "number", id: "guestCount", required: !0, min: "10", max: "100", value: e.guestCount, onChange: i => t({ ...e, guestCount: i.target.value }), className: "w-full pl-10 pr-4 py-3 bg-muted border border-border rounded-sm text-foreground placeholder:text-foreground/40 focus:outline-none focus:ring-2 focus:ring-primary font-body", placeholder: "25" })] })] }), u.jsxs("div", { children: [u.jsx("label", { htmlFor: "occasion", className: "block text-sm font-body text-foreground/80 mb-2", children: "Occasion" }), u.jsxs("select", { id: "occasion", value: e.occasion, onChange: i => t({ ...e, occasion: i.target.value }), className: "w-full px-4 py-3 bg-muted border border-border rounded-sm text-foreground focus:outline-none focus:ring-2 focus:ring-primary font-body", children: [u.jsx("option", { value: "", children: "Select occasion" }), u.jsx("option", { value: "corporate", children: "Corporate Event" }), u.jsx("option", { value: "wedding", children: "Wedding Reception" }), u.jsx("option", { value: "birthday", children: "Birthday Celebration" }), u.jsx("option", { value: "anniversary", children: "Anniversary" }), u.jsx("option", { value: "holiday", children: "Holiday Party" }), u.jsx("option", { value: "other", children: "Other" })] })] })] }), u.jsxs("div", { children: [u.jsx("label", { htmlFor: "message", className: "block text-sm font-body text-foreground/80 mb-2", children: "Additional Details" }), u.jsx("textarea", { id: "message", rows: 4, value: e.message, onChange: i => t({ ...e, message: i.target.value }), className: "w-full px-4 py-3 bg-muted border border-border rounded-sm text-foreground placeholder:text-foreground/40 focus:outline-none focus:ring-2 focus:ring-primary font-body resize-none", placeholder: "Tell us about your event..." })] }), u.jsx("button", { type: "submit", disabled: n, className: "btn-gold w-full sm:w-auto disabled:opacity-50 disabled:cursor-not-allowed", children: n ? "Submitting..." : "Submit Inquiry" })] })] }), u.jsxs(K.div, { initial: { opacity: 0, x: 30 }, whileInView: { opacity: 1, x: 0 }, viewport: { once: !0 }, className: "space-y-8", children: [u.jsxs("div", { className: "keens-card p-8", children: [u.jsx("h3", { className: "font-heading text-xl text-primary mb-4", children: "What's Included" }), u.jsxs("ul", { className: "space-y-3 font-body text-foreground/80", children: [u.jsxs("li", { className: "flex items-start gap-3", children: [u.jsx("span", { className: "text-primary", children: "" }), "Dedicated event coordinator"] }), u.jsxs("li", { className: "flex items-start gap-3", children: [u.jsx("span", { className: "text-primary", children: "" }), "Custom menu creation with our executive chef"] }), u.jsxs("li", { className: "flex items-start gap-3", children: [u.jsx("span", { className: "text-primary", children: "" }), "Premium wine and scotch pairings"] }), u.jsxs("li", { className: "flex items-start gap-3", children: [u.jsx("span", { className: "text-primary", children: "" }), "Full A/V support for presentations"] }), u.jsxs("li", { className: "flex items-start gap-3", children: [u.jsx("span", { className: "text-primary", children: "" }), "Coat check and valet coordination"] })] })] }), u.jsxs("div", { className: "keens-card p-8", children: [u.jsx("h3", { className: "font-heading text-xl text-primary mb-4", children: "Download Resources" }), u.jsx("p", { className: "text-foreground/70 text-sm font-body mb-4", children: "View our complete private dining options, floor plans, and sample menus." }), u.jsxs("a", { href: "#", className: "inline-flex items-center gap-2 text-primary font-body font-medium hover:underline", children: [u.jsx(XC, { className: "w-4 h-4" }), "Download Floor Plans & Packages (PDF)"] })] }), u.jsxs("div", { className: "keens-card p-8", children: [u.jsx("h3", { className: "font-heading text-xl text-primary mb-4", children: "Prefer to Call?" }), u.jsx("p", { className: "text-foreground/70 text-sm font-body mb-4", children: "Our events team is available Monday through Friday, 10am6pm." }), u.jsxs("a", { href: "tel:+12129473636", className: "btn-outline-gold inline-flex items-center gap-2", children: [u.jsx(zr, { className: "w-4 h-4" }), "212-947-3636"] })] })] })] }) }) })] }) } function kM() { return u.jsxs(fr, { children: [u.jsx("section", { className: "pt-32 pb-16 bg-mahogany", children: u.jsxs("div", { className: "keens-container", children: [u.jsx("nav", { "aria-label": "Breadcrumb", className: "mb-8", children: u.jsxs("ol", { className: "flex items-center gap-2 text-sm font-body text-foreground/60", children: [u.jsx("li", { children: u.jsx(fe, { to: "/", className: "hover:text-primary transition-colors", children: "Home" }) }), u.jsx("li", { children: u.jsx(Xt, { className: "w-4 h-4" }) }), u.jsx("li", { className: "text-primary", children: "Reservations" })] }) }), u.jsxs(K.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, className: "max-w-3xl", children: [u.jsxs("h1", { className: "font-heading text-4xl md:text-5xl text-foreground mb-4", children: ["Reserve Your ", u.jsx("span", { className: "italic text-primary", children: "Table" })] }), u.jsx("p", { className: "keens-body", children: "Secure your place at New York's most legendary steakhouse. We recommend reservations, especially for dinner service and weekends." })] })] }) }), u.jsx("section", { className: "keens-section bg-charcoal", children: u.jsx("div", { className: "keens-container", children: u.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-3 gap-12", children: [u.jsx(K.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, className: "lg:col-span-2", children: u.jsxs("div", { className: "keens-card p-8 md:p-12", children: [u.jsxs("h2", { className: "font-heading text-2xl text-foreground mb-6 flex items-center gap-3", children: [u.jsx(Zi, { className: "w-6 h-6 text-primary" }), "Book Online"] }), u.jsx("div", { className: "aspect-[4/3] md:aspect-[16/9] bg-muted/50 rounded-sm flex items-center justify-center border border-border/30", children: u.jsxs("div", { className: "text-center p-8", children: [u.jsx(Zi, { className: "w-16 h-16 text-primary/50 mx-auto mb-4" }), u.jsx("h3", { className: "font-heading text-xl text-foreground mb-2", children: "Reservation System" }), u.jsx("p", { className: "text-foreground/60 font-body text-sm mb-6 max-w-md", children: "Our OpenTable widget would be embedded here, allowing you to select your date, time, and party size directly." }), u.jsxs("a", { href: "https://www.opentable.com/keens-steakhouse", target: "_blank", rel: "noopener noreferrer", className: "btn-gold inline-flex items-center gap-2", children: ["Book on OpenTable", u.jsx(Xt, { className: "w-4 h-4" })] })] }) }), u.jsxs("div", { className: "mt-6 p-4 bg-sienna/10 border border-sienna/30 rounded-sm flex items-start gap-3", children: [u.jsx(QC, { className: "w-5 h-5 text-sienna flex-shrink-0 mt-0.5" }), u.jsxs("div", { className: "text-sm font-body", children: [u.jsx("p", { className: "text-foreground/80", children: "Having trouble booking online?" }), u.jsxs("p", { className: "text-foreground/60 mt-1", children: ["Please call us at", " ", u.jsx("a", { href: "tel:+12129473636", className: "text-primary hover:underline", children: "212-947-3636" }), " ", "to secure your table."] })] })] })] }) }), u.jsxs(K.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { delay: .1 }, className: "space-y-6", children: [u.jsxs("div", { className: "keens-card p-6", children: [u.jsx("h3", { className: "font-heading text-lg text-primary mb-3", children: "Dress Code" }), u.jsxs("p", { className: "text-foreground/70 text-sm font-body", children: [u.jsx("strong", { className: "text-foreground", children: "Business Casual." }), " Jackets appreciated but not required. No athletic wear, please."] })] }), u.jsxs("div", { className: "keens-card p-6", children: [u.jsxs("h3", { className: "font-heading text-lg text-primary mb-3 flex items-center gap-2", children: [u.jsx(Cs, { className: "w-5 h-5" }), "Hours"] }), u.jsxs("div", { className: "space-y-2 text-sm font-body", children: [u.jsxs("div", { className: "flex justify-between text-foreground/70", children: [u.jsx("span", { children: "MonFri Lunch" }), u.jsx("span", { children: "11:45am  2:30pm" })] }), u.jsxs("div", { className: "flex justify-between text-foreground/70", children: [u.jsx("span", { children: "MonFri Dinner" }), u.jsx("span", { children: "5:00pm  10:30pm" })] }), u.jsxs("div", { className: "flex justify-between text-foreground/70", children: [u.jsx("span", { children: "Saturday" }), u.jsx("span", { children: "5:00pm  10:30pm" })] }), u.jsxs("div", { className: "flex justify-between text-foreground/70", children: [u.jsx("span", { children: "Sunday" }), u.jsx("span", { children: "5:00pm  9:00pm" })] })] })] }), u.jsxs("div", { className: "keens-card p-6", children: [u.jsxs("h3", { className: "font-heading text-lg text-primary mb-3 flex items-center gap-2", children: [u.jsx(gf, { className: "w-5 h-5" }), "Location"] }), u.jsxs("address", { className: "text-foreground/70 text-sm font-body not-italic mb-4", children: ["72 West 36th Street", u.jsx("br", {}), "New York, NY 10018"] }), u.jsxs("p", { className: "text-foreground/60 text-xs font-body", children: [u.jsx("strong", { className: "text-foreground/70", children: "Parking:" }), " Secure parking is available at Edison ParkFast at 101 West 36th Street, located directly opposite our main entrance."] })] }), u.jsxs("div", { className: "keens-card p-6", children: [u.jsxs("h3", { className: "font-heading text-lg text-primary mb-3 flex items-center gap-2", children: [u.jsx(zr, { className: "w-5 h-5" }), "Call Us"] }), u.jsx("a", { href: "tel:+12129473636", className: "btn-outline-gold w-full justify-center", children: "212-947-3636" })] })] })] }) }) }), u.jsx("section", { className: "py-8 bg-mahogany border-t border-border/20", children: u.jsx("div", { className: "keens-container", children: u.jsx("div", { className: "aspect-[21/9] bg-muted/30 rounded-sm overflow-hidden", children: u.jsx("iframe", { src: "https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d3022.617!2d-73.9855!3d40.7505!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x89c259aae7e1c7a3%3A0x3b7d7b8d6c8c8c8c!2sKeens%20Steakhouse!5e0!3m2!1sen!2sus!4v1234567890", width: "100%", height: "100%", style: { border: 0, filter: "invert(90%) hue-rotate(180deg) contrast(0.9)" }, allowFullScreen: !0, loading: "lazy", referrerPolicy: "no-referrer-when-downgrade", title: "Keens Steakhouse location on Google Maps" }) }) }) })] }) } function TM() { return u.jsxs(fr, { children: [u.jsx("section", { className: "pt-32 pb-16 bg-mahogany", children: u.jsxs("div", { className: "keens-container", children: [u.jsx("nav", { "aria-label": "Breadcrumb", className: "mb-8", children: u.jsxs("ol", { className: "flex items-center gap-2 text-sm font-body text-foreground/60", children: [u.jsx("li", { children: u.jsx(fe, { to: "/", className: "hover:text-primary transition-colors", children: "Home" }) }), u.jsx("li", { children: u.jsx(Xt, { className: "w-4 h-4" }) }), u.jsx("li", { className: "text-primary", children: "Contact" })] }) }), u.jsxs(K.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, className: "max-w-3xl", children: [u.jsxs("h1", { className: "font-heading text-4xl md:text-5xl text-foreground mb-4", children: ["Contact ", u.jsx("span", { className: "italic text-primary", children: "Keens" })] }), u.jsx("p", { className: "keens-body", children: "We welcome your inquiries about reservations, private events, or any questions about our historic establishment." })] })] }) }), u.jsx("section", { className: "keens-section bg-charcoal", children: u.jsx("div", { className: "keens-container", children: u.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-8", children: [u.jsxs(K.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, className: "keens-card p-6", children: [u.jsxs("div", { className: "flex items-center gap-3 text-primary mb-4", children: [u.jsx(gf, { className: "w-6 h-6" }), u.jsx("h3", { className: "font-heading text-lg", children: "Address" })] }), u.jsxs("address", { className: "not-italic text-foreground/80 font-body", children: ["72 West 36th Street", u.jsx("br", {}), "New York, NY 10018"] }), u.jsx("a", { href: "https://maps.google.com/?q=72+West+36th+Street+New+York+NY+10018", target: "_blank", rel: "noopener noreferrer", className: "inline-block mt-4 text-sm text-primary hover:underline font-body", children: "Get Directions " })] }), u.jsxs(K.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { delay: .1 }, className: "keens-card p-6", children: [u.jsxs("div", { className: "flex items-center gap-3 text-primary mb-4", children: [u.jsx(zr, { className: "w-6 h-6" }), u.jsx("h3", { className: "font-heading text-lg", children: "Phone" })] }), u.jsx("a", { href: "tel:+12129473636", className: "text-foreground/80 font-body text-lg hover:text-primary transition-colors", children: "212-947-3636" }), u.jsx("p", { className: "text-foreground/50 text-sm font-body mt-2", children: "Reservations & General Inquiries" })] }), u.jsxs(K.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { delay: .2 }, className: "keens-card p-6", children: [u.jsxs("div", { className: "flex items-center gap-3 text-primary mb-4", children: [u.jsx(mf, { className: "w-6 h-6" }), u.jsx("h3", { className: "font-heading text-lg", children: "Email" })] }), u.jsx("a", { href: "mailto:info@keenssteakhouse.com", className: "text-foreground/80 font-body hover:text-primary transition-colors break-all", children: "info@keenssteakhouse.com" }), u.jsx("p", { className: "text-foreground/50 text-sm font-body mt-2", children: "We respond within 24 hours" })] }), u.jsxs(K.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { delay: .3 }, className: "keens-card p-6", children: [u.jsxs("div", { className: "flex items-center gap-3 text-primary mb-4", children: [u.jsx(Cs, { className: "w-6 h-6" }), u.jsx("h3", { className: "font-heading text-lg", children: "Hours" })] }), u.jsxs("div", { className: "space-y-1 text-foreground/80 font-body text-sm", children: [u.jsx("p", { children: "MonFri: 11:45am10:30pm" }), u.jsx("p", { children: "Saturday: 5:00pm10:30pm" }), u.jsx("p", { children: "Sunday: 5:00pm9:00pm" })] })] })] }) }) }), u.jsx("section", { className: "py-12 bg-mahogany border-t border-border/20", children: u.jsx("div", { className: "keens-container", children: u.jsxs(K.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, className: "flex flex-col md:flex-row items-start gap-6 max-w-3xl", children: [u.jsx(GC, { className: "w-8 h-8 text-primary flex-shrink-0" }), u.jsxs("div", { children: [u.jsx("h3", { className: "font-heading text-xl text-foreground mb-2", children: "Parking" }), u.jsxs("p", { className: "text-foreground/70 font-body", children: ["Secure parking is available at ", u.jsx("strong", { className: "text-foreground", children: "Edison ParkFast" }), " at 101 West 36th Street, located directly opposite our main entrance. Valet service may be available during dinner hoursplease call ahead to confirm."] })] })] }) }) }), u.jsx("section", { className: "bg-charcoal", children: u.jsx("div", { className: "aspect-[21/9] md:aspect-[3/1]", children: u.jsx("iframe", { src: "https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d3022.617!2d-73.9855!3d40.7505!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x89c259aae7e1c7a3%3A0x3b7d7b8d6c8c8c8c!2sKeens%20Steakhouse!5e0!3m2!1sen!2sus!4v1234567890", width: "100%", height: "100%", style: { border: 0, filter: "invert(90%) hue-rotate(180deg) contrast(0.9)" }, allowFullScreen: !0, loading: "lazy", referrerPolicy: "no-referrer-when-downgrade", title: "Keens Steakhouse location on Google Maps" }) }) })] }) } function EM() { return u.jsxs(fr, { children: [u.jsx("section", { className: "pt-32 pb-16 bg-mahogany", children: u.jsxs("div", { className: "keens-container", children: [u.jsx("nav", { "aria-label": "Breadcrumb", className: "mb-8", children: u.jsxs("ol", { className: "flex items-center gap-2 text-sm font-body text-foreground/60", children: [u.jsx("li", { children: u.jsx(fe, { to: "/", className: "hover:text-primary transition-colors", children: "Home" }) }), u.jsx("li", { children: u.jsx(Xt, { className: "w-4 h-4" }) }), u.jsx("li", { className: "text-primary", children: "Privacy Policy" })] }) }), u.jsx(K.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, children: u.jsxs("h1", { className: "font-heading text-4xl md:text-5xl text-foreground mb-8", children: ["Privacy ", u.jsx("span", { className: "italic text-primary", children: "Policy" })] }) })] }) }), u.jsx("section", { className: "keens-section bg-charcoal", children: u.jsx("div", { className: "keens-container max-w-3xl", children: u.jsxs("div", { className: "prose prose-invert prose-lg font-body", children: [u.jsx("p", { className: "text-foreground/80 leading-relaxed mb-6", children: "Last updated: January 2025" }), u.jsx("p", { className: "text-foreground/80 leading-relaxed mb-6", children: 'Keens Steakhouse ("we," "our," or "us") is committed to protecting your privacy. This Privacy Policy explains how we collect, use, disclose, and safeguard your information when you visit our website or dine with us.' }), u.jsx("h2", { className: "font-heading text-2xl text-primary mt-10 mb-4", children: "Information We Collect" }), u.jsx("p", { className: "text-foreground/80 leading-relaxed mb-4", children: "We may collect personal information that you voluntarily provide to us when you:" }), u.jsxs("ul", { className: "list-disc list-inside text-foreground/80 space-y-2 mb-6", children: [u.jsx("li", { children: "Make a reservation through our website or third-party platforms" }), u.jsx("li", { children: "Inquire about private dining or events" }), u.jsx("li", { children: "Subscribe to our newsletter" }), u.jsx("li", { children: "Contact us through our website or by phone" })] }), u.jsx("h2", { className: "font-heading text-2xl text-primary mt-10 mb-4", children: "How We Use Your Information" }), u.jsx("p", { className: "text-foreground/80 leading-relaxed mb-6", children: "We use the information we collect to provide and improve our services, process reservations, respond to inquiries, and send you promotional communications with your consent." }), u.jsx("h2", { className: "font-heading text-2xl text-primary mt-10 mb-4", children: "Contact Us" }), u.jsxs("p", { className: "text-foreground/80 leading-relaxed", children: ["If you have questions about this Privacy Policy, please contact us at", " ", u.jsx("a", { href: "mailto:info@keenssteakhouse.com", className: "text-primary hover:underline", children: "info@keenssteakhouse.com" }), " ", "or call", " ", u.jsx("a", { href: "tel:+12129473636", className: "text-primary hover:underline", children: "212-947-3636" }), "."] })] }) }) })] }) } const NM = () => { const e = Js(); return x.useEffect(() => { console.error("404 Error: User attempted to access non-existent route:", e.pathname) }, [e.pathname]), u.jsx(fr, { children: u.jsx("section", { className: "min-h-[80vh] flex items-center justify-center bg-mahogany", children: u.jsxs(K.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, className: "text-center keens-container", children: [u.jsx("h1", { className: "font-heading text-8xl md:text-9xl text-primary mb-4", children: "404" }), u.jsx("h2", { className: "font-heading text-2xl md:text-3xl text-foreground mb-4 italic", children: "Lost in the Pipe Room?" }), u.jsx("p", { className: "text-foreground/70 font-body mb-8 max-w-md mx-auto", children: "It seems you've wandered into a section of Keens that doesn't exist. Even with 90,000 pipes, we can't find this page." }), u.jsxs("div", { className: "flex flex-col sm:flex-row items-center justify-center gap-4", children: [u.jsx(fe, { to: "/", className: "btn-gold", children: "Return to Home" }), u.jsx(fe, { to: "/menus", className: "btn-outline-gold", children: "View Our Menus" })] })] }) }) }) }, PM = new NN, jM = () => u.jsx(jN, { client: PM, children: u.jsxs(rN, { children: [u.jsx(zk, {}), u.jsx(vT, {}), u.jsx(EP, { children: u.jsxs(xP, { children: [u.jsx(on, { path: "/", element: u.jsx(pM, {}) }), u.jsx(on, { path: "/menus", element: u.jsx(vM, {}) }), u.jsx(on, { path: "/history", element: u.jsx(bM, {}) }), u.jsx(on, { path: "/private-dining", element: u.jsx(CM, {}) }), u.jsx(on, { path: "/reservations", element: u.jsx(kM, {}) }), u.jsx(on, { path: "/contact", element: u.jsx(TM, {}) }), u.jsx(on, { path: "/privacy", element: u.jsx(EM, {}) }), u.jsx(on, { path: "*", element: u.jsx(NM, {}) })] }) })] }) }); Xv(document.getElementById("root")).render(u.jsx(jM, {}));
